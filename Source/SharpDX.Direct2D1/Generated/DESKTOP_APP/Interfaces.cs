// <auto-generated/>

namespace SharpDX.Direct2D1
{
    [System.Runtime.InteropServices.GuidAttribute("0359dc30-95e6-4568-9055-27720d130e93")]
    public partial class AnalysisTransform : SharpDX.ComObject
    {
        public AnalysisTransform(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator AnalysisTransform(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new AnalysisTransform(nativePtr);
        /// <summary>
        /// <p>Supplies the analysis data to an analysis transform.</p>
        /// </summary>
        /// <param name = "analysisData"><dd>  <p>The data that the transform will analyze.</p> </dd></param>
        /// <param name = "analysisDataCount"><dd>  <p>The size of the analysis data.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The output of the transform will be copied to CPU-accessible memory by the imaging effects system before being passed to the implementation.</p><p> If this call fails, the corresponding <strong><see cref = "SharpDX.Direct2D1.Effect"/></strong> instance is placed into an error state and fails to draw.</p>
        /// </remarks>
        /// <doc-id>hh404348</doc-id>
        /// <unmanaged>HRESULT ID2D1AnalysisTransform::ProcessAnalysisResults([In, Buffer] const unsigned char* analysisData,[In] unsigned int analysisDataCount)</unmanaged>
        /// <unmanaged-short>ID2D1AnalysisTransform::ProcessAnalysisResults</unmanaged-short>
        internal unsafe void ProcessAnalysisResults(System.IntPtr analysisData, System.Int32 analysisDataCount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)analysisData, analysisDataCount, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("a2296057-ea42-4099-983b-539fb6505426")]
    public partial class Bitmap : SharpDX.Direct2D1.Image
    {
        public Bitmap(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Bitmap(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Bitmap(nativePtr);
        /// <summary>
        /// <p>Returns the size, in device-independent pixels (DIPs), of the bitmap.</p>
        /// </summary>
        /// <remarks>
        /// <p>A DIP is 1/96?of an inch. To retrieve the size in device pixels, use the <strong>ID2D1Bitmap::GetPixelSize</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd371170</doc-id>
        /// <unmanaged>GetSize</unmanaged>
        /// <unmanaged-short>GetSize</unmanaged-short>
        public SharpDX.Size2F Size
        {
            get => GetSize();
        }

        /// <summary>
        /// <p>Returns the size, in device-dependent units (pixels), of the bitmap.</p>
        /// </summary>
        /// <doc-id>dd371167</doc-id>
        /// <unmanaged>GetPixelSize</unmanaged>
        /// <unmanaged-short>GetPixelSize</unmanaged-short>
        public SharpDX.Size2 PixelSize
        {
            get => GetPixelSize();
        }

        /// <summary>
        /// <p>Retrieves the pixel format and alpha mode of the bitmap.</p>
        /// </summary>
        /// <doc-id>dd371164</doc-id>
        /// <unmanaged>GetPixelFormat</unmanaged>
        /// <unmanaged-short>GetPixelFormat</unmanaged-short>
        public SharpDX.Direct2D1.PixelFormat PixelFormat
        {
            get => GetPixelFormat();
        }

        /// <summary>
        /// <p>Returns the size, in device-independent pixels (DIPs), of the bitmap.</p>
        /// </summary>
        /// <returns><p>The size, in DIPs, of the bitmap.</p></returns>
        /// <remarks>
        /// <p>A DIP is 1/96?of an inch. To retrieve the size in device pixels, use the <strong>ID2D1Bitmap::GetPixelSize</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd371170</doc-id>
        /// <unmanaged>D2D_SIZE_F ID2D1Bitmap::GetSize()</unmanaged>
        /// <unmanaged-short>ID2D1Bitmap::GetSize</unmanaged-short>
        internal unsafe SharpDX.Size2F GetSize()
        {
            SharpDX.Size2F __result__;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }

        /// <summary>
        /// <p>Returns the size, in device-dependent units (pixels), of the bitmap.</p>
        /// </summary>
        /// <returns><p>The size, in pixels, of the bitmap.</p></returns>
        /// <doc-id>dd371167</doc-id>
        /// <unmanaged>D2D_SIZE_U ID2D1Bitmap::GetPixelSize()</unmanaged>
        /// <unmanaged-short>ID2D1Bitmap::GetPixelSize</unmanaged-short>
        internal unsafe SharpDX.Size2 GetPixelSize()
        {
            SharpDX.Size2 __result__;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves the pixel format and alpha mode of the bitmap.</p>
        /// </summary>
        /// <returns><p>The pixel format and alpha mode of the bitmap.</p></returns>
        /// <doc-id>dd371164</doc-id>
        /// <unmanaged>D2D1_PIXEL_FORMAT ID2D1Bitmap::GetPixelFormat()</unmanaged>
        /// <unmanaged-short>ID2D1Bitmap::GetPixelFormat</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.PixelFormat GetPixelFormat()
        {
            SharpDX.Direct2D1.PixelFormat __result__;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }

        /// <summary>
        /// <p>Return the dots per inch (DPI) of the bitmap.</p>
        /// </summary>
        /// <param name = "dpiX"><dd>  <p>The horizontal DPI of the image. You must allocate storage for this parameter.</p> </dd></param>
        /// <param name = "dpiY"><dd>  <p>The vertical DPI of the image.  You must allocate storage for this parameter.</p> </dd></param>
        /// <doc-id>dd371161</doc-id>
        /// <unmanaged>void ID2D1Bitmap::GetDpi([Out] float* dpiX,[Out] float* dpiY)</unmanaged>
        /// <unmanaged-short>ID2D1Bitmap::GetDpi</unmanaged-short>
        internal unsafe void GetDpi(out System.Single dpiX, out System.Single dpiY)
        {
            fixed (void *dpiY_ = &dpiY)
                fixed (void *dpiX_ = &dpiX)
                    SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, dpiX_, dpiY_, (*(void ***)this._nativePointer)[7]);
        }

        /// <summary>
        /// <p>Copies the specified region from the specified bitmap into the current bitmap. </p>
        /// </summary>
        /// <param name = "destPoint"><dd>  <p>In the current bitmap, the upper-left corner of the area to which the region specified by <em>srcRect</em> is copied.</p> </dd></param>
        /// <param name = "bitmap"><dd>  <p>The bitmap to copy from.</p> </dd></param>
        /// <param name = "srcRect"><dd>  <p>The area of <em>bitmap</em> to copy.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method does not update the size of the  current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion, and will fail if the bitmap formats do not match.</p><p>Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <strong><see cref = "SharpDX.Result"/></strong> and tag state will be returned at the next call to <strong>EndDraw</strong> or <strong>Flush</strong>.</p><p>Starting with Windows?8.1,  this method supports block compressed bitmaps.  If you are using a block compressed format, the end coordinates of the <em>srcRect</em> parameter must be multiples of 4 or the method returns <strong>E_INVALIDARG</strong>.</p>
        /// </remarks>
        /// <doc-id>dd371152</doc-id>
        /// <unmanaged>HRESULT ID2D1Bitmap::CopyFromBitmap([In, Optional] const D2D_POINT_2U* destPoint,[In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_U* srcRect)</unmanaged>
        /// <unmanaged-short>ID2D1Bitmap::CopyFromBitmap</unmanaged-short>
        internal unsafe void CopyFromBitmap(SharpDX.Mathematics.Interop.RawPoint? destPoint, SharpDX.Direct2D1.Bitmap bitmap, SharpDX.Mathematics.Interop.RawRectangle? srcRect)
        {
            SharpDX.Mathematics.Interop.RawPoint destPoint_;
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangle srcRect_;
            SharpDX.Result __result__;
            if (destPoint != null)
                destPoint_ = destPoint.Value;
            bitmap_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Bitmap>(bitmap);
            if (srcRect != null)
                srcRect_ = srcRect.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, destPoint == null ? (void *)0 : &destPoint_, (void *)bitmap_, srcRect == null ? (void *)0 : &srcRect_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Copies the specified region from the specified render target into the current bitmap. </p>
        /// </summary>
        /// <param name = "destPoint"><dd>  <p>In the current bitmap, the upper-left corner of the area to which the region specified by <em>srcRect</em> is copied.</p> </dd></param>
        /// <param name = "renderTarget"><dd>  <p>The render target that contains the region to copy.</p> </dd></param>
        /// <param name = "srcRect"><dd>  <p>The area of <em>renderTarget</em> to copy.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion, and will fail if the bitmap formats do not match.</p><p>Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <strong><see cref = "SharpDX.Result"/></strong> and tag state will be returned at the next call to <strong>EndDraw</strong> or <strong>Flush</strong>. </p><p>All clips and layers must be popped off of the render target before calling this method.  The method returns <strong><see cref = "RenderTargetHasLayerOrCliprect"/></strong> if any clips or layers are currently applied to the render target.</p>
        /// </remarks>
        /// <doc-id>dd371158</doc-id>
        /// <unmanaged>HRESULT ID2D1Bitmap::CopyFromRenderTarget([In, Optional] const D2D_POINT_2U* destPoint,[In] ID2D1RenderTarget* renderTarget,[In, Optional] const D2D_RECT_U* srcRect)</unmanaged>
        /// <unmanaged-short>ID2D1Bitmap::CopyFromRenderTarget</unmanaged-short>
        internal unsafe void CopyFromRenderTarget(SharpDX.Mathematics.Interop.RawPoint? destPoint, SharpDX.Direct2D1.RenderTarget renderTarget, SharpDX.Mathematics.Interop.RawRectangle? srcRect)
        {
            SharpDX.Mathematics.Interop.RawPoint destPoint_;
            System.IntPtr renderTarget_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangle srcRect_;
            SharpDX.Result __result__;
            if (destPoint != null)
                destPoint_ = destPoint.Value;
            renderTarget_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.RenderTarget>(renderTarget);
            if (srcRect != null)
                srcRect_ = srcRect.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, destPoint == null ? (void *)0 : &destPoint_, (void *)renderTarget_, srcRect == null ? (void *)0 : &srcRect_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Copies the specified region from memory into the current bitmap. </p>
        /// </summary>
        /// <param name = "dstRect"><dd>  <p>In the current bitmap, the upper-left corner of the area to which the region specified by <em>srcRect</em> is copied.</p> </dd></param>
        /// <param name = "srcData"><dd>  <p>The data to copy.</p> </dd></param>
        /// <param name = "pitch"><dd>  <p>The stride, or pitch, of the source bitmap stored in <em>srcData</em>. The stride is the byte count of a scanline (one row of pixels in memory). The stride can be computed from the following formula: pixel width * bytes per pixel + memory padding.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method does not update the size of the current bitmap. If the contents of the source bitmap do not fit in the current bitmap, this method fails. Also, note that this method does not perform format conversion; the two bitmap formats should match. </p><p>If this method is passed invalid input (such as an invalid destination rectangle), can produce unpredictable results, such as a distorted image or device failure.</p><p>Calling this method may cause the current batch to flush if the bitmap is active in the batch. If the batch that was flushed does not complete successfully, this method fails. However, this method does not clear the error state of the render target on which the batch was flushed. The failing <strong><see cref = "SharpDX.Result"/></strong> and tag state will be returned at the next call to <strong>EndDraw</strong> or <strong>Flush</strong>. </p><p>Starting with Windows?8.1,  this method supports block compressed bitmaps.  If you are using a block compressed format, the end coordinates of the <em>srcRect</em> parameter must be multiples of 4 or the method returns <strong>E_INVALIDARG</strong>.</p>
        /// </remarks>
        /// <doc-id>dd371155</doc-id>
        /// <unmanaged>HRESULT ID2D1Bitmap::CopyFromMemory([In, Optional] const D2D_RECT_U* dstRect,[In] const void* srcData,[In] unsigned int pitch)</unmanaged>
        /// <unmanaged-short>ID2D1Bitmap::CopyFromMemory</unmanaged-short>
        internal unsafe void CopyFromMemory(SharpDX.Mathematics.Interop.RawRectangle? dstRect, System.IntPtr srcData, System.Int32 pitch)
        {
            SharpDX.Mathematics.Interop.RawRectangle dstRect_;
            SharpDX.Result __result__;
            if (dstRect != null)
                dstRect_ = dstRect.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, dstRect == null ? (void *)0 : &dstRect_, (void *)srcData, pitch, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("a898a84c-3873-4588-b08b-ebbf978df041")]
    public partial class Bitmap1 : SharpDX.Direct2D1.Bitmap
    {
        public Bitmap1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Bitmap1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Bitmap1(nativePtr);
        /// <summary>
        /// <p>Gets the color context information associated with the bitmap. </p>
        /// </summary>
        /// <remarks>
        /// <p>If the bitmap was created without specifying a color context, the returned context is <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh404350</doc-id>
        /// <unmanaged>GetColorContext</unmanaged>
        /// <unmanaged-short>GetColorContext</unmanaged-short>
        public SharpDX.Direct2D1.ColorContext ColorContext
        {
            get
            {
                GetColorContext(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the options used in creating the bitmap.</p>
        /// </summary>
        /// <doc-id>hh404351</doc-id>
        /// <unmanaged>GetOptions</unmanaged>
        /// <unmanaged-short>GetOptions</unmanaged-short>
        public SharpDX.Direct2D1.BitmapOptions Options
        {
            get => GetOptions();
        }

        /// <summary>
        /// <p>Gets either the surface that was specified when the bitmap was created, or the default surface created when the bitmap was created. </p>
        /// </summary>
        /// <remarks>
        /// <p>The bitmap used must have been created from a DXGI surface render target, a derived render target, or a device context created from an <strong><see cref = "SharpDX.Direct2D1.Device"/></strong>.</p><p>The returned surface can be used with Microsoft Direct3D or any other API that interoperates with shared surfaces. The application must transitively ensure that the surface is usable on the Direct3D device that is used in this context. For example, if using the surface with Direct2D  then the Direct2D render target must have been created through <strong>ID2D1Factory::CreateDxgiSurfaceRenderTarget</strong> or on a device context created on the same device.</p>
        /// </remarks>
        /// <doc-id>hh404355</doc-id>
        /// <unmanaged>GetSurface</unmanaged>
        /// <unmanaged-short>GetSurface</unmanaged-short>
        public SharpDX.DXGI.Surface Surface
        {
            get
            {
                GetSurface(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the color context information associated with the bitmap. </p>
        /// </summary>
        /// <param name = "colorContext"><dd>  <p>When this method returns, contains the address of a reference to the  color context interface associated with the bitmap.</p> </dd></param>
        /// <remarks>
        /// <p>If the bitmap was created without specifying a color context, the returned context is <strong><c>null</c></strong>.</p>
        /// </remarks>
        /// <doc-id>hh404350</doc-id>
        /// <unmanaged>void ID2D1Bitmap1::GetColorContext([Out, Optional] ID2D1ColorContext** colorContext)</unmanaged>
        /// <unmanaged-short>ID2D1Bitmap1::GetColorContext</unmanaged-short>
        internal unsafe void GetColorContext(out SharpDX.Direct2D1.ColorContext colorContext)
        {
            System.IntPtr colorContext_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &colorContext_, (*(void ***)this._nativePointer)[11]);
            if (colorContext_ != System.IntPtr.Zero)
                colorContext = new SharpDX.Direct2D1.ColorContext(colorContext_);
            else
                colorContext = null;
        }

        /// <summary>
        /// <p>Gets the options used in creating the bitmap.</p>
        /// </summary>
        /// <returns><p>This method returns the options used.</p></returns>
        /// <doc-id>hh404351</doc-id>
        /// <unmanaged>D2D1_BITMAP_OPTIONS ID2D1Bitmap1::GetOptions()</unmanaged>
        /// <unmanaged-short>ID2D1Bitmap1::GetOptions</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.BitmapOptions GetOptions()
        {
            SharpDX.Direct2D1.BitmapOptions __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1BitmapOptions(this._nativePointer, (*(void ***)this._nativePointer)[12]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets either the surface that was specified when the bitmap was created, or the default surface created when the bitmap was created. </p>
        /// </summary>
        /// <param name = "dxgiSurface"><dd>  <p>The underlying DXGI surface for the bitmap.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref = "BitmapBoundAsTarget"/></td><td>Cannot draw with a bitmap that is currently bound as the target bitmap.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The bitmap used must have been created from a DXGI surface render target, a derived render target, or a device context created from an <strong><see cref = "SharpDX.Direct2D1.Device"/></strong>.</p><p>The returned surface can be used with Microsoft Direct3D or any other API that interoperates with shared surfaces. The application must transitively ensure that the surface is usable on the Direct3D device that is used in this context. For example, if using the surface with Direct2D  then the Direct2D render target must have been created through <strong>ID2D1Factory::CreateDxgiSurfaceRenderTarget</strong> or on a device context created on the same device.</p>
        /// </remarks>
        /// <doc-id>hh404355</doc-id>
        /// <unmanaged>HRESULT ID2D1Bitmap1::GetSurface([Out, Optional] IDXGISurface** dxgiSurface)</unmanaged>
        /// <unmanaged-short>ID2D1Bitmap1::GetSurface</unmanaged-short>
        internal unsafe void GetSurface(out SharpDX.DXGI.Surface dxgiSurface)
        {
            System.IntPtr dxgiSurface_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &dxgiSurface_, (*(void ***)this._nativePointer)[13]);
            if (dxgiSurface_ != System.IntPtr.Zero)
                dxgiSurface = new SharpDX.DXGI.Surface(dxgiSurface_);
            else
                dxgiSurface = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Maps  the given bitmap into memory.</p>
        /// </summary>
        /// <param name = "options"><dd>  <p>The options used in mapping the bitmap into memory.</p> </dd></param>
        /// <param name = "mappedRect"><dd>  <p>When this method returns, contains a reference to the rectangle that is mapped into memory.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are not valid</td></tr> <tr><td>D3DERR_DEVICELOST</td><td>The device has been lost but cannot be reset at this time.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??You can't use bitmaps for some purposes while mapped. Particularly, the <strong>ID2D1Bitmap::CopyFromBitmap</strong> method doesn't work if either the source or destination bitmap is mapped.?<p>The bitmap must have been created with the <strong>D2D1_BITMAP_OPTIONS_CPU_READ</strong> flag specified.</p>
        /// </remarks>
        /// <doc-id>hh404357</doc-id>
        /// <unmanaged>HRESULT ID2D1Bitmap1::Map([In] D2D1_MAP_OPTIONS options,[Out] D2D1_MAPPED_RECT* mappedRect)</unmanaged>
        /// <unmanaged-short>ID2D1Bitmap1::Map</unmanaged-short>
        internal unsafe void Map(SharpDX.Direct2D1.MapOptions options, out SharpDX.Direct2D1.MappedRectangle mappedRect)
        {
            mappedRect = default (SharpDX.Direct2D1.MappedRectangle);
            SharpDX.Result __result__;
            fixed (void *mappedRect_ = &mappedRect)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)options), mappedRect_, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Unmaps the bitmap from memory. </p>
        /// </summary>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are not valid.</td></tr> <tr><td>E_POINTER</td><td>Pointer is not valid.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>Any memory returned from the <strong>Map</strong> call is now invalid and may be reclaimed by the operating system or used for other purposes. </p><p>The bitmap must have been previously mapped.</p>
        /// </remarks>
        /// <doc-id>hh404359</doc-id>
        /// <unmanaged>HRESULT ID2D1Bitmap1::Unmap()</unmanaged>
        /// <unmanaged-short>ID2D1Bitmap1::Unmap</unmanaged-short>
        public unsafe void Unmap()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd906aa-12e2-11dc-9fed-001143a055f9")]
    public partial class BitmapBrush : SharpDX.Direct2D1.Brush
    {
        public BitmapBrush(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapBrush(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapBrush(nativePtr);
        /// <summary>
        /// <p>Gets or sets the method by which the brush horizontally tiles those areas that extend past its bitmap. </p>
        /// </summary>
        /// <remarks>
        /// <p>Like all brushes, <strong><see cref = "SharpDX.Direct2D1.BitmapBrush"/></strong> defines an infinite plane of content. Because bitmaps are finite, it relies on an extend mode to determine how the plane is filled horizontally and vertically.</p>
        /// </remarks>
        /// <doc-id>dd371128</doc-id>
        /// <unmanaged>GetExtendModeX / SetExtendModeX</unmanaged>
        /// <unmanaged-short>GetExtendModeX</unmanaged-short>
        public SharpDX.Direct2D1.ExtendMode ExtendModeX
        {
            get => GetExtendModeX();
            set => SetExtendModeX(value);
        }

        /// <summary>
        /// <p>Gets or sets the method by which the brush vertically tiles those areas that extend past its bitmap. </p>
        /// </summary>
        /// <remarks>
        /// <p>Like all brushes, <strong><see cref = "SharpDX.Direct2D1.BitmapBrush"/></strong> defines an infinite plane of content.  Because bitmaps are finite, it relies on an extend mode to determine how the plane is filled horizontally and vertically.</p>
        /// </remarks>
        /// <doc-id>dd371132</doc-id>
        /// <unmanaged>GetExtendModeY / SetExtendModeY</unmanaged>
        /// <unmanaged-short>GetExtendModeY</unmanaged-short>
        public SharpDX.Direct2D1.ExtendMode ExtendModeY
        {
            get => GetExtendModeY();
            set => SetExtendModeY(value);
        }

        /// <summary>
        /// <p>Gets or sets the interpolation method used when the brush bitmap is scaled or rotated. </p>
        /// </summary>
        /// <remarks>
        /// <p>This method gets the interpolation mode of a bitmap, which is specified by the <strong><see cref = "SharpDX.Direct2D1.BitmapInterpolationMode"/></strong> enumeration type.   <strong>D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR</strong> represents nearest neighbor filtering. It looks up the bitmap pixel nearest to the current rendering pixel and chooses its exact color. <strong>D2D1_BITMAP_INTERPOLATION_MODE_LINEAR</strong> represents linear filtering, and  interpolates a color from the four nearest bitmap pixels.</p><p>The interpolation mode of a bitmap also affects subpixel translations. In a subpixel translation, linear interpolation positions the bitmap more precisely to the application request, but blurs the bitmap in the process. </p>
        /// </remarks>
        /// <doc-id>dd371134</doc-id>
        /// <unmanaged>GetInterpolationMode / SetInterpolationMode</unmanaged>
        /// <unmanaged-short>GetInterpolationMode</unmanaged-short>
        public SharpDX.Direct2D1.BitmapInterpolationMode InterpolationMode
        {
            get => GetInterpolationMode();
            set => SetInterpolationMode(value);
        }

        /// <summary>
        /// <p>Gets or sets the bitmap source that this brush uses to paint.</p>
        /// </summary>
        /// <doc-id>dd371124</doc-id>
        /// <unmanaged>GetBitmap / SetBitmap</unmanaged>
        /// <unmanaged-short>GetBitmap</unmanaged-short>
        public SharpDX.Direct2D1.Bitmap Bitmap
        {
            get
            {
                GetBitmap(out var __output__);
                return __output__;
            }

            set => SetBitmap(value);
        }

        /// <summary>
        /// <p>Specifies how the brush horizontally tiles those areas that extend past its bitmap. </p>
        /// </summary>
        /// <param name = "extendModeX"><dd>  <p>A value that specifies how the brush horizontally tiles those areas that extend past its bitmap. </p> </dd></param>
        /// <remarks>
        /// <p>Sometimes, the  bitmap for a bitmap brush doesn't completely fill the area being painted. When this happens, Direct2D uses the brush's horizontal (<strong>SetExtendModeX</strong>) and vertical (<strong>SetExtendModeY</strong>) extend mode settings to determine how to fill the remaining area.</p><p>The following illustration shows the results from  every  possible combination of the extend modes for an <strong><see cref = "SharpDX.Direct2D1.BitmapBrush"/></strong>: <strong>D2D1_EXTEND_MODE_CLAMP</strong> (CLAMP), <strong>D2D1_EXTEND_MODE_WRAP</strong> (WRAP), and <strong>D2D1_EXTEND_MIRROR</strong> (MIRROR).</p><p></p>
        /// </remarks>
        /// <doc-id>dd371139</doc-id>
        /// <unmanaged>void ID2D1BitmapBrush::SetExtendModeX([In] D2D1_EXTEND_MODE extendModeX)</unmanaged>
        /// <unmanaged-short>ID2D1BitmapBrush::SetExtendModeX</unmanaged-short>
        internal unsafe void SetExtendModeX(SharpDX.Direct2D1.ExtendMode extendModeX)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)extendModeX), (*(void ***)this._nativePointer)[8]);
        }

        /// <summary>
        /// <p>Specifies how the brush vertically tiles those areas that extend past its bitmap.</p>
        /// </summary>
        /// <param name = "extendModeY"><dd>  <p>A value that specifies how the brush vertically tiles those areas that extend past its bitmap.</p> </dd></param>
        /// <remarks>
        /// <p>Sometimes, the  bitmap for a bitmap brush doesn't completely fill the area being painted. When this happens, Direct2D uses the brush's horizontal (<strong>SetExtendModeX</strong>) and vertical (<strong>SetExtendModeY</strong>) extend mode settings to determine how to fill the remaining area.</p><p>The following illustration shows the results from  every  possible combination of the extend modes for an <strong><see cref = "SharpDX.Direct2D1.BitmapBrush"/></strong>: <strong>D2D1_EXTEND_MODE_CLAMP</strong> (CLAMP), <strong>D2D1_EXTEND_MODE_WRAP</strong> (WRAP), and <strong>D2D1_EXTEND_MIRROR</strong> (MIRROR).</p><p></p>
        /// </remarks>
        /// <doc-id>dd371142</doc-id>
        /// <unmanaged>void ID2D1BitmapBrush::SetExtendModeY([In] D2D1_EXTEND_MODE extendModeY)</unmanaged>
        /// <unmanaged-short>ID2D1BitmapBrush::SetExtendModeY</unmanaged-short>
        internal unsafe void SetExtendModeY(SharpDX.Direct2D1.ExtendMode extendModeY)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)extendModeY), (*(void ***)this._nativePointer)[9]);
        }

        /// <summary>
        /// <p>Specifies the interpolation mode used when the brush bitmap is scaled or rotated.</p>
        /// </summary>
        /// <param name = "interpolationMode"><dd>  <p>The interpolation mode used when the brush bitmap is scaled or rotated.</p> </dd></param>
        /// <remarks>
        /// <p>This method sets the interpolation mode for a bitmap, which is an enum value that is specified in the <strong><see cref = "SharpDX.Direct2D1.BitmapInterpolationMode"/></strong> enumeration type.   D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR represents nearest neighbor filtering. It looks up the nearest bitmap pixel to the current rendering pixel and chooses its exact color. D2D1_BITMAP_INTERPOLATION_MODE_LINEAR represents linear filtering, and  interpolates a color from the four nearest bitmap pixels.</p><p>The interpolation mode of a bitmap also affects subpixel translations. In a subpixel translation, bilinear interpolation positions the bitmap more precisely to the application requests, but blurs the bitmap in the process. </p>
        /// </remarks>
        /// <doc-id>dd371145</doc-id>
        /// <unmanaged>void ID2D1BitmapBrush::SetInterpolationMode([In] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode)</unmanaged>
        /// <unmanaged-short>ID2D1BitmapBrush::SetInterpolationMode</unmanaged-short>
        internal unsafe void SetInterpolationMode(SharpDX.Direct2D1.BitmapInterpolationMode interpolationMode)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)interpolationMode), (*(void ***)this._nativePointer)[10]);
        }

        /// <summary>
        /// <p>Specifies the bitmap source that this brush uses to paint. </p>
        /// </summary>
        /// <param name = "bitmap"><dd>  <p>The bitmap source used by the brush.</p> </dd></param>
        /// <remarks>
        /// <p>This method specifies the bitmap source that this brush uses to paint. The bitmap is not resized or rescaled automatically to fit the geometry that it fills. The bitmap stays at its native size. To resize or translate the bitmap, use the <strong>SetTransform</strong> method to apply  a transform to the brush. </p><p>The native size of a bitmap is the width and height in bitmap pixels, divided by the bitmap DPI. This native size forms the base tile of the brush. To tile a subregion of the bitmap, you must generate a new bitmap containing this subregion and use <strong>SetBitmap</strong> to apply it to the brush. 
        /// </p>
        /// </remarks>
        /// <doc-id>dd371136</doc-id>
        /// <unmanaged>void ID2D1BitmapBrush::SetBitmap([In, Optional] ID2D1Bitmap* bitmap)</unmanaged>
        /// <unmanaged-short>ID2D1BitmapBrush::SetBitmap</unmanaged-short>
        internal unsafe void SetBitmap(SharpDX.Direct2D1.Bitmap bitmap)
        {
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            bitmap_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Bitmap>(bitmap);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)bitmap_, (*(void ***)this._nativePointer)[11]);
        }

        /// <summary>
        /// <p> Gets the method by which the brush horizontally tiles those areas that extend past its bitmap. </p>
        /// </summary>
        /// <returns><p>A value that specifies how the brush horizontally tiles those areas that extend past its bitmap.</p></returns>
        /// <remarks>
        /// <p>Like all brushes, <strong><see cref = "SharpDX.Direct2D1.BitmapBrush"/></strong> defines an infinite plane of content. Because bitmaps are finite, it relies on an extend mode to determine how the plane is filled horizontally and vertically.</p>
        /// </remarks>
        /// <doc-id>dd371128</doc-id>
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1BitmapBrush::GetExtendModeX()</unmanaged>
        /// <unmanaged-short>ID2D1BitmapBrush::GetExtendModeX</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.ExtendMode GetExtendModeX()
        {
            SharpDX.Direct2D1.ExtendMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1ExtendMode(this._nativePointer, (*(void ***)this._nativePointer)[12]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the method by which the brush vertically tiles those areas that extend past its bitmap. </p>
        /// </summary>
        /// <returns><p>A value that specifies how the brush vertically tiles those areas that extend past its bitmap.</p></returns>
        /// <remarks>
        /// <p>Like all brushes, <strong><see cref = "SharpDX.Direct2D1.BitmapBrush"/></strong> defines an infinite plane of content.  Because bitmaps are finite, it relies on an extend mode to determine how the plane is filled horizontally and vertically.</p>
        /// </remarks>
        /// <doc-id>dd371132</doc-id>
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1BitmapBrush::GetExtendModeY()</unmanaged>
        /// <unmanaged-short>ID2D1BitmapBrush::GetExtendModeY</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.ExtendMode GetExtendModeY()
        {
            SharpDX.Direct2D1.ExtendMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1ExtendMode(this._nativePointer, (*(void ***)this._nativePointer)[13]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the interpolation method used when the brush bitmap is scaled or rotated. </p>
        /// </summary>
        /// <returns><p>The interpolation method used when the brush bitmap is scaled or rotated.</p></returns>
        /// <remarks>
        /// <p>This method gets the interpolation mode of a bitmap, which is specified by the <strong><see cref = "SharpDX.Direct2D1.BitmapInterpolationMode"/></strong> enumeration type.   <strong>D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR</strong> represents nearest neighbor filtering. It looks up the bitmap pixel nearest to the current rendering pixel and chooses its exact color. <strong>D2D1_BITMAP_INTERPOLATION_MODE_LINEAR</strong> represents linear filtering, and  interpolates a color from the four nearest bitmap pixels.</p><p>The interpolation mode of a bitmap also affects subpixel translations. In a subpixel translation, linear interpolation positions the bitmap more precisely to the application request, but blurs the bitmap in the process. </p>
        /// </remarks>
        /// <doc-id>dd371134</doc-id>
        /// <unmanaged>D2D1_BITMAP_INTERPOLATION_MODE ID2D1BitmapBrush::GetInterpolationMode()</unmanaged>
        /// <unmanaged-short>ID2D1BitmapBrush::GetInterpolationMode</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.BitmapInterpolationMode GetInterpolationMode()
        {
            SharpDX.Direct2D1.BitmapInterpolationMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1BitmapInterpolationMode(this._nativePointer, (*(void ***)this._nativePointer)[14]);
            return __result__;
        }

        /// <summary>
        /// <p> Gets the bitmap source that this brush uses to paint.</p>
        /// </summary>
        /// <param name = "bitmap"><dd>  <p>When this method returns, contains the address to a reference to the bitmap with which this brush paints.</p> </dd></param>
        /// <doc-id>dd371124</doc-id>
        /// <unmanaged>void ID2D1BitmapBrush::GetBitmap([Out, Optional] ID2D1Bitmap** bitmap)</unmanaged>
        /// <unmanaged-short>ID2D1BitmapBrush::GetBitmap</unmanaged-short>
        internal unsafe void GetBitmap(out SharpDX.Direct2D1.Bitmap bitmap)
        {
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &bitmap_, (*(void ***)this._nativePointer)[15]);
            if (bitmap_ != System.IntPtr.Zero)
                bitmap = new SharpDX.Direct2D1.Bitmap(bitmap_);
            else
                bitmap = null;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("41343a53-e41a-49a2-91cd-21793bbb62e5")]
    public partial class BitmapBrush1 : SharpDX.Direct2D1.BitmapBrush
    {
        public BitmapBrush1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapBrush1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapBrush1(nativePtr);
        /// <summary>
        /// <p>Returns or sets the current interpolation mode of the brush.</p>
        /// </summary>
        /// <doc-id>hh871448</doc-id>
        /// <unmanaged>GetInterpolationMode1 / SetInterpolationMode1</unmanaged>
        /// <unmanaged-short>GetInterpolationMode1</unmanaged-short>
        public SharpDX.Direct2D1.InterpolationMode InterpolationMode1
        {
            get => GetInterpolationMode1();
            set => SetInterpolationMode1(value);
        }

        /// <summary>
        /// <p>Sets the interpolation mode for the brush.</p>
        /// </summary>
        /// <param name = "interpolationMode"><dd>  <p>The mode to use.</p> </dd></param>
        /// <doc-id>hh871449</doc-id>
        /// <unmanaged>void ID2D1BitmapBrush1::SetInterpolationMode1([In] D2D1_INTERPOLATION_MODE interpolationMode)</unmanaged>
        /// <unmanaged-short>ID2D1BitmapBrush1::SetInterpolationMode1</unmanaged-short>
        internal unsafe void SetInterpolationMode1(SharpDX.Direct2D1.InterpolationMode interpolationMode)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)interpolationMode), (*(void ***)this._nativePointer)[16]);
        }

        /// <summary>
        /// <p>Returns the current interpolation mode of the brush.</p>
        /// </summary>
        /// <returns><p>The current interpolation mode.</p></returns>
        /// <doc-id>hh871448</doc-id>
        /// <unmanaged>D2D1_INTERPOLATION_MODE ID2D1BitmapBrush1::GetInterpolationMode1()</unmanaged>
        /// <unmanaged-short>ID2D1BitmapBrush1::GetInterpolationMode1</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.InterpolationMode GetInterpolationMode1()
        {
            SharpDX.Direct2D1.InterpolationMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1InterpolationMode(this._nativePointer, (*(void ***)this._nativePointer)[17]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd90695-12e2-11dc-9fed-001143a055f9")]
    public partial class BitmapRenderTarget : SharpDX.Direct2D1.RenderTarget
    {
        public BitmapRenderTarget(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BitmapRenderTarget(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BitmapRenderTarget(nativePtr);
        /// <summary>
        /// <p>Retrieves the bitmap for this render target. The returned bitmap can be used for drawing operations. </p>
        /// </summary>
        /// <remarks>
        /// <p>The DPI for the <strong><see cref = "SharpDX.Direct2D1.Bitmap"/></strong> obtained from <strong>GetBitmap</strong> will be the DPI of the <strong><see cref = "SharpDX.Direct2D1.BitmapRenderTarget"/></strong> when the render target was created. Changing the DPI of the <strong><see cref = "SharpDX.Direct2D1.BitmapRenderTarget"/></strong> by calling  <strong>SetDpi</strong> doesn't affect the DPI of the bitmap, even if <strong>SetDpi</strong> is called before <strong>GetBitmap</strong>. Using <strong>SetDpi</strong> to change the DPI of the <strong><see cref = "SharpDX.Direct2D1.BitmapRenderTarget"/></strong> does affect how contents are rendered into the bitmap: it just doesn't affect the DPI of the bitmap retrieved by <strong>GetBitmap</strong>.</p>
        /// </remarks>
        /// <doc-id>dd371150</doc-id>
        /// <unmanaged>GetBitmap</unmanaged>
        /// <unmanaged-short>GetBitmap</unmanaged-short>
        public SharpDX.Direct2D1.Bitmap Bitmap
        {
            get
            {
                GetBitmap(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves the bitmap for this render target. The returned bitmap can be used for drawing operations. </p>
        /// </summary>
        /// <param name = "bitmap"><dd>  <p>When this method returns, contains the address of a reference to the bitmap for this render target. This bitmap can be used for drawing operations. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The DPI for the <strong><see cref = "SharpDX.Direct2D1.Bitmap"/></strong> obtained from <strong>GetBitmap</strong> will be the DPI of the <strong><see cref = "SharpDX.Direct2D1.BitmapRenderTarget"/></strong> when the render target was created. Changing the DPI of the <strong><see cref = "SharpDX.Direct2D1.BitmapRenderTarget"/></strong> by calling  <strong>SetDpi</strong> doesn't affect the DPI of the bitmap, even if <strong>SetDpi</strong> is called before <strong>GetBitmap</strong>. Using <strong>SetDpi</strong> to change the DPI of the <strong><see cref = "SharpDX.Direct2D1.BitmapRenderTarget"/></strong> does affect how contents are rendered into the bitmap: it just doesn't affect the DPI of the bitmap retrieved by <strong>GetBitmap</strong>.</p>
        /// </remarks>
        /// <doc-id>dd371150</doc-id>
        /// <unmanaged>HRESULT ID2D1BitmapRenderTarget::GetBitmap([Out] ID2D1Bitmap** bitmap)</unmanaged>
        /// <unmanaged-short>ID2D1BitmapRenderTarget::GetBitmap</unmanaged-short>
        internal unsafe void GetBitmap(out SharpDX.Direct2D1.Bitmap bitmap)
        {
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &bitmap_, (*(void ***)this._nativePointer)[57]);
            if (bitmap_ != System.IntPtr.Zero)
                bitmap = new SharpDX.Direct2D1.Bitmap(bitmap_);
            else
                bitmap = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("63ac0b32-ba44-450f-8806-7f4ca1ff2f1b")]
    public partial class BlendTransform : SharpDX.Direct2D1.ConcreteTransform
    {
        public BlendTransform(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BlendTransform(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BlendTransform(nativePtr);
        /// <summary>
        /// <p>Gets or sets the blend description of the corresponding blend transform object.</p>
        /// </summary>
        /// <doc-id>hh404363</doc-id>
        /// <unmanaged>GetDescription / SetDescription</unmanaged>
        /// <unmanaged-short>GetDescription</unmanaged-short>
        public SharpDX.Direct2D1.BlendDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }

            set => SetDescription(ref value);
        }

        /// <summary>
        /// <p>Changes the blend description of the corresponding blend transform object.</p>
        /// </summary>
        /// <param name = "description"><dd>  <p>The new blend description specified for the blend transform.</p> </dd></param>
        /// <doc-id>hh404365</doc-id>
        /// <unmanaged>void ID2D1BlendTransform::SetDescription([In] const D2D1_BLEND_DESCRIPTION* description)</unmanaged>
        /// <unmanaged-short>ID2D1BlendTransform::SetDescription</unmanaged-short>
        internal unsafe void SetDescription(ref SharpDX.Direct2D1.BlendDescription description)
        {
            fixed (void *description_ = &description)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, description_, (*(void ***)this._nativePointer)[6]);
        }

        /// <summary>
        /// <p>Gets the blend description of the corresponding blend transform object.</p>
        /// </summary>
        /// <param name = "description"><dd>  <p>When this method returns, contains the blend description specified for the blend transform.</p> </dd></param>
        /// <doc-id>hh404363</doc-id>
        /// <unmanaged>void ID2D1BlendTransform::GetDescription([Out] D2D1_BLEND_DESCRIPTION* description)</unmanaged>
        /// <unmanaged-short>ID2D1BlendTransform::GetDescription</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct2D1.BlendDescription description)
        {
            description = default (SharpDX.Direct2D1.BlendDescription);
            fixed (void *description_ = &description)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, description_, (*(void ***)this._nativePointer)[7]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("4998735c-3a19-473c-9781-656847e3a347")]
    public partial class BorderTransform : SharpDX.Direct2D1.ConcreteTransform
    {
        public BorderTransform(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BorderTransform(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BorderTransform(nativePtr);
        /// <summary>
        /// <p>Gets or sets the extend mode in the x direction.</p>
        /// </summary>
        /// <doc-id>hh404381</doc-id>
        /// <unmanaged>GetExtendModeX / SetExtendModeX</unmanaged>
        /// <unmanaged-short>GetExtendModeX</unmanaged-short>
        public SharpDX.Direct2D1.ExtendMode ExtendModeX
        {
            get => GetExtendModeX();
            set => SetExtendModeX(value);
        }

        /// <summary>
        /// <p>Gets or sets the extend mode in the y direction.</p>
        /// </summary>
        /// <doc-id>hh404383</doc-id>
        /// <unmanaged>GetExtendModeY / SetExtendModeY</unmanaged>
        /// <unmanaged-short>GetExtendModeY</unmanaged-short>
        public SharpDX.Direct2D1.ExtendMode ExtendModeY
        {
            get => GetExtendModeY();
            set => SetExtendModeY(value);
        }

        /// <summary>
        /// <p>Sets the extend mode in the x direction.</p>
        /// </summary>
        /// <param name = "extendMode"><dd>  <p>The extend mode in the x direction.</p> </dd></param>
        /// <remarks>
        /// <p>If the extend mode enumeration is invalid, this operation is ignored.</p>
        /// </remarks>
        /// <doc-id>hh404385</doc-id>
        /// <unmanaged>void ID2D1BorderTransform::SetExtendModeX([In] D2D1_EXTEND_MODE extendMode)</unmanaged>
        /// <unmanaged-short>ID2D1BorderTransform::SetExtendModeX</unmanaged-short>
        internal unsafe void SetExtendModeX(SharpDX.Direct2D1.ExtendMode extendMode)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)extendMode), (*(void ***)this._nativePointer)[6]);
        }

        /// <summary>
        /// <p>Sets the extend mode in the y direction.</p>
        /// </summary>
        /// <param name = "extendMode"><dd>  <p>The extend mode in the y direction.</p> </dd></param>
        /// <remarks>
        /// <p>If the extend mode enumeration is invalid, this operation is ignored.</p>
        /// </remarks>
        /// <doc-id>hh404387</doc-id>
        /// <unmanaged>void ID2D1BorderTransform::SetExtendModeY([In] D2D1_EXTEND_MODE extendMode)</unmanaged>
        /// <unmanaged-short>ID2D1BorderTransform::SetExtendModeY</unmanaged-short>
        internal unsafe void SetExtendModeY(SharpDX.Direct2D1.ExtendMode extendMode)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)extendMode), (*(void ***)this._nativePointer)[7]);
        }

        /// <summary>
        /// <p>Gets the extend mode in the x direction.</p>
        /// </summary>
        /// <returns><p>This method returns the extend mode in the x direction.</p></returns>
        /// <doc-id>hh404381</doc-id>
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1BorderTransform::GetExtendModeX()</unmanaged>
        /// <unmanaged-short>ID2D1BorderTransform::GetExtendModeX</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.ExtendMode GetExtendModeX()
        {
            SharpDX.Direct2D1.ExtendMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1ExtendMode(this._nativePointer, (*(void ***)this._nativePointer)[8]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the extend mode in the y direction.</p>
        /// </summary>
        /// <returns><p>This method returns the extend mode in the y direction.</p></returns>
        /// <doc-id>hh404383</doc-id>
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1BorderTransform::GetExtendModeY()</unmanaged>
        /// <unmanaged-short>ID2D1BorderTransform::GetExtendModeY</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.ExtendMode GetExtendModeY()
        {
            SharpDX.Direct2D1.ExtendMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1ExtendMode(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("90f732e2-5092-4606-a819-8651970baccd")]
    public partial class BoundsAdjustmentTransform : SharpDX.Direct2D1.TransformNodeNative
    {
        public BoundsAdjustmentTransform(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator BoundsAdjustmentTransform(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new BoundsAdjustmentTransform(nativePtr);
        /// <summary>
        /// <p>Returns or sets the output rectangle of the support transform.</p>
        /// </summary>
        /// <doc-id>hh847964</doc-id>
        /// <unmanaged>GetOutputBounds / SetOutputBounds</unmanaged>
        /// <unmanaged-short>GetOutputBounds</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangle OutputBounds
        {
            get
            {
                GetOutputBounds(out var __output__);
                return __output__;
            }

            set => SetOutputBounds(value);
        }

        /// <summary>
        /// <p>This sets the output bounds for the support transform.</p>
        /// </summary>
        /// <param name = "outputBounds"><dd>  <p>The output bounds.</p> </dd></param>
        /// <doc-id>hh847965</doc-id>
        /// <unmanaged>void ID2D1BoundsAdjustmentTransform::SetOutputBounds([In] const RECT* outputBounds)</unmanaged>
        /// <unmanaged-short>ID2D1BoundsAdjustmentTransform::SetOutputBounds</unmanaged-short>
        internal unsafe void SetOutputBounds(SharpDX.Mathematics.Interop.RawRectangle outputBounds)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &outputBounds, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p>Returns the output rectangle of the support transform.</p>
        /// </summary>
        /// <param name = "outputBounds"><dd>  <p>The output bounds.</p> </dd></param>
        /// <doc-id>hh847964</doc-id>
        /// <unmanaged>void ID2D1BoundsAdjustmentTransform::GetOutputBounds([Out] RECT* outputBounds)</unmanaged>
        /// <unmanaged-short>ID2D1BoundsAdjustmentTransform::GetOutputBounds</unmanaged-short>
        internal unsafe void GetOutputBounds(out SharpDX.Mathematics.Interop.RawRectangle outputBounds)
        {
            outputBounds = default (SharpDX.Mathematics.Interop.RawRectangle);
            fixed (void *outputBounds_ = &outputBounds)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, outputBounds_, (*(void ***)this._nativePointer)[5]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd906a8-12e2-11dc-9fed-001143a055f9")]
    public partial class Brush : SharpDX.Direct2D1.Resource
    {
        public Brush(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Brush(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Brush(nativePtr);
        /// <summary>
        /// <p>Gets or sets the degree of opacity of this brush.   </p>
        /// </summary>
        /// <doc-id>dd371176</doc-id>
        /// <unmanaged>GetOpacity / SetOpacity</unmanaged>
        /// <unmanaged-short>GetOpacity</unmanaged-short>
        public System.Single Opacity
        {
            get => GetOpacity();
            set => SetOpacity(value);
        }

        /// <summary>
        /// <p>Gets or sets the transform applied to this brush. </p>
        /// </summary>
        /// <remarks>
        /// <p>When the brush transform is the identity matrix, the brush appears in the same coordinate space as the render target in which it is drawn.</p>
        /// </remarks>
        /// <doc-id>dd371179</doc-id>
        /// <unmanaged>GetTransform / SetTransform</unmanaged>
        /// <unmanaged-short>GetTransform</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 Transform
        {
            get
            {
                GetTransform(out var __output__);
                return __output__;
            }

            set => SetTransform(ref value);
        }

        /// <summary>
        /// <p>Sets the degree of opacity of this brush.</p>
        /// </summary>
        /// <param name = "opacity"><dd>  <p>A value between zero and 1 that indicates the opacity of the brush. This value is a constant multiplier that linearly scales the alpha value of all pixels filled by the brush. The opacity values are clamped in the range 0?1 before they are multipled together. </p> </dd></param>
        /// <doc-id>dd371181</doc-id>
        /// <unmanaged>void ID2D1Brush::SetOpacity([In] float opacity)</unmanaged>
        /// <unmanaged-short>ID2D1Brush::SetOpacity</unmanaged-short>
        internal unsafe void SetOpacity(System.Single opacity)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, opacity, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p> Sets the transformation applied to the brush.</p>
        /// </summary>
        /// <param name = "transform"><dd>  <p>The transformation to apply to this brush.</p> </dd></param>
        /// <remarks>
        /// <p>When you paint with a brush, it paints in the coordinate space of the render target. Brushes do not automatically position themselves to align with the object being painted; by default, they begin painting at the origin (0, 0) of the render target. </p><p>You can "move" the gradient defined by an <strong><see cref = "SharpDX.Direct2D1.LinearGradientBrush"/></strong> to a target area by setting its start point and end point. Likewise, you can move the gradient defined by an <strong><see cref = "SharpDX.Direct2D1.RadialGradientBrush"/></strong> by changing its center and radii. </p><p>To align the content of an <strong><see cref = "SharpDX.Direct2D1.BitmapBrush"/></strong> to the area being painted, you can use the <strong>SetTransform</strong> method to translate the bitmap to the desired location. This transform only affects the brush; it does not affect any other content drawn by the render target. </p><p>The following illustrations show the effect of using an <strong><see cref = "SharpDX.Direct2D1.BitmapBrush"/></strong> to fill a rectangle located at (100, 100). The illustration on the left illustration shows the result of filling the rectangle without transforming the brush: the bitmap is drawn at the render target's origin. As a result, only a portion of the bitmap appears in the rectangle.</p><p>The illustration on the right shows the result of transforming the <strong><see cref = "SharpDX.Direct2D1.BitmapBrush"/></strong> so that its content is shifted 50 pixels to the right and 50 pixels down. The bitmap now fills the rectangle.</p><p></p>
        /// </remarks>
        /// <doc-id>dd371186</doc-id>
        /// <unmanaged>void ID2D1Brush::SetTransform([In] const D2D_MATRIX_3X2_F* transform)</unmanaged>
        /// <unmanaged-short>ID2D1Brush::SetTransform</unmanaged-short>
        internal unsafe void SetTransform(ref SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            fixed (void *transform_ = &transform)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, transform_, (*(void ***)this._nativePointer)[5]);
        }

        /// <summary>
        /// <p>Gets the degree of opacity of this brush.   </p>
        /// </summary>
        /// <returns><p>A value between zero and 1 that indicates the opacity of the brush. This value is a constant multiplier that linearly scales the alpha value of all pixels filled by the brush. The opacity values are clamped in the range 0?1 before they are multipled together. </p></returns>
        /// <doc-id>dd371176</doc-id>
        /// <unmanaged>float ID2D1Brush::GetOpacity()</unmanaged>
        /// <unmanaged-short>ID2D1Brush::GetOpacity</unmanaged-short>
        internal unsafe System.Single GetOpacity()
        {
            System.Single __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallfloat(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the transform applied to this brush. </p>
        /// </summary>
        /// <param name = "transform"><dd>  <p>The transform applied to this brush.</p> </dd></param>
        /// <remarks>
        /// <p>When the brush transform is the identity matrix, the brush appears in the same coordinate space as the render target in which it is drawn.</p>
        /// </remarks>
        /// <doc-id>dd371179</doc-id>
        /// <unmanaged>void ID2D1Brush::GetTransform([Out] D2D_MATRIX_3X2_F* transform)</unmanaged>
        /// <unmanaged-short>ID2D1Brush::GetTransform</unmanaged-short>
        internal unsafe void GetTransform(out SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            transform = default (SharpDX.Mathematics.Interop.RawMatrix3x2);
            fixed (void *transform_ = &transform)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, transform_, (*(void ***)this._nativePointer)[7]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("1c4820bb-5771-4518-a581-2fe4dd0ec657")]
    public partial class ColorContext : SharpDX.Direct2D1.Resource
    {
        public ColorContext(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ColorContext(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ColorContext(nativePtr);
        /// <summary>
        /// <p>Gets the color space  of the color context.</p>
        /// </summary>
        /// <doc-id>dn890780</doc-id>
        /// <unmanaged>GetColorSpace</unmanaged>
        /// <unmanaged-short>GetColorSpace</unmanaged-short>
        public SharpDX.Direct2D1.ColorSpace ColorSpace
        {
            get => GetColorSpace();
        }

        /// <summary>
        /// <p>Gets the size of the color profile associated with the bitmap. 	</p>
        /// </summary>
        /// <remarks>
        /// <p>This can be used to allocate a buffer to receive the color profile bytes associated with the context.</p>
        /// </remarks>
        /// <doc-id>hh404390</doc-id>
        /// <unmanaged>GetProfileSize</unmanaged>
        /// <unmanaged-short>GetProfileSize</unmanaged-short>
        internal System.Int32 ProfileSize
        {
            get => GetProfileSize();
        }

        /// <summary>
        /// <p>Gets the color space  of the color context.</p>
        /// </summary>
        /// <returns><p>This method returns the color space of the contained ICC profile.</p></returns>
        /// <doc-id>dn890780</doc-id>
        /// <unmanaged>D2D1_COLOR_SPACE ID2D1ColorContext::GetColorSpace()</unmanaged>
        /// <unmanaged-short>ID2D1ColorContext::GetColorSpace</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.ColorSpace GetColorSpace()
        {
            SharpDX.Direct2D1.ColorSpace __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1ColorSpace(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the size of the color profile associated with the bitmap. 	</p>
        /// </summary>
        /// <returns><p>This method returns the  size of the profile in bytes.</p></returns>
        /// <remarks>
        /// <p>This can be used to allocate a buffer to receive the color profile bytes associated with the context.</p>
        /// </remarks>
        /// <doc-id>hh404390</doc-id>
        /// <unmanaged>unsigned int ID2D1ColorContext::GetProfileSize()</unmanaged>
        /// <unmanaged-short>ID2D1ColorContext::GetProfileSize</unmanaged-short>
        internal unsafe System.Int32 GetProfileSize()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the color profile bytes for an <strong><see cref = "SharpDX.Direct2D1.ColorContext"/></strong>. </p>
        /// </summary>
        /// <param name = "rofileRef">No documentation.</param>
        /// <param name = "profileSize">No documentation.</param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref = "InsufficientBuffer"/></td><td>The supplied buffer was too small to accomodate the data.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>If <em>profileSize</em> is insufficient to store the entire profile, <em>profile</em> is zero-initialized before this method fails.</p>
        /// </remarks>
        /// <doc-id>hh404389</doc-id>
        /// <unmanaged>HRESULT ID2D1ColorContext::GetProfile([Out, Buffer] unsigned char* profile,[In] unsigned int profileSize)</unmanaged>
        /// <unmanaged-short>ID2D1ColorContext::GetProfile</unmanaged-short>
        internal unsafe void GetProfile(System.Byte[] rofileRef, System.Int32 profileSize)
        {
            SharpDX.Result __result__;
            fixed (void *rofileRef_ = rofileRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, rofileRef_, profileSize, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("1ab42875-c57f-4be9-bd85-9cd78d6f55ee")]
    public partial class ColorContext1 : SharpDX.Direct2D1.ColorContext
    {
        public ColorContext1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ColorContext1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ColorContext1(nativePtr);
        /// <summary>
        /// <p>Represents a color context to be used with the Color Management Effect.</p>
        /// </summary>
        /// <doc-id>mt797797</doc-id>
        /// <unmanaged>GetColorContextType</unmanaged>
        /// <unmanaged-short>GetColorContextType</unmanaged-short>
        public SharpDX.Direct2D1.ColorContextType ColorContextType
        {
            get => GetColorContextType();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetDXGIColorSpace</unmanaged>
        /// <unmanaged-short>GetDXGIColorSpace</unmanaged-short>
        public SharpDX.DXGI.ColorSpaceType DXGIColorSpace
        {
            get => GetDXGIColorSpace();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetSimpleColorProfile</unmanaged>
        /// <unmanaged-short>GetSimpleColorProfile</unmanaged-short>
        public SharpDX.Direct2D1.SimpleColorProfile SimpleColorProfile
        {
            get
            {
                GetSimpleColorProfile(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Represents a color context to be used with the Color Management Effect.</p>
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <doc-id>mt797797</doc-id>
        /// <unmanaged>D2D1_COLOR_CONTEXT_TYPE ID2D1ColorContext1::GetColorContextType()</unmanaged>
        /// <unmanaged-short>ID2D1ColorContext1::GetColorContextType</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.ColorContextType GetColorContextType()
        {
            SharpDX.Direct2D1.ColorContextType __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1ColorContextType(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>DXGI_COLOR_SPACE_TYPE ID2D1ColorContext1::GetDXGIColorSpace()</unmanaged>
        /// <unmanaged-short>ID2D1ColorContext1::GetDXGIColorSpace</unmanaged-short>
        internal unsafe SharpDX.DXGI.ColorSpaceType GetDXGIColorSpace()
        {
            SharpDX.DXGI.ColorSpaceType __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDXGIColorSpaceType(this._nativePointer, (*(void ***)this._nativePointer)[8]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "simpleProfile">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1ColorContext1::GetSimpleColorProfile([Out] D2D1_SIMPLE_COLOR_PROFILE* simpleProfile)</unmanaged>
        /// <unmanaged-short>ID2D1ColorContext1::GetSimpleColorProfile</unmanaged-short>
        internal unsafe void GetSimpleColorProfile(out SharpDX.Direct2D1.SimpleColorProfile simpleProfile)
        {
            simpleProfile = default (SharpDX.Direct2D1.SimpleColorProfile);
            SharpDX.Result __result__;
            fixed (void *simpleProfile_ = &simpleProfile)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, simpleProfile_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("b4f34a19-2383-4d76-94f6-ec343657c3dc")]
    public partial class CommandList : SharpDX.Direct2D1.Image
    {
        public CommandList(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator CommandList(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new CommandList(nativePtr);
        /// <summary>
        /// <p>Streams the contents of the command list  to the specified command sink. </p>
        /// </summary>
        /// <param name = "sink"><dd>  <p>The sink into which the command list will be streamed.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p><p>The return value indicates any failures the command sink implementation  returns through its <strong>EndDraw</strong> method.</p></returns>
        /// <remarks>
        /// <p>The command sink can be implemented by any caller of the API.</p><p>If the caller makes any design-time failure calls while a command list is selected as a target, the command list is placed in an error state. The stream call fails without making any calls to the passed in sink.</p><p>Sample use:</p><pre>Class MyCommandSink : public <see cref = "SharpDX.Direct2D1.CommandSink"/>
        /// {
        /// public: // All of the <see cref = "SharpDX.Direct2D1.CommandSink"/> methods implemented here.
        /// }; <see cref = "SharpDX.Result"/>
        /// StreamToMyCommandSink( __in <see cref = "SharpDX.Direct2D1.CommandList"/> *pCommandList  )
        /// { <see cref = "SharpDX.Result"/> hr = <see cref = "SharpDX.Result.Ok"/>; MyCommandSink *pCommandSink = new MyCommandSink(); hr = pCommandSink ? <see cref = "SharpDX.Result.Ok"/> : E_OUTOFMEMORY; if (SUCCEEDED(hr)) { // Receive the contents of the command sink streamed to the sink. hr = pCommandList-&gt;Stream(pCommandSink); } SafeRelease(&amp;pCommandSink); return hr; }</pre>
        /// </remarks>
        /// <doc-id>hh404393</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandList::Stream([In] ID2D1CommandSink* sink)</unmanaged>
        /// <unmanaged-short>ID2D1CommandList::Stream</unmanaged-short>
        public unsafe void Stream(SharpDX.Direct2D1.CommandSink sink)
        {
            System.IntPtr sink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            sink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.CommandSink>(sink);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)sink_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Instructs the command list to stop accepting commands so that you can use it as an input to an effect or in a call to <strong>ID2D1DeviceContext::DrawImage</strong>.  You should call the method after it has been attached to an <strong><see cref = "SharpDX.Direct2D1.DeviceContext"/></strong> and written to but before the command list is used.</p>
        /// </summary>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref = "WrongState"/> </td><td>Close has already been called on the command list.</td></tr> </table><p>?</p><p> </p><strong>Note</strong>??If the device context associated with the command list has an error, the command list returns the same error.?</returns>
        /// <remarks>
        /// <p>This method returns <see cref = "WrongState"/> if it has already been called on the command list. If an error occurred on the device context during population, the method returns that error. Otherwise, the method returns <see cref = "SharpDX.Result.Ok"/>. </p><p>If the <strong>Close</strong> method returns an error, any future use of the command list results in the same error.</p>
        /// </remarks>
        /// <doc-id>hh871450</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandList::Close()</unmanaged>
        /// <unmanaged-short>ID2D1CommandList::Close</unmanaged-short>
        public unsafe void Close()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("54d7898a-a061-40a7-bec7-e465bcba2c4f")]
    public partial interface CommandSink : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("9eb767fd-4269-4467-b8c2-eb30cb305743")]
    public partial interface CommandSink1 : SharpDX.Direct2D1.CommandSink
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("9eb767fd-4269-4467-b8c2-eb30cb305743")]
    internal partial class CommandSink1Native : SharpDX.Direct2D1.CommandSinkNative, SharpDX.Direct2D1.CommandSink1
    {
        public CommandSink1Native(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator CommandSink1Native(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new CommandSink1Native(nativePtr);
        /// <summary>
        /// <p>Sets a new primitive blend mode. </p>
        /// </summary>
        /// <doc-id>dn280438</doc-id>
        /// <unmanaged>SetPrimitiveBlend1</unmanaged>
        /// <unmanaged-short>SetPrimitiveBlend1</unmanaged-short>
        public SharpDX.Direct2D1.PrimitiveBlend PrimitiveBlend1_
        {
            set => SetPrimitiveBlend1_(value);
        }

        /// <summary>
        /// <p>Sets a new primitive blend mode. </p>
        /// </summary>
        /// <param name = "primitiveBlend"><dd>  <p>The primitive blend that will apply to subsequent primitives.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <doc-id>dn280438</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink1::SetPrimitiveBlend1([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink1::SetPrimitiveBlend1</unmanaged-short>
        internal unsafe void SetPrimitiveBlend1_(SharpDX.Direct2D1.PrimitiveBlend primitiveBlend)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)primitiveBlend), (*(void ***)this._nativePointer)[28]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3bab440e-417e-47df-a2e2-bc0be6a00916")]
    public partial interface CommandSink2 : SharpDX.Direct2D1.CommandSink1
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("3bab440e-417e-47df-a2e2-bc0be6a00916")]
    internal partial class CommandSink2Native : SharpDX.Direct2D1.CommandSink1Native, SharpDX.Direct2D1.CommandSink2
    {
        public CommandSink2Native(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator CommandSink2Native(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new CommandSink2Native(nativePtr);
        /// <summary>
        /// <p>Renders the given ink object using the given brush and ink style.</p>
        /// </summary>
        /// <param name = "ink"><dd>  <p>The ink object to be rendered.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush with which to render the ink object.</p> </dd></param>
        /// <param name = "inkStyle"><dd>  <p>The ink style to use when rendering the ink object.</p> </dd></param>
        /// <returns><p>This method does not return a value.</p></returns>
        /// <doc-id>dn890784</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink2::DrawInk([In] ID2D1Ink* ink,[In] ID2D1Brush* brush,[In, Optional] ID2D1InkStyle* inkStyle)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink2::DrawInk</unmanaged-short>
        internal unsafe void DrawInk_(SharpDX.Direct2D1.Ink ink, SharpDX.Direct2D1.Brush brush, SharpDX.Direct2D1.InkStyle inkStyle)
        {
            System.IntPtr ink_ = System.IntPtr.Zero;
            System.IntPtr brush_ = System.IntPtr.Zero;
            System.IntPtr inkStyle_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            ink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Ink>(ink);
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            inkStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.InkStyle>(inkStyle);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)ink_, (void *)brush_, (void *)inkStyle_, (*(void ***)this._nativePointer)[29]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Renders a given gradient mesh to the target.</p>
        /// </summary>
        /// <param name = "gradientMesh"><dd>  <p>The gradient mesh to be rendered.</p> </dd></param>
        /// <returns><p>This method does not return a value.</p></returns>
        /// <doc-id>dn890783</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink2::DrawGradientMesh([In] ID2D1GradientMesh* gradientMesh)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink2::DrawGradientMesh</unmanaged-short>
        internal unsafe void DrawGradientMesh_(SharpDX.Direct2D1.GradientMesh gradientMesh)
        {
            System.IntPtr gradientMesh_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            gradientMesh_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.GradientMesh>(gradientMesh);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)gradientMesh_, (*(void ***)this._nativePointer)[30]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Draws a metafile to the command sink using the given source and destination rectangles.</p>
        /// </summary>
        /// <param name = "gdiMetafile"><dd>  <p>The metafile to draw.</p> </dd></param>
        /// <param name = "destinationRectangle"><dd>  <p>The rectangle in the target where the metafile will be drawn, relative to the upper left corner (defined in DIPs). If <c>null</c> is specified, the destination rectangle is the size of the target.</p> </dd></param>
        /// <param name = "sourceRectangle"><dd>  <p>The rectangle of the source metafile that will be drawn, relative to the upper left corner (defined in DIPs).  If <c>null</c> is specified, the source rectangle is the value returned by <strong>ID2D1GdiMetafile1::GetSourceBounds</strong>.</p> </dd></param>
        /// <returns><p>This method does not return a value.</p></returns>
        /// <doc-id>dn890782</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink2::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink2::DrawGdiMetafile</unmanaged-short>
        internal unsafe void DrawGdiMetafile_(SharpDX.Direct2D1.GdiMetafile gdiMetafile, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle)
        {
            System.IntPtr gdiMetafile_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangleF destinationRectangle_;
            SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle_;
            SharpDX.Result __result__;
            gdiMetafile_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.GdiMetafile>(gdiMetafile);
            if (destinationRectangle != null)
                destinationRectangle_ = destinationRectangle.Value;
            if (sourceRectangle != null)
                sourceRectangle_ = sourceRectangle.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)gdiMetafile_, destinationRectangle == null ? (void *)0 : &destinationRectangle_, sourceRectangle == null ? (void *)0 : &sourceRectangle_, (*(void ***)this._nativePointer)[31]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("18079135-4cf3-4868-bc8e-06067e6d242d")]
    public partial interface CommandSink3 : SharpDX.Direct2D1.CommandSink2
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("18079135-4cf3-4868-bc8e-06067e6d242d")]
    internal partial class CommandSink3Native : SharpDX.Direct2D1.CommandSink2Native, SharpDX.Direct2D1.CommandSink3
    {
        public CommandSink3Native(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator CommandSink3Native(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new CommandSink3Native(nativePtr);
        /// <summary>
        /// <p>Renders part or all of the given sprite batch to the device context using the specified drawing options.</p>
        /// </summary>
        /// <param name = "spriteBatch"><dd>  <p>The sprite batch to draw.</p> </dd></param>
        /// <param name = "startIndex"><dd>  <p>The index of the first sprite in the sprite batch to draw.</p> </dd></param>
        /// <param name = "spriteCount"><dd>  <p>The number of sprites to draw.</p> </dd></param>
        /// <param name = "bitmap"><dd>  <p>The bitmap from which the sprites are to be sourced. Each sprite?s source rectangle refers to a portion of this bitmap.</p> </dd></param>
        /// <param name = "interpolationMode"><dd>  <p>The interpolation mode to use when drawing this sprite batch. This determines how Direct2D interpolates pixels within the drawn sprites if scaling is performed.</p> </dd></param>
        /// <param name = "spriteOptions"><dd>  <p>The additional drawing options, if any, to be used for this sprite batch.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>mt619823</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink3::DrawSpriteBatch([In] ID2D1SpriteBatch* spriteBatch,[In] unsigned int startIndex,[In] unsigned int spriteCount,[In] ID2D1Bitmap* bitmap,[In] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode,[In] D2D1_SPRITE_OPTIONS spriteOptions)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink3::DrawSpriteBatch</unmanaged-short>
        internal unsafe void DrawSpriteBatch_(SharpDX.Direct2D1.SpriteBatch spriteBatch, System.Int32 startIndex, System.Int32 spriteCount, SharpDX.Direct2D1.Bitmap bitmap, SharpDX.Direct2D1.BitmapInterpolationMode interpolationMode, SharpDX.Direct2D1.SpriteOptions spriteOptions)
        {
            System.IntPtr spriteBatch_ = System.IntPtr.Zero;
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            spriteBatch_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SpriteBatch>(spriteBatch);
            bitmap_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Bitmap>(bitmap);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)spriteBatch_, startIndex, spriteCount, (void *)bitmap_, unchecked ((System.Int32)interpolationMode), unchecked ((System.Int32)spriteOptions), (*(void ***)this._nativePointer)[32]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("c78a6519-40d6-4218-b2de-beeeb744bb3e")]
    public partial interface CommandSink4 : SharpDX.Direct2D1.CommandSink3
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("c78a6519-40d6-4218-b2de-beeeb744bb3e")]
    internal partial class CommandSink4Native : SharpDX.Direct2D1.CommandSink3Native, SharpDX.Direct2D1.CommandSink4
    {
        public CommandSink4Native(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator CommandSink4Native(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new CommandSink4Native(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>SetPrimitiveBlend2</unmanaged>
        /// <unmanaged-short>SetPrimitiveBlend2</unmanaged-short>
        public SharpDX.Direct2D1.PrimitiveBlend PrimitiveBlend2_
        {
            set => SetPrimitiveBlend2_(value);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "primitiveBlend">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1CommandSink4::SetPrimitiveBlend2([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink4::SetPrimitiveBlend2</unmanaged-short>
        internal unsafe void SetPrimitiveBlend2_(SharpDX.Direct2D1.PrimitiveBlend primitiveBlend)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)primitiveBlend), (*(void ***)this._nativePointer)[33]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("54d7898a-a061-40a7-bec7-e465bcba2c4f")]
    internal partial class CommandSinkNative : SharpDX.ComObject, SharpDX.Direct2D1.CommandSink
    {
        public CommandSinkNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator CommandSinkNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new CommandSinkNative(nativePtr);
        /// <summary>
        /// <p>Sets the antialiasing mode that will be used to render any subsequent geometry.</p>
        /// </summary>
        /// <doc-id>hh404420</doc-id>
        /// <unmanaged>SetAntialiasMode</unmanaged>
        /// <unmanaged-short>SetAntialiasMode</unmanaged-short>
        public SharpDX.Direct2D1.AntialiasMode AntialiasMode_
        {
            set => SetAntialiasMode_(value);
        }

        /// <summary>
        /// <p>Indicates the new default antialiasing mode for text.</p>
        /// </summary>
        /// <doc-id>hh404423</doc-id>
        /// <unmanaged>SetTextAntialiasMode</unmanaged>
        /// <unmanaged-short>SetTextAntialiasMode</unmanaged-short>
        public SharpDX.Direct2D1.TextAntialiasMode TextAntialiasMode_
        {
            set => SetTextAntialiasMode_(value);
        }

        /// <summary>
        /// <p>Indicates more detailed text rendering parameters.</p>
        /// </summary>
        /// <doc-id>hh404424</doc-id>
        /// <unmanaged>SetTextRenderingParams</unmanaged>
        /// <unmanaged-short>SetTextRenderingParams</unmanaged-short>
        public SharpDX.DirectWrite.RenderingParams TextRenderingParams_
        {
            set => SetTextRenderingParams_(value);
        }

        /// <summary>
        /// <p>Sets a new transform.</p>
        /// </summary>
        /// <remarks>
        /// <p>The transform will be applied to the corresponding device context.</p>
        /// </remarks>
        /// <doc-id>hh404425</doc-id>
        /// <unmanaged>SetTransform</unmanaged>
        /// <unmanaged-short>SetTransform</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 Transform_
        {
            set => SetTransform_(ref value);
        }

        /// <summary>
        /// <p>Sets a new primitive blend mode.</p>
        /// </summary>
        /// <doc-id>hh404421</doc-id>
        /// <unmanaged>SetPrimitiveBlend</unmanaged>
        /// <unmanaged-short>SetPrimitiveBlend</unmanaged-short>
        public SharpDX.Direct2D1.PrimitiveBlend PrimitiveBlend_
        {
            set => SetPrimitiveBlend_(value);
        }

        /// <summary>
        /// <p>The unit mode changes the meaning of subsequent units from device-independent pixels (DIPs) to pixels  or the other way. The command sink does not record a DPI, this is implied by the playback context or other playback interface such as <strong><see cref = "SharpDX.Direct2D1.PrintControl"/></strong>.</p>
        /// </summary>
        /// <remarks>
        /// <p>The unit mode changes the interpretation of units from DIPs to pixels  or vice versa.</p>
        /// </remarks>
        /// <doc-id>hh404426</doc-id>
        /// <unmanaged>SetUnitMode</unmanaged>
        /// <unmanaged-short>SetUnitMode</unmanaged-short>
        public SharpDX.Direct2D1.UnitMode UnitMode_
        {
            set => SetUnitMode_(value);
        }

        /// <summary>
        /// <p>Notifies the implementation of the command sink that drawing is about to commence.</p>
        /// </summary>
        /// <returns><p> This method always returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. </p></returns>
        /// <doc-id>hh404395</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::BeginDraw()</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::BeginDraw</unmanaged-short>
        internal unsafe void BeginDraw_()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Indicates when  <strong><see cref = "SharpDX.Direct2D1.CommandSink"/></strong> processing has completed.</p>
        /// </summary>
        /// <returns><p>If the method/function succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The <strong><see cref = "SharpDX.Result"/></strong> active at the end of the command list will be returned.</p><p> It allows the calling function or method to indicate a failure back to the stream implementation.</p>
        /// </remarks>
        /// <doc-id>hh404409</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::EndDraw()</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::EndDraw</unmanaged-short>
        internal unsafe void EndDraw_()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the antialiasing mode that will be used to render any subsequent geometry.</p>
        /// </summary>
        /// <param name = "antialiasMode"><dd>  <p>The antialiasing mode selected for the command list.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <doc-id>hh404420</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::SetAntialiasMode([In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::SetAntialiasMode</unmanaged-short>
        internal unsafe void SetAntialiasMode_(SharpDX.Direct2D1.AntialiasMode antialiasMode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)antialiasMode), (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the tags that correspond to the tags in the command sink.</p>
        /// </summary>
        /// <param name = "tag1"><dd>  <p>The first tag to associate with the primitive.</p> </dd></param>
        /// <param name = "tag2"><dd>  <p>The second tag to associate with the primitive.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <doc-id>hh404422</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::SetTags([In] unsigned longlong tag1,[In] unsigned longlong tag2)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::SetTags</unmanaged-short>
        internal unsafe void SetTags_(System.Int64 tag1, System.Int64 tag2)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, tag1, tag2, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Indicates the new default antialiasing mode for text.</p>
        /// </summary>
        /// <param name = "textAntialiasMode"><dd>  <p>The antialiasing mode for the text.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <doc-id>hh404423</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::SetTextAntialiasMode([In] D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::SetTextAntialiasMode</unmanaged-short>
        internal unsafe void SetTextAntialiasMode_(SharpDX.Direct2D1.TextAntialiasMode textAntialiasMode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)textAntialiasMode), (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Indicates more detailed text rendering parameters.</p>
        /// </summary>
        /// <param name = "textRenderingParams"><dd>  <p>The parameters to use for text rendering.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <doc-id>hh404424</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::SetTextRenderingParams([In, Optional] IDWriteRenderingParams* textRenderingParams)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::SetTextRenderingParams</unmanaged-short>
        internal unsafe void SetTextRenderingParams_(SharpDX.DirectWrite.RenderingParams textRenderingParams)
        {
            System.IntPtr textRenderingParams_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            textRenderingParams_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.RenderingParams>(textRenderingParams);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)textRenderingParams_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets a new transform.</p>
        /// </summary>
        /// <param name = "transform"><dd>  <p>The transform to be set.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <remarks>
        /// <p>The transform will be applied to the corresponding device context.</p>
        /// </remarks>
        /// <doc-id>hh404425</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::SetTransform([In] const D2D_MATRIX_3X2_F* transform)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::SetTransform</unmanaged-short>
        internal unsafe void SetTransform_(ref SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            SharpDX.Result __result__;
            fixed (void *transform_ = &transform)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, transform_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets a new primitive blend mode.</p>
        /// </summary>
        /// <param name = "primitiveBlend"><dd>  <p>The primitive blend that will apply to subsequent primitives.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <doc-id>hh404421</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::SetPrimitiveBlend([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::SetPrimitiveBlend</unmanaged-short>
        internal unsafe void SetPrimitiveBlend_(SharpDX.Direct2D1.PrimitiveBlend primitiveBlend)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)primitiveBlend), (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>The unit mode changes the meaning of subsequent units from device-independent pixels (DIPs) to pixels  or the other way. The command sink does not record a DPI, this is implied by the playback context or other playback interface such as <strong><see cref = "SharpDX.Direct2D1.PrintControl"/></strong>.</p>
        /// </summary>
        /// <param name = "unitMode">No documentation.</param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <remarks>
        /// <p>The unit mode changes the interpretation of units from DIPs to pixels  or vice versa.</p>
        /// </remarks>
        /// <doc-id>hh404426</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::SetUnitMode([In] D2D1_UNIT_MODE unitMode)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::SetUnitMode</unmanaged-short>
        internal unsafe void SetUnitMode_(SharpDX.Direct2D1.UnitMode unitMode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)unitMode), (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Clears the drawing area to the specified color.  </p>
        /// </summary>
        /// <param name = "color"><dd>  <p>The color to which the command sink should be cleared.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <remarks>
        /// <p>The clear color is restricted by the currently selected clip and layer bounds.</p><p>If no color is specified, the color should be interpreted by context. Examples include but are not limited to:</p><ul> <li>Transparent black for a premultiplied bitmap target.</li> <li>Opaque black for an ignore bitmap target.</li> <li>Containing no content (or white) for a printer page.</li> </ul>
        /// </remarks>
        /// <doc-id>hh404397</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::Clear([In, Optional] const D2D_COLOR_F* color)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::Clear</unmanaged-short>
        internal unsafe void Clear_(SharpDX.Mathematics.Interop.RawColor4? color)
        {
            SharpDX.Mathematics.Interop.RawColor4 color_;
            SharpDX.Result __result__;
            if (color != null)
                color_ = color.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, color == null ? (void *)0 : &color_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Indicates the glyphs to be drawn.</p>
        /// </summary>
        /// <param name = "baselineOrigin"><dd>  <p>The upper left corner of the baseline.</p> </dd></param>
        /// <param name = "glyphRun"><dd>  <p>The glyphs to render.</p> </dd></param>
        /// <param name = "glyphRunDescription"><dd>  <p>Additional non-rendering information about the glyphs.</p> </dd></param>
        /// <param name = "foregroundBrush"><dd>  <p>The brush used to fill the glyphs.</p> </dd></param>
        /// <param name = "measuringMode"><dd>  <p>The measuring mode to apply to the glyphs.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <remarks>
        /// <p> <strong>DrawText</strong> and <strong>DrawTextLayout</strong> are broken down into glyph runs and rectangles by the time the command sink is processed. So, these methods aren't available on the command sink. Since the application may require additional callback processing when calling <strong>DrawTextLayout</strong>, this semantic can't be easily preserved in the command list.</p>
        /// </remarks>
        /// <doc-id>hh404401</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In] ID2D1Brush* foregroundBrush,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::DrawGlyphRun</unmanaged-short>
        internal unsafe void DrawGlyphRun_(SharpDX.Mathematics.Interop.RawVector2 baselineOrigin, SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.DirectWrite.GlyphRunDescription glyphRunDescription, SharpDX.Direct2D1.Brush foregroundBrush, SharpDX.Direct2D1.MeasuringMode measuringMode)
        {
            SharpDX.DirectWrite.GlyphRun.__Native glyphRun_ = default (SharpDX.DirectWrite.GlyphRun.__Native);
            SharpDX.DirectWrite.GlyphRunDescription.__Native glyphRunDescription_ = default (SharpDX.DirectWrite.GlyphRunDescription.__Native);
            System.IntPtr foregroundBrush_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            glyphRun.__MarshalTo(ref glyphRun_);
            if (glyphRunDescription != null)
                glyphRunDescription.__MarshalTo(ref glyphRunDescription_);
            foregroundBrush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(foregroundBrush);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, baselineOrigin, &glyphRun_, glyphRunDescription == null ? (void *)0 : &glyphRunDescription_, (void *)foregroundBrush_, unchecked ((System.Int32)measuringMode), (*(void ***)this._nativePointer)[13]);
            glyphRun.__MarshalFree(ref glyphRun_);
            if (glyphRunDescription != null)
                glyphRunDescription.__MarshalFree(ref glyphRunDescription_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Draws a line drawn between two points.</p>
        /// </summary>
        /// <param name = "point0"><dd>  <p>The start point of the line.</p> </dd></param>
        /// <param name = "point1"><dd>  <p>The end point of the line.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush used to fill the line.</p> </dd></param>
        /// <param name = "strokeWidth"><dd>  <p>The width of the stroke to fill the line.</p> </dd></param>
        /// <param name = "strokeStyle"><dd>  <p>The style of the stroke. If not specified, the stroke is solid.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <doc-id>hh404405</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawLine([In] D2D_POINT_2F point0,[In] D2D_POINT_2F point1,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::DrawLine</unmanaged-short>
        internal unsafe void DrawLine_(SharpDX.Mathematics.Interop.RawVector2 point0, SharpDX.Mathematics.Interop.RawVector2 point1, SharpDX.Direct2D1.Brush brush, System.Single strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            System.IntPtr brush_ = System.IntPtr.Zero;
            System.IntPtr strokeStyle_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            strokeStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.StrokeStyle>(strokeStyle);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, point0, point1, (void *)brush_, strokeWidth, (void *)strokeStyle_, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Indicates the geometry to be drawn to the command sink.</p>
        /// </summary>
        /// <param name = "geometry"><dd>  <p>The geometry to be stroked.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush that will be used to fill the stroked geometry.</p> </dd></param>
        /// <param name = "strokeWidth"><dd>  <p>The width of the stroke.</p> </dd></param>
        /// <param name = "strokeStyle"><dd>  <p>The style of the stroke.</p> </dd></param>
        /// <returns><p>An <see cref = "SharpDX.Result"/>. </p></returns>
        /// <remarks>
        /// <p> <strong>Ellipses</strong> and <strong>rounded rectangles</strong> are converted to the corresponding ellipse and rounded rectangle geometries before calling into the <strong>DrawGeometry</strong> method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh404399</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::DrawGeometry</unmanaged-short>
        internal unsafe void DrawGeometry_(SharpDX.Direct2D1.Geometry geometry, SharpDX.Direct2D1.Brush brush, System.Single strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            System.IntPtr geometry_ = System.IntPtr.Zero;
            System.IntPtr brush_ = System.IntPtr.Zero;
            System.IntPtr strokeStyle_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            geometry_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Geometry>(geometry);
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            strokeStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.StrokeStyle>(strokeStyle);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)geometry_, (void *)brush_, strokeWidth, (void *)strokeStyle_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Draws a rectangle.</p>
        /// </summary>
        /// <param name = "rect"><dd>  <p>The rectangle to be drawn to the command sink.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush used to stroke the geometry.</p> </dd></param>
        /// <param name = "strokeWidth"><dd>  <p>The width of the stroke.</p> </dd></param>
        /// <param name = "strokeStyle"><dd>  <p>The style of the stroke.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <doc-id>hh404407</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::DrawRectangle</unmanaged-short>
        internal unsafe void DrawRectangle_(SharpDX.Mathematics.Interop.RawRectangleF rect, SharpDX.Direct2D1.Brush brush, System.Single strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            System.IntPtr brush_ = System.IntPtr.Zero;
            System.IntPtr strokeStyle_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            strokeStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.StrokeStyle>(strokeStyle);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &rect, (void *)brush_, strokeWidth, (void *)strokeStyle_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Draws a bitmap to the render target.</p>
        /// </summary>
        /// <param name = "bitmap"><dd>  <p>The bitmap to draw.</p> </dd></param>
        /// <param name = "destinationRectangle"><dd>  <p>The destination rectangle. The default is the size of the bitmap and the location is the upper left corner of the render target.</p> </dd></param>
        /// <param name = "opacity"><dd>  <p>The opacity of the bitmap.</p> </dd></param>
        /// <param name = "interpolationMode"><dd>  <p>The interpolation mode to use.</p> </dd></param>
        /// <param name = "sourceRectangle"><dd>  <p>An optional source rectangle.</p> </dd></param>
        /// <param name = "erspectiveTransformRef"><dd>  <p>An optional perspective transform.</p> </dd></param>
        /// <returns><p>This method does not return a value.</p></returns>
        /// <remarks>
        /// <p>The <em>destinationRectangle</em> parameter defines the rectangle in the target where the bitmap will appear (in device-independent pixels (DIPs)).  This is affected by the currently set transform and the perspective transform, if set.  If you specify <c>null</c>, then the destination rectangle is (left=0, top=0, right = width(<em>sourceRectangle</em>), bottom = height(<em>sourceRectangle</em>). </p><p>The <em>sourceRectangle</em> defines the sub-rectangle of the source bitmap (in DIPs).  <strong>DrawBitmap</strong> clips this rectangle to the size of the source bitmap, so it's impossible to sample outside of the bitmap.  If you specify <c>null</c>, then the source rectangle is taken to be the size of the source bitmap. </p><p>The <em>perspectiveTransform</em> is specified in addition to the transform on device context.
        /// </p>
        /// </remarks>
        /// <doc-id>hh847972</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_F* destinationRectangle,[In] float opacity,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D_RECT_F* sourceRectangle,[In, Optional] const D2D_MATRIX_4X4_F* perspectiveTransform)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::DrawBitmap</unmanaged-short>
        internal unsafe void DrawBitmap_(SharpDX.Direct2D1.Bitmap bitmap, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, System.Single opacity, SharpDX.Direct2D1.InterpolationMode interpolationMode, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle, SharpDX.Mathematics.Interop.RawMatrix? erspectiveTransformRef)
        {
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangleF destinationRectangle_;
            SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle_;
            SharpDX.Mathematics.Interop.RawMatrix erspectiveTransformRef_;
            SharpDX.Result __result__;
            bitmap_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Bitmap>(bitmap);
            if (destinationRectangle != null)
                destinationRectangle_ = destinationRectangle.Value;
            if (sourceRectangle != null)
                sourceRectangle_ = sourceRectangle.Value;
            if (erspectiveTransformRef != null)
                erspectiveTransformRef_ = erspectiveTransformRef.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)bitmap_, destinationRectangle == null ? (void *)0 : &destinationRectangle_, opacity, unchecked ((System.Int32)interpolationMode), sourceRectangle == null ? (void *)0 : &sourceRectangle_, erspectiveTransformRef == null ? (void *)0 : &erspectiveTransformRef_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Draws the provided image to the command sink.  </p>
        /// </summary>
        /// <param name = "image"><dd>  <p>The image to be drawn to the command sink.</p> </dd></param>
        /// <param name = "targetOffset"><dd>  <p>This defines the offset in the destination space that the image will be rendered to. The entire logical extent of the image will be rendered to the corresponding destination. If not specified, the destination origin will be (0, 0). The top-left corner of the image will be mapped to the target offset. This will not necessarily be the origin.</p> </dd></param>
        /// <param name = "imageRectangle"><dd>  <p>The corresponding rectangle in the image space will be mapped to the provided origins when processing the image.</p> </dd></param>
        /// <param name = "interpolationMode"><dd>  <p>The interpolation mode to use to  scale the image if necessary.</p> </dd></param>
        /// <param name = "compositeMode"><dd>  <p>If specified, the composite mode that will be applied to the limits of the currently selected clip.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <remarks>
        /// <p>Because the image can itself be a command list or contain an effect graph that in turn contains a command list, this method can result in recursive processing.</p>
        /// </remarks>
        /// <doc-id>hh404403</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawImage([In] ID2D1Image* image,[In, Optional] const D2D_POINT_2F* targetOffset,[In, Optional] const D2D_RECT_F* imageRectangle,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In] D2D1_COMPOSITE_MODE compositeMode)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::DrawImage</unmanaged-short>
        internal unsafe void DrawImage_(SharpDX.Direct2D1.Image image, SharpDX.Mathematics.Interop.RawVector2? targetOffset, SharpDX.Mathematics.Interop.RawRectangleF? imageRectangle, SharpDX.Direct2D1.InterpolationMode interpolationMode, SharpDX.Direct2D1.CompositeMode compositeMode)
        {
            System.IntPtr image_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawVector2 targetOffset_;
            SharpDX.Mathematics.Interop.RawRectangleF imageRectangle_;
            SharpDX.Result __result__;
            image_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Image>(image);
            if (targetOffset != null)
                targetOffset_ = targetOffset.Value;
            if (imageRectangle != null)
                imageRectangle_ = imageRectangle.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)image_, targetOffset == null ? (void *)0 : &targetOffset_, imageRectangle == null ? (void *)0 : &imageRectangle_, unchecked ((System.Int32)interpolationMode), unchecked ((System.Int32)compositeMode), (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Draw a metafile to the device context.</p>
        /// </summary>
        /// <param name = "gdiMetafile"><dd>  <p>The metafile to draw.</p> </dd></param>
        /// <param name = "targetOffset"><dd>  <p>The offset from the upper left corner of the render target.</p> </dd></param>
        /// <returns><p>This method does not return a value.</p></returns>
        /// <remarks>
        /// <p>The <em>targetOffset</em> defines the offset in the destination space that the image will be rendered to. The entire logical extent of the image is rendered to the corresponding destination. If you don't specify the offset, the destination origin will be (0, 0). The top, left corner of the image will be mapped to the target offset. This will not necessarily be the origin.
        /// </p>
        /// </remarks>
        /// <doc-id>hh847973</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_POINT_2F* targetOffset)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::DrawGdiMetafile</unmanaged-short>
        internal unsafe void DrawGdiMetafile_(SharpDX.Direct2D1.GdiMetafile gdiMetafile, SharpDX.Mathematics.Interop.RawVector2? targetOffset)
        {
            System.IntPtr gdiMetafile_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawVector2 targetOffset_;
            SharpDX.Result __result__;
            gdiMetafile_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.GdiMetafile>(gdiMetafile);
            if (targetOffset != null)
                targetOffset_ = targetOffset.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)gdiMetafile_, targetOffset == null ? (void *)0 : &targetOffset_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Indicates a mesh to be filled by the command sink.</p>
        /// </summary>
        /// <param name = "mesh"><dd>  <p>The mesh object to be filled.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush with which to fill the mesh.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <doc-id>hh404413</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::FillMesh([In] ID2D1Mesh* mesh,[In] ID2D1Brush* brush)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::FillMesh</unmanaged-short>
        internal unsafe void FillMesh_(SharpDX.Direct2D1.Mesh mesh, SharpDX.Direct2D1.Brush brush)
        {
            System.IntPtr mesh_ = System.IntPtr.Zero;
            System.IntPtr brush_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            mesh_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Mesh>(mesh);
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)mesh_, (void *)brush_, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Fills an opacity mask on the command sink.</p>
        /// </summary>
        /// <param name = "opacityMask"><dd>  <p>The bitmap whose alpha channel will be sampled to define the opacity mask.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush with which to fill the mask.</p> </dd></param>
        /// <param name = "destinationRectangle"><dd>  <p>The destination rectangle in which to fill the mask. If not specified, this is the origin.</p> </dd></param>
        /// <param name = "sourceRectangle"><dd>  <p>The source rectangle within the opacity mask. If not specified, this is the entire mask.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <remarks>
        /// <p>The opacity mask bitmap must be considered to be clamped on each axis.</p>
        /// </remarks>
        /// <doc-id>hh404414</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::FillOpacityMask([In] ID2D1Bitmap* opacityMask,[In] ID2D1Brush* brush,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::FillOpacityMask</unmanaged-short>
        internal unsafe void FillOpacityMask_(SharpDX.Direct2D1.Bitmap opacityMask, SharpDX.Direct2D1.Brush brush, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle)
        {
            System.IntPtr opacityMask_ = System.IntPtr.Zero;
            System.IntPtr brush_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangleF destinationRectangle_;
            SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle_;
            SharpDX.Result __result__;
            opacityMask_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Bitmap>(opacityMask);
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            if (destinationRectangle != null)
                destinationRectangle_ = destinationRectangle.Value;
            if (sourceRectangle != null)
                sourceRectangle_ = sourceRectangle.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)opacityMask_, (void *)brush_, destinationRectangle == null ? (void *)0 : &destinationRectangle_, sourceRectangle == null ? (void *)0 : &sourceRectangle_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Indicates to the command sink a geometry to be filled.</p>
        /// </summary>
        /// <param name = "geometry"><dd>  <p>The geometry that should be filled.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The primary brush used to fill the geometry.</p> </dd></param>
        /// <param name = "opacityBrush"><dd>  <p>A brush whose alpha channel is used to modify the opacity of the primary fill brush.  </p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <remarks>
        /// <p>If the opacity brush is specified, the primary brush will be a bitmap brush fixed on both the x-axis and the y-axis.</p><p>Ellipses and rounded rectangles are converted to the corresponding geometry before being passed to <strong>FillGeometry</strong>.</p>
        /// </remarks>
        /// <doc-id>hh404411</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::FillGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In, Optional] ID2D1Brush* opacityBrush)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::FillGeometry</unmanaged-short>
        internal unsafe void FillGeometry_(SharpDX.Direct2D1.Geometry geometry, SharpDX.Direct2D1.Brush brush, SharpDX.Direct2D1.Brush opacityBrush)
        {
            System.IntPtr geometry_ = System.IntPtr.Zero;
            System.IntPtr brush_ = System.IntPtr.Zero;
            System.IntPtr opacityBrush_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            geometry_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Geometry>(geometry);
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            opacityBrush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(opacityBrush);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)geometry_, (void *)brush_, (void *)opacityBrush_, (*(void ***)this._nativePointer)[22]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Indicates to the command sink a rectangle to be filled.</p>
        /// </summary>
        /// <param name = "rect"><dd>  <p>The rectangle to fill.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush with which to fill the rectangle.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <doc-id>hh404415</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::FillRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::FillRectangle</unmanaged-short>
        internal unsafe void FillRectangle_(SharpDX.Mathematics.Interop.RawRectangleF rect, SharpDX.Direct2D1.Brush brush)
        {
            System.IntPtr brush_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &rect, (void *)brush_, (*(void ***)this._nativePointer)[23]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Pushes a clipping rectangle onto the clip and layer stack.</p>
        /// </summary>
        /// <param name = "clipRect"><dd>  <p>The rectangle that defines the clip.</p> </dd></param>
        /// <param name = "antialiasMode"><dd>  <p>The antialias mode for the clip.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <remarks>
        /// <p>If the current world transform is not preserving the axis, <em>clipRectangle</em> is transformed and the bounds of the transformed rectangle are used instead.</p>
        /// </remarks>
        /// <doc-id>hh404418</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::PushAxisAlignedClip([In] const D2D_RECT_F* clipRect,[In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::PushAxisAlignedClip</unmanaged-short>
        internal unsafe void PushAxisAlignedClip_(SharpDX.Mathematics.Interop.RawRectangleF clipRect, SharpDX.Direct2D1.AntialiasMode antialiasMode)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &clipRect, unchecked ((System.Int32)antialiasMode), (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Pushes a layer onto the clip and layer stack.</p>
        /// </summary>
        /// <param name = "layerParameters1"><dd>  <p>The parameters that define the layer.</p> </dd></param>
        /// <param name = "layer"><dd>  <p>The layer resource that receives subsequent drawing operations.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <doc-id>hh404419</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::PushLayer([In] const D2D1_LAYER_PARAMETERS1* layerParameters1,[In, Optional] ID2D1Layer* layer)</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::PushLayer</unmanaged-short>
        internal unsafe void PushLayer_(ref SharpDX.Direct2D1.LayerParameters1 layerParameters1, SharpDX.Direct2D1.Layer layer)
        {
            SharpDX.Direct2D1.LayerParameters1.__Native layerParameters1_ = default (SharpDX.Direct2D1.LayerParameters1.__Native);
            System.IntPtr layer_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            layerParameters1.__MarshalTo(ref layerParameters1_);
            layer_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Layer>(layer);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &layerParameters1_, (void *)layer_, (*(void ***)this._nativePointer)[25]);
            layerParameters1.__MarshalFree(ref layerParameters1_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes an axis-aligned clip from the layer and clip stack.</p>
        /// </summary>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <doc-id>hh404416</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::PopAxisAlignedClip()</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::PopAxisAlignedClip</unmanaged-short>
        internal unsafe void PopAxisAlignedClip_()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[26]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes  a layer from the layer and clip stack.</p>
        /// </summary>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code. </p></returns>
        /// <doc-id>hh404417</doc-id>
        /// <unmanaged>HRESULT ID2D1CommandSink::PopLayer()</unmanaged>
        /// <unmanaged-short>ID2D1CommandSink::PopLayer</unmanaged-short>
        internal unsafe void PopLayer_()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[27]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("5598b14b-9fd7-48b7-9bdb-8f0964eb38bc")]
    public partial class ComputeInformation : SharpDX.Direct2D1.RenderInformation
    {
        public ComputeInformation(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ComputeInformation(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ComputeInformation(nativePtr);
        /// <summary>
        /// <p>Sets the compute shader to the given shader resource.  The resource must be loaded before this call is made.</p>
        /// </summary>
        /// <doc-id>hh847967</doc-id>
        /// <unmanaged>SetComputeShader</unmanaged>
        /// <unmanaged-short>SetComputeShader</unmanaged-short>
        public System.Guid ComputeShader
        {
            set => SetComputeShader(value);
        }

        /// <summary>
        /// <p>Establishes or changes the constant buffer data for this transform.</p>
        /// </summary>
        /// <param name = "buffer"><dd>  <p>The data applied to the constant buffer.</p> </dd></param>
        /// <param name = "bufferCount"><dd>  <p>The number of bytes of data in the constant buffer.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh847968</doc-id>
        /// <unmanaged>HRESULT ID2D1ComputeInfo::SetComputeShaderConstantBuffer([In, Buffer] const unsigned char* buffer,[In] unsigned int bufferCount)</unmanaged>
        /// <unmanaged-short>ID2D1ComputeInfo::SetComputeShaderConstantBuffer</unmanaged-short>
        internal unsafe void SetComputeShaderConstantBuffer(System.IntPtr buffer, System.Int32 bufferCount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)buffer, bufferCount, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the compute shader to the given shader resource.  The resource must be loaded before this call is made.</p>
        /// </summary>
        /// <param name = "shaderId"><dd>  <p>The <see cref = "System.Guid"/> of the shader.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh847967</doc-id>
        /// <unmanaged>HRESULT ID2D1ComputeInfo::SetComputeShader([In] const GUID&amp; shaderId)</unmanaged>
        /// <unmanaged-short>ID2D1ComputeInfo::SetComputeShader</unmanaged-short>
        internal unsafe void SetComputeShader(System.Guid shaderId)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &shaderId, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the resource texture corresponding to the given shader texture index to the given texture resource.  The texture resource must already have been loaded with <strong>ID2D1EffectContext::CreateResourceTexture</strong> method. This call will fail if the specified index overlaps with any input. The input indices always precede the texture LUT indices.
        /// </p>
        /// </summary>
        /// <param name = "textureIndex">No documentation.</param>
        /// <param name = "resourceTexture">No documentation.</param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh847969</doc-id>
        /// <unmanaged>HRESULT ID2D1ComputeInfo::SetResourceTexture([In] unsigned int textureIndex,[In] ID2D1ResourceTexture* resourceTexture)</unmanaged>
        /// <unmanaged-short>ID2D1ComputeInfo::SetResourceTexture</unmanaged-short>
        public unsafe void SetResourceTexture(System.Int32 textureIndex, SharpDX.Direct2D1.ResourceTexture resourceTexture)
        {
            System.IntPtr resourceTexture_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            resourceTexture_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.ResourceTexture>(resourceTexture);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, textureIndex, (void *)resourceTexture_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("0d85573c-01e3-4f7d-bfd9-0d60608bf3c3")]
    public partial interface ComputeTransform : SharpDX.Direct2D1.Transform
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("0d85573c-01e3-4f7d-bfd9-0d60608bf3c3")]
    public partial class ComputeTransformNative : SharpDX.Direct2D1.TransformNative, SharpDX.Direct2D1.ComputeTransform
    {
        public ComputeTransformNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ComputeTransformNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ComputeTransformNative(nativePtr);
        /// <summary>
        /// <p>Sets the render information used to specify the compute shader pass.</p>
        /// </summary>
        /// <remarks>
        /// <p>If this method fails, <strong>ID2D1TransformGraph::AddNode</strong> fails.</p>
        /// </remarks>
        /// <doc-id>hh404450</doc-id>
        /// <unmanaged>SetComputeInfo</unmanaged>
        /// <unmanaged-short>SetComputeInfo</unmanaged-short>
        public SharpDX.Direct2D1.ComputeInformation ComputeInfo_
        {
            set => SetComputeInfo_(value);
        }

        /// <summary>
        /// <p>Sets the render information used to specify the compute shader pass.</p>
        /// </summary>
        /// <param name = "computeInfo"><dd>  <p>The render information object to set.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If this method fails, <strong>ID2D1TransformGraph::AddNode</strong> fails.</p>
        /// </remarks>
        /// <doc-id>hh404450</doc-id>
        /// <unmanaged>HRESULT ID2D1ComputeTransform::SetComputeInfo([In] ID2D1ComputeInfo* computeInfo)</unmanaged>
        /// <unmanaged-short>ID2D1ComputeTransform::SetComputeInfo</unmanaged-short>
        internal unsafe void SetComputeInfo_(SharpDX.Direct2D1.ComputeInformation computeInfo)
        {
            System.IntPtr computeInfo_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            computeInfo_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.ComputeInformation>(computeInfo);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)computeInfo_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>This method allows a compute-shader?based transform to select the number of thread groups to execute based on the number of output pixels it needs to fill.</p>
        /// </summary>
        /// <param name = "outputRect"><dd>  <p>The output rectangle that will be filled by the compute transform.</p> </dd></param>
        /// <param name = "dimensionX"><dd>  <p>The number of threads in the x dimension.</p> </dd></param>
        /// <param name = "dimensionY"><dd>  <p>The number of threads in the y dimension.</p> </dd></param>
        /// <param name = "dimensionZ"><dd>  <p>The number of threads in the z dimension.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>If this call fails, the corresponding <strong><see cref = "SharpDX.Direct2D1.Effect"/></strong> instance is placed into an error state and fails to draw.</p>
        /// </remarks>
        /// <doc-id>hh404437</doc-id>
        /// <unmanaged>HRESULT ID2D1ComputeTransform::CalculateThreadgroups([In] const RECT* outputRect,[Out] unsigned int* dimensionX,[Out] unsigned int* dimensionY,[Out] unsigned int* dimensionZ)</unmanaged>
        /// <unmanaged-short>ID2D1ComputeTransform::CalculateThreadgroups</unmanaged-short>
        internal unsafe void CalculateThreadgroups_(SharpDX.Mathematics.Interop.RawRectangle outputRect, out System.Int32 dimensionX, out System.Int32 dimensionY, out System.Int32 dimensionZ)
        {
            SharpDX.Result __result__;
            fixed (void *dimensionZ_ = &dimensionZ)
                fixed (void *dimensionY_ = &dimensionY)
                    fixed (void *dimensionX_ = &dimensionX)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &outputRect, dimensionX_, dimensionY_, dimensionZ_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("1a799d8a-69f7-4e4c-9fed-437ccc6684cc")]
    public partial class ConcreteTransform : SharpDX.Direct2D1.TransformNodeNative
    {
        public ConcreteTransform(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ConcreteTransform(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ConcreteTransform(nativePtr);
        /// <summary>
        /// <p>Sets whether the output of the specified transform is cached.</p>
        /// </summary>
        /// <doc-id>hh404454</doc-id>
        /// <unmanaged>SetCached</unmanaged>
        /// <unmanaged-short>SetCached</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Cached
        {
            set => SetCached(value);
        }

        /// <summary>
        /// <p>Sets the properties of the output buffer of the specified transform node.</p>
        /// </summary>
        /// <param name = "bufferPrecision"><dd>  <p>The number of bits and the type of the output buffer.</p> </dd></param>
        /// <param name = "channelDepth"><dd>  <p>The number of channels in the output buffer (1 or 4).</p> </dd></param>
        /// <returns><p>The method returns an <see cref = "SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are not valid</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>You can use the <strong>ID2D1EffectContext::IsBufferPrecisionSupported</strong> method to see if buffer precision is supported.</p><p>The available channel depth and precision depend on the capabilities of the underlying Microsoft Direct3D device.</p>
        /// </remarks>
        /// <doc-id>hh404456</doc-id>
        /// <unmanaged>HRESULT ID2D1ConcreteTransform::SetOutputBuffer([In] D2D1_BUFFER_PRECISION bufferPrecision,[In] D2D1_CHANNEL_DEPTH channelDepth)</unmanaged>
        /// <unmanaged-short>ID2D1ConcreteTransform::SetOutputBuffer</unmanaged-short>
        public unsafe void SetOutputBuffer(SharpDX.Direct2D1.BufferPrecision bufferPrecision, SharpDX.Direct2D1.ChannelDepth channelDepth)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)bufferPrecision), unchecked ((System.Int32)channelDepth), (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets whether the output of the specified transform is cached.</p>
        /// </summary>
        /// <param name = "isCached"><dd>  <p><strong>TRUE</strong> if the output should be cached; otherwise,  <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></param>
        /// <doc-id>hh404454</doc-id>
        /// <unmanaged>void ID2D1ConcreteTransform::SetCached([In] BOOL isCached)</unmanaged>
        /// <unmanaged-short>ID2D1ConcreteTransform::SetCached</unmanaged-short>
        internal unsafe void SetCached(SharpDX.Mathematics.Interop.RawBool isCached)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, isCached, (*(void ***)this._nativePointer)[5]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("a248fd3f-3e6c-4e63-9f03-7f68ecc91db9")]
    public partial interface CustomEffect : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("a248fd3f-3e6c-4e63-9f03-7f68ecc91db9")]
    internal partial class CustomEffectNative : SharpDX.ComObject, SharpDX.Direct2D1.CustomEffect
    {
        public CustomEffectNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator CustomEffectNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new CustomEffectNative(nativePtr);
        /// <summary>
        /// <p>The renderer calls this method to provide the effect implementation with a way to specify  its transform graph and transform graph changes. </p><p>The renderer calls this method when:</p><ul> <li>When the effect is first initialized.</li> <li>If the number of inputs to the effect changes.</li> </ul>
        /// </summary>
        /// <doc-id>hh871459</doc-id>
        /// <unmanaged>SetGraph</unmanaged>
        /// <unmanaged-short>SetGraph</unmanaged-short>
        public SharpDX.Direct2D1.TransformGraph Graph_
        {
            set => SetGraph_(value);
        }

        /// <summary>
        /// <p>The effect can use this method to do one time initialization tasks.  If this method is not needed, the method can just return <strong><see cref = "SharpDX.Result.Ok"/></strong>.</p>
        /// </summary>
        /// <param name = "effectContext"><dd>  <p>An internal context interface that creates and returns effect author?centric types.</p> </dd></param>
        /// <param name = "transformGraph"><dd>  <p>The effect can populate the transform graph with a topology and can update it later.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This moves resource creation cost to the <strong>CreateEffect</strong> call, rather than during rendering.</p><p>If the implementation fails this call, the corresponding <strong>ID2D1DeviceContext::CreateEffect</strong> call also fails.</p><p>The following example shows an effect implementing an initialize method.</p>
        /// </remarks>
        /// <doc-id>hh404570</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectImpl::Initialize([In] ID2D1EffectContext* effectContext,[In] ID2D1TransformGraph* transformGraph)</unmanaged>
        /// <unmanaged-short>ID2D1EffectImpl::Initialize</unmanaged-short>
        internal unsafe void Initialize_(SharpDX.Direct2D1.EffectContext effectContext, SharpDX.Direct2D1.TransformGraph transformGraph)
        {
            System.IntPtr effectContext_ = System.IntPtr.Zero;
            System.IntPtr transformGraph_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            effectContext_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.EffectContext>(effectContext);
            transformGraph_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.TransformGraph>(transformGraph);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)effectContext_, (void *)transformGraph_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Prepares an effect for the rendering process.</p>
        /// </summary>
        /// <param name = "changeType"><dd>  <p>Indicates the type of change the effect should expect.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This method is called by the renderer when the effect is within an effect graph that is drawn.</p><p> The method will be called:</p><ul> <li>If the effect has been initialized but has not previously been drawn.</li> <li>If an effect property has been set since the last draw call.</li> <li>If the context state has changed since the effect was last drawn.</li> </ul><p>The method will not otherwise be called. The transforms created by the effect will be called to handle their input and output rectangles for every draw call.</p><p>Most effects defer creating any resources or specifying a topology until this call is made. They store their properties and map them to a concrete set of rendering techniques when first drawn.</p>
        /// </remarks>
        /// <doc-id>hh404572</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectImpl::PrepareForRender([In] D2D1_CHANGE_TYPE changeType)</unmanaged>
        /// <unmanaged-short>ID2D1EffectImpl::PrepareForRender</unmanaged-short>
        internal unsafe void PrepareForRender_(SharpDX.Direct2D1.ChangeType changeType)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)changeType), (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>The renderer calls this method to provide the effect implementation with a way to specify  its transform graph and transform graph changes. </p><p>The renderer calls this method when:</p><ul> <li>When the effect is first initialized.</li> <li>If the number of inputs to the effect changes.</li> </ul>
        /// </summary>
        /// <param name = "transformGraph"><dd>  <p>The graph to which the effect describes its transform topology through the SetDescription call.</p> </dd></param>
        /// <returns><p>An error that prevents the effect from being initialized if called as part of the CreateEffect call. If the effect fails a subsequent SetGraph call:</p><ul> <li>The error will be returned from the property method that caused the number of inputs to the effect to change.</li> <li>The effect object will be placed into an error state, if subsequently used to render, the context will be placed into a temporary error state, that particular effect will fail to render and the failure will be returned on the next EndDraw or Flush call.</li> </ul></returns>
        /// <doc-id>hh871459</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectImpl::SetGraph([In] ID2D1TransformGraph* transformGraph)</unmanaged>
        /// <unmanaged-short>ID2D1EffectImpl::SetGraph</unmanaged-short>
        internal unsafe void SetGraph_(SharpDX.Direct2D1.TransformGraph transformGraph)
        {
            System.IntPtr transformGraph_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            transformGraph_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.TransformGraph>(transformGraph);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)transformGraph_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("47dd575d-ac05-4cdd-8049-9b02cd16f44c")]
    public partial class Device : SharpDX.Direct2D1.Resource
    {
        public Device(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device(nativePtr);
        /// <summary>
        /// <p>Sets the maximum amount of texture memory Direct2D accumulates before it purges the image caches and cached texture allocations.</p>
        /// </summary>
        /// <doc-id>hh847984</doc-id>
        /// <unmanaged>GetMaximumTextureMemory / SetMaximumTextureMemory</unmanaged>
        /// <unmanaged-short>GetMaximumTextureMemory</unmanaged-short>
        public System.Int64 MaximumTextureMemory
        {
            get => GetMaximumTextureMemory();
            set => SetMaximumTextureMemory(value);
        }

        /// <summary>
        /// <p>Creates a new device context from a Direct2D device.</p>
        /// </summary>
        /// <param name = "options"><dd>  <p>The options to be applied to the created device context.</p> </dd></param>
        /// <param name = "deviceContext"><dd>  <p>When this method returns, contains the address of a reference to the new device context.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The new device context will not have a  selected target bitmap. The caller must create and select a bitmap as the target surface of the context.</p>
        /// </remarks>
        /// <doc-id>hh404545</doc-id>
        /// <unmanaged>HRESULT ID2D1Device::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out, Fast] ID2D1DeviceContext** deviceContext)</unmanaged>
        /// <unmanaged-short>ID2D1Device::CreateDeviceContext</unmanaged-short>
        internal unsafe void CreateDeviceContext(SharpDX.Direct2D1.DeviceContextOptions options, SharpDX.Direct2D1.DeviceContext deviceContext)
        {
            System.IntPtr deviceContext_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)options), &deviceContext_, (*(void ***)this._nativePointer)[4]);
            (deviceContext).NativePointer = deviceContext_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.Direct2D1.PrintControl"/></strong> object that converts Direct2D primitives stored in <strong><see cref = "SharpDX.Direct2D1.CommandList"/></strong> into a fixed page representation.  The print sub-system then consumes the primitives.</p>
        /// </summary>
        /// <param name = "wicFactory">No documentation.</param>
        /// <param name = "documentTarget">No documentation.</param>
        /// <param name = "rintControlPropertiesRef">No documentation.</param>
        /// <param name = "rintControlRef">No documentation.</param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_FAIL</td><td>Generic failure code.</td></tr> <tr><td><see cref = "PrintFormatNotSupported"/></td><td>The print format is not supported by the document target.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends on run-time factors such as network status, print server configuration, and printer driver implementation?factors that are difficult to predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the application appear to be unresponsive.?
        /// </remarks>
        /// <doc-id>hh404550</doc-id>
        /// <unmanaged>HRESULT ID2D1Device::CreatePrintControl([In] IWICImagingFactory* wicFactory,[In] IPrintDocumentPackageTarget* documentTarget,[In, Optional] const D2D1_PRINT_CONTROL_PROPERTIES* printControlProperties,[Out, Fast] ID2D1PrintControl** printControl)</unmanaged>
        /// <unmanaged-short>ID2D1Device::CreatePrintControl</unmanaged-short>
        internal unsafe void CreatePrintControl(SharpDX.WIC.ImagingFactory wicFactory, SharpDX.ComObject documentTarget, SharpDX.Direct2D1.PrintControlProperties? rintControlPropertiesRef, SharpDX.Direct2D1.PrintControl rintControlRef)
        {
            System.IntPtr wicFactory_ = System.IntPtr.Zero;
            System.IntPtr documentTarget_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.PrintControlProperties rintControlPropertiesRef_;
            System.IntPtr rintControlRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            wicFactory_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.ImagingFactory>(wicFactory);
            documentTarget_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.ComObject>(documentTarget);
            if (rintControlPropertiesRef != null)
                rintControlPropertiesRef_ = rintControlPropertiesRef.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)wicFactory_, (void *)documentTarget_, rintControlPropertiesRef == null ? (void *)0 : &rintControlPropertiesRef_, &rintControlRef_, (*(void ***)this._nativePointer)[5]);
            (rintControlRef).NativePointer = rintControlRef_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the maximum amount of texture memory Direct2D accumulates before it purges the image caches and cached texture allocations.</p>
        /// </summary>
        /// <param name = "maximumInBytes"><dd>  <p>The new maximum texture memory in bytes.</p> </dd></param>
        /// <remarks>
        /// <strong>Note</strong>??Direct2D may exceed the  maximum texture memory you set with this method for a single frame if necessary to render the frame.?
        /// </remarks>
        /// <doc-id>hh847985</doc-id>
        /// <unmanaged>void ID2D1Device::SetMaximumTextureMemory([In] unsigned longlong maximumInBytes)</unmanaged>
        /// <unmanaged-short>ID2D1Device::SetMaximumTextureMemory</unmanaged-short>
        internal unsafe void SetMaximumTextureMemory(System.Int64 maximumInBytes)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, maximumInBytes, (*(void ***)this._nativePointer)[6]);
        }

        /// <summary>
        /// <p>Sets the maximum amount of texture memory Direct2D accumulates before it purges the image caches and cached texture allocations.</p>
        /// </summary>
        /// <returns><p>The maximum amount of texture memory in bytes.</p></returns>
        /// <doc-id>hh847984</doc-id>
        /// <unmanaged>unsigned longlong ID2D1Device::GetMaximumTextureMemory()</unmanaged>
        /// <unmanaged-short>ID2D1Device::GetMaximumTextureMemory</unmanaged-short>
        internal unsafe System.Int64 GetMaximumTextureMemory()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }

        /// <summary>
        /// <p>Clears all of the rendering resources used by Direct2D. </p>
        /// </summary>
        /// <param name = "millisecondsSinceUse"><dd>  <p>Discards only resources that haven't been used for greater than the specified time in milliseconds. The default is 0 milliseconds.</p> </dd></param>
        /// <doc-id>hh404542</doc-id>
        /// <unmanaged>void ID2D1Device::ClearResources([In] unsigned int millisecondsSinceUse)</unmanaged>
        /// <unmanaged-short>ID2D1Device::ClearResources</unmanaged-short>
        public unsafe void ClearResources(System.Int32 millisecondsSinceUse)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, millisecondsSinceUse, (*(void ***)this._nativePointer)[8]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("d21768e1-23a4-4823-a14b-7c3eba85d658")]
    public partial class Device1 : SharpDX.Direct2D1.Device
    {
        public Device1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device1(nativePtr);
        /// <summary>
        /// <p>Retrieves or sets the current rendering priority of the device.</p>
        /// </summary>
        /// <doc-id>dn280459</doc-id>
        /// <unmanaged>GetRenderingPriority / SetRenderingPriority</unmanaged>
        /// <unmanaged-short>GetRenderingPriority</unmanaged-short>
        public SharpDX.Direct2D1.RenderingPriority RenderingPriority
        {
            get => GetRenderingPriority();
            set => SetRenderingPriority(value);
        }

        /// <summary>
        /// <p>Retrieves the current rendering priority of the device.</p>
        /// </summary>
        /// <returns><p> The current rendering priority of the device.</p></returns>
        /// <doc-id>dn280459</doc-id>
        /// <unmanaged>D2D1_RENDERING_PRIORITY ID2D1Device1::GetRenderingPriority()</unmanaged>
        /// <unmanaged-short>ID2D1Device1::GetRenderingPriority</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.RenderingPriority GetRenderingPriority()
        {
            SharpDX.Direct2D1.RenderingPriority __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1RenderingPriority(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }

        /// <summary>
        /// <p>Sets the priority of Direct2D rendering operations performed on any device context associated with the device.</p>
        /// </summary>
        /// <param name = "renderingPriority"><dd>  <p>The desired rendering priority for the device and associated contexts.</p> </dd></param>
        /// <remarks>
        /// <p>Calling this method affects the rendering priority of all device contexts associated with the device. This method can be called at any time, but is not guaranteed to take effect until the beginning of the next frame. The recommended usage is to call this method outside of <strong>BeginDraw</strong> and <strong>EndDraw</strong> blocks. Cycling this property frequently within drawing blocks will effectively reduce the benefits of any throttling that is applied.</p>
        /// </remarks>
        /// <doc-id>dn280460</doc-id>
        /// <unmanaged>void ID2D1Device1::SetRenderingPriority([In] D2D1_RENDERING_PRIORITY renderingPriority)</unmanaged>
        /// <unmanaged-short>ID2D1Device1::SetRenderingPriority</unmanaged-short>
        internal unsafe void SetRenderingPriority(SharpDX.Direct2D1.RenderingPriority renderingPriority)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)renderingPriority), (*(void ***)this._nativePointer)[10]);
        }

        /// <summary>
        /// <p>Represents a resource domain whose objects and device contexts can be used together. This interface performs all the same functions as the existing <strong><see cref = "SharpDX.Direct2D1.Device"/></strong> interface. It also enables control of the device's rendering priority.</p>
        /// </summary>
        /// <param name = "options">No documentation.</param>
        /// <param name = "deviceContext1">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>dn280458</doc-id>
        /// <unmanaged>HRESULT ID2D1Device1::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out, Fast] ID2D1DeviceContext1** deviceContext1)</unmanaged>
        /// <unmanaged-short>ID2D1Device1::CreateDeviceContext</unmanaged-short>
        internal unsafe void CreateDeviceContext(SharpDX.Direct2D1.DeviceContextOptions options, SharpDX.Direct2D1.DeviceContext1 deviceContext1)
        {
            System.IntPtr deviceContext1_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)options), &deviceContext1_, (*(void ***)this._nativePointer)[11]);
            (deviceContext1).NativePointer = deviceContext1_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("a44472e1-8dfb-4e60-8492-6e2861c9ca8b")]
    public partial class Device2 : SharpDX.Direct2D1.Device1
    {
        public Device2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device2(nativePtr);
        /// <summary>
        /// <p>Returns the DXGI device associated with this Direct2D device.</p>
        /// </summary>
        /// <doc-id>dn917489</doc-id>
        /// <unmanaged>GetDxgiDevice</unmanaged>
        /// <unmanaged-short>GetDxgiDevice</unmanaged-short>
        public SharpDX.DXGI.Device DxgiDevice
        {
            get
            {
                GetDxgiDevice(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Creates a new <strong><see cref = "SharpDX.Direct2D1.DeviceContext2"/></strong> from a Direct2D device.</p>
        /// </summary>
        /// <param name = "options">No documentation.</param>
        /// <param name = "deviceContext2">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn890787</doc-id>
        /// <unmanaged>HRESULT ID2D1Device2::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out, Fast] ID2D1DeviceContext2** deviceContext2)</unmanaged>
        /// <unmanaged-short>ID2D1Device2::CreateDeviceContext</unmanaged-short>
        internal unsafe void CreateDeviceContext(SharpDX.Direct2D1.DeviceContextOptions options, SharpDX.Direct2D1.DeviceContext2 deviceContext2)
        {
            System.IntPtr deviceContext2_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)options), &deviceContext2_, (*(void ***)this._nativePointer)[12]);
            (deviceContext2).NativePointer = deviceContext2_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Flush all device contexts that reference a given bitmap.</p>
        /// </summary>
        /// <param name = "bitmap"><dd>  <p>The bitmap, created on this device, for which all referencing device contexts will be flushed. </p> </dd></param>
        /// <doc-id>dn890788</doc-id>
        /// <unmanaged>void ID2D1Device2::FlushDeviceContexts([In] ID2D1Bitmap* bitmap)</unmanaged>
        /// <unmanaged-short>ID2D1Device2::FlushDeviceContexts</unmanaged-short>
        public unsafe void FlushDeviceContexts(SharpDX.Direct2D1.Bitmap bitmap)
        {
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            bitmap_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Bitmap>(bitmap);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)bitmap_, (*(void ***)this._nativePointer)[13]);
        }

        /// <summary>
        /// <p>Returns the DXGI device associated with this Direct2D device.</p>
        /// </summary>
        /// <param name = "dxgiDevice"><dd>  <p>The DXGI device associated with this Direct2D device.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn917489</doc-id>
        /// <unmanaged>HRESULT ID2D1Device2::GetDxgiDevice([Out] IDXGIDevice** dxgiDevice)</unmanaged>
        /// <unmanaged-short>ID2D1Device2::GetDxgiDevice</unmanaged-short>
        internal unsafe void GetDxgiDevice(out SharpDX.DXGI.Device dxgiDevice)
        {
            System.IntPtr dxgiDevice_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &dxgiDevice_, (*(void ***)this._nativePointer)[14]);
            if (dxgiDevice_ != System.IntPtr.Zero)
                dxgiDevice = new SharpDX.DXGI.Device(dxgiDevice_);
            else
                dxgiDevice = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("852f2087-802c-4037-ab60-ff2e7ee6fc01")]
    public partial class Device3 : SharpDX.Direct2D1.Device2
    {
        public Device3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device3(nativePtr);
        /// <summary>
        /// <p>Creates a new <strong><see cref = "SharpDX.Direct2D1.DeviceContext3"/></strong> from this Direct2D device.</p>
        /// </summary>
        /// <param name = "options">No documentation.</param>
        /// <param name = "deviceContext3">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>mt619825</doc-id>
        /// <unmanaged>HRESULT ID2D1Device3::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out, Fast] ID2D1DeviceContext3** deviceContext3)</unmanaged>
        /// <unmanaged-short>ID2D1Device3::CreateDeviceContext</unmanaged-short>
        internal unsafe void CreateDeviceContext(SharpDX.Direct2D1.DeviceContextOptions options, SharpDX.Direct2D1.DeviceContext3 deviceContext3)
        {
            System.IntPtr deviceContext3_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)options), &deviceContext3_, (*(void ***)this._nativePointer)[15]);
            (deviceContext3).NativePointer = deviceContext3_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("d7bdb159-5683-4a46-bc9c-72dc720b858b")]
    public partial class Device4 : SharpDX.Direct2D1.Device3
    {
        public Device4(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device4(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device4(nativePtr);
        /// <summary>
        /// <p>Gets or sets the maximum capacity of the color glyph cache.</p>
        /// </summary>
        /// <doc-id>mt736466</doc-id>
        /// <unmanaged>GetMaximumColorGlyphCacheMemory / SetMaximumColorGlyphCacheMemory</unmanaged>
        /// <unmanaged-short>GetMaximumColorGlyphCacheMemory</unmanaged-short>
        public System.Int64 MaximumColorGlyphCacheMemory
        {
            get => GetMaximumColorGlyphCacheMemory();
            set => SetMaximumColorGlyphCacheMemory(value);
        }

        /// <summary>
        /// <p>Creates a new device context from a Direct2D device.</p>
        /// </summary>
        /// <param name = "options"><dd>  <p>The options to be applied to the created device context.</p> </dd></param>
        /// <param name = "deviceContext4"><dd>  <p>When this method returns, contains the address of a reference to the new device context.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The new device context will not have a  selected target bitmap. The caller must create and select a bitmap as the target surface of the context.</p>
        /// </remarks>
        /// <doc-id>hh404545</doc-id>
        /// <unmanaged>HRESULT ID2D1Device4::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out, Fast] ID2D1DeviceContext4** deviceContext4)</unmanaged>
        /// <unmanaged-short>ID2D1Device4::CreateDeviceContext</unmanaged-short>
        internal unsafe void CreateDeviceContext(SharpDX.Direct2D1.DeviceContextOptions options, SharpDX.Direct2D1.DeviceContext4 deviceContext4)
        {
            System.IntPtr deviceContext4_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)options), &deviceContext4_, (*(void ***)this._nativePointer)[16]);
            (deviceContext4).NativePointer = deviceContext4_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the maximum capacity of the color glyph cache. </p>
        /// </summary>
        /// <param name = "maximumInBytes"><dd>  <p>The maximum capacity of the color glyph cache.</p> </dd></param>
        /// <remarks>
        /// <p>The color glyph cache is used to store color bitmap glyphs and SVG glyphs, enabling faster performance if the same glyphs are needed again. The capacity determines the amount of memory that D2D may use to store glyphs that the application does not already reference. If the application references a glyph using <strong>GetColorBitmapGlyphImage</strong> or <strong>GetSvgGlyphImage</strong>, after it has been evicted, this glyph does not count toward the cache capacity.</p>
        /// </remarks>
        /// <doc-id>mt736467</doc-id>
        /// <unmanaged>void ID2D1Device4::SetMaximumColorGlyphCacheMemory([In] unsigned longlong maximumInBytes)</unmanaged>
        /// <unmanaged-short>ID2D1Device4::SetMaximumColorGlyphCacheMemory</unmanaged-short>
        internal unsafe void SetMaximumColorGlyphCacheMemory(System.Int64 maximumInBytes)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, maximumInBytes, (*(void ***)this._nativePointer)[17]);
        }

        /// <summary>
        /// <p>Gets the maximum capacity of the color glyph cache.</p>
        /// </summary>
        /// <returns><p>Returns the maximum capacity of the color glyph cache in bytes.</p></returns>
        /// <doc-id>mt736466</doc-id>
        /// <unmanaged>unsigned longlong ID2D1Device4::GetMaximumColorGlyphCacheMemory()</unmanaged>
        /// <unmanaged-short>ID2D1Device4::GetMaximumColorGlyphCacheMemory</unmanaged-short>
        internal unsafe System.Int64 GetMaximumColorGlyphCacheMemory()
        {
            System.Int64 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCalllong(this._nativePointer, (*(void ***)this._nativePointer)[18]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("d55ba0a4-6405-4694-aef5-08ee1a4358b4")]
    public partial class Device5 : SharpDX.Direct2D1.Device4
    {
        public Device5(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Device5(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Device5(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "options">No documentation.</param>
        /// <param name = "deviceContext5">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1Device5::CreateDeviceContext([In] D2D1_DEVICE_CONTEXT_OPTIONS options,[Out, Fast] ID2D1DeviceContext5** deviceContext5)</unmanaged>
        /// <unmanaged-short>ID2D1Device5::CreateDeviceContext</unmanaged-short>
        internal unsafe void CreateDeviceContext(SharpDX.Direct2D1.DeviceContextOptions options, SharpDX.Direct2D1.DeviceContext5 deviceContext5)
        {
            System.IntPtr deviceContext5_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)options), &deviceContext5_, (*(void ***)this._nativePointer)[19]);
            (deviceContext5).NativePointer = deviceContext5_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("e8f7fe7a-191c-466d-ad95-975678bda998")]
    public partial class DeviceContext : SharpDX.Direct2D1.RenderTarget
    {
        public DeviceContext(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceContext(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceContext(nativePtr);
        /// <summary>
        /// <p>Gets the device associated with a device context.</p>
        /// </summary>
        /// <remarks>
        /// <p>The application can retrieve the device even if it is created from an earlier render target code-path. The application must use an <strong><see cref = "SharpDX.Direct2D1.DeviceContext"/></strong> interface and then call <strong>GetDevice</strong>. Some functionality for controlling all of the resources for a set of device contexts is maintained only on an <strong><see cref = "SharpDX.Direct2D1.Device"/></strong> object.</p>
        /// </remarks>
        /// <doc-id>hh404513</doc-id>
        /// <unmanaged>GetDevice</unmanaged>
        /// <unmanaged-short>GetDevice</unmanaged-short>
        public SharpDX.Direct2D1.Device Device
        {
            get
            {
                GetDevice(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets or sets the target currently associated with the device context.</p>
        /// </summary>
        /// <remarks>
        /// <p>If a target is not associated with the device context, <em>target</em> will contain <strong><c>null</c></strong> when the methods returns.</p><p>If the currently selected target is a bitmap rather than a command list, the application can gain access to the initial bitmaps created by using one of the following methods:</p><ul> <li> <strong>CreateHwndRenderTarget</strong> </li> <li> <strong>CreateDxgiSurfaceRenderTarget</strong> </li> <li> <strong>CreateWicBitmapRenderTarget</strong> </li> <li> <strong>CreateDCRenderTarget</strong> </li> <li> <strong>CreateCompatibleRenderTarget</strong> </li> </ul><p>It is not possible for an application to destroy these bitmaps.  All of these bitmaps are bindable as bitmap targets.  However not all of these bitmaps can be used as bitmap sources for  <strong><see cref = "SharpDX.Direct2D1.RenderTarget"/></strong> methods.</p><p> <strong>CreateDxgiSurfaceRenderTarget</strong> will create a bitmap that is usable as a bitmap source if the DXGI surface is bindable as a shader resource view.</p><p> <strong>CreateCompatibleRenderTarget</strong> will always create bitmaps that are usable as a bitmap source.</p><p> <strong>ID2D1RenderTarget::BeginDraw</strong> will copy from the <see cref = "System.IntPtr"/> to the original bitmap associated with it.  <strong>ID2D1RenderTarget::EndDraw</strong> will copy from the original bitmap to the <see cref = "System.IntPtr"/>.  </p><p> <strong><see cref = "SharpDX.WIC.Bitmap"/></strong> objects will be locked in the following circumstances:</p><ul> <li>BeginDraw has been called and the currently selected target bitmap is a WIC bitmap.</li> <li>A WIC bitmap is set as the target of a device context after BeginDraw has been called and before EndDraw has been called.</li> <li>Any of the ID2D1Bitmap::Copy* methods are called with a WIC bitmap as either the source or destination.</li> </ul><p><see cref = "SharpDX.WIC.Bitmap"/> objects will be unlocked in the following circumstances:</p><ul> <li>EndDraw is called and the currently selected target bitmap is a WIC bitmap.</li> <li>A WIC bitmap is removed as the target of a device context between the calls to BeginDraw and EndDraw.</li> <li>Any of the ID2D1Bitmap::Copy* methods are called with a WIC bitmap as either the source or destination.</li> </ul><p>Direct2D will only lock bitmaps that are not currently locked.</p><p>Calling <strong>QueryInterface</strong> for <strong><see cref = "SharpDX.Direct2D1.GdiInteropRenderTarget"/></strong> will always succeed.  <strong>ID2D1GdiInteropRenderTarget::GetDC</strong> will return a device context corresponding to the currently bound target bitmap.  GetDC will fail if the target bitmap was not created with the GDI_COMPATIBLE flag set.</p><p> <strong>ID2D1HwndRenderTarget::Resize</strong> will return <strong><see cref = "InvalidCall"/></strong> if there are any outstanding references to the original target bitmap associated with the render target.</p><p>Although the target can be a command list, it cannot be any other type of image. It cannot be the output image of an effect.</p>
        /// </remarks>
        /// <doc-id>hh404523</doc-id>
        /// <unmanaged>GetTarget / SetTarget</unmanaged>
        /// <unmanaged-short>GetTarget</unmanaged-short>
        public SharpDX.Direct2D1.Image Target
        {
            get
            {
                GetTarget(out var __output__);
                return __output__;
            }

            set => SetTarget(value);
        }

        /// <summary>
        /// <p>Gets or sets the rendering controls that have been applied to the context.</p>
        /// </summary>
        /// <doc-id>hh404519</doc-id>
        /// <unmanaged>GetRenderingControls / SetRenderingControls</unmanaged>
        /// <unmanaged-short>GetRenderingControls</unmanaged-short>
        public SharpDX.Direct2D1.RenderingControls RenderingControls
        {
            get
            {
                GetRenderingControls(out var __output__);
                return __output__;
            }

            set => SetRenderingControls(value);
        }

        /// <summary>
        /// <p>Returns or sets the currently set primitive blend used by the device context.  </p>
        /// </summary>
        /// <doc-id>hh404517</doc-id>
        /// <unmanaged>GetPrimitiveBlend / SetPrimitiveBlend</unmanaged>
        /// <unmanaged-short>GetPrimitiveBlend</unmanaged-short>
        public SharpDX.Direct2D1.PrimitiveBlend PrimitiveBlend
        {
            get => GetPrimitiveBlend();
            set => SetPrimitiveBlend(value);
        }

        /// <summary>
        /// <p>Gets or sets the mode that  is being used to interpret values by the device context.</p>
        /// </summary>
        /// <doc-id>hh404525</doc-id>
        /// <unmanaged>GetUnitMode / SetUnitMode</unmanaged>
        /// <unmanaged-short>GetUnitMode</unmanaged-short>
        public SharpDX.Direct2D1.UnitMode UnitMode
        {
            get => GetUnitMode();
            set => SetUnitMode(value);
        }

        /// <summary>
        /// <p>Creates a bitmap that can be used as a target surface, for reading back to the CPU, or as a source for the <strong>DrawBitmap</strong> and <strong><see cref = "SharpDX.Direct2D1.BitmapBrush"/></strong> APIs. In addition, color context information can be passed to the bitmap.</p>
        /// </summary>
        /// <param name = "size">No documentation.</param>
        /// <param name = "sourceData">No documentation.</param>
        /// <param name = "pitch">No documentation.</param>
        /// <param name = "bitmapProperties">No documentation.</param>
        /// <param name = "bitmap">No documentation.</param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The new bitmap can be used as a target for <strong>SetTarget</strong> if it is created with <strong>D2D1_BITMAP_OPTIONS_TARGET</strong>.</p>
        /// </remarks>
        /// <doc-id>hh404480</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmap([In] D2D_SIZE_U size,[In, Optional] const void* sourceData,[In] unsigned int pitch,[In] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out, Fast] ID2D1Bitmap1** bitmap)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::CreateBitmap</unmanaged-short>
        internal unsafe void CreateBitmap(SharpDX.Size2 size, System.IntPtr sourceData, System.Int32 pitch, SharpDX.Direct2D1.BitmapProperties1 bitmapProperties, SharpDX.Direct2D1.Bitmap1 bitmap)
        {
            SharpDX.Direct2D1.BitmapProperties1.__Native bitmapProperties_ = default (SharpDX.Direct2D1.BitmapProperties1.__Native);
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            bitmapProperties.__MarshalTo(ref bitmapProperties_);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, size, (void *)sourceData, pitch, &bitmapProperties_, &bitmap_, (*(void ***)this._nativePointer)[57]);
            (bitmap).NativePointer = bitmap_;
            bitmapProperties.__MarshalFree(ref bitmapProperties_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a Direct2D bitmap by copying a WIC bitmap.</p>
        /// </summary>
        /// <param name = "wicBitmapSource"><dd>  <p>The WIC bitmap source to copy from.</p> </dd></param>
        /// <param name = "bitmapProperties"><dd>  <p>A bitmap properties structure that specifies bitmap creation options.</p> </dd></param>
        /// <param name = "bitmap"><dd>  <p>The address of the newly created bitmap object.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>Starting with Windows?8.1, the  <em>bitmapProperties</em> parameter is optional. When it is not specified, the created bitmap inherits the pixel format and alpha mode from  <em>wicBitmapSource</em>. For a list of supported pixel formats and alpha modes, see Supported Pixel Formats and Alpha Modes.</p><p>When the <em>bitmapProperties</em> parameter is specified, the value in <em>bitmapProperties-&gt;pixelFormat</em> must either be <strong>DXGI_FORMAT_UNKNOWN</strong> or must match the WIC pixel format in <em>wicBitmapSource</em>.</p><p>When <em>bitmapProperties-&gt;pixelFormat.alphaMode</em> is set to <strong>D2D1_ALPHA_MODE_UNKNOWN</strong>, the newly created bitmap inherits the alpha mode from <em>wicBitmapSource</em>. When <em>bitmapProperties-&gt;pixelFormat.alphaMode</em> is set to <strong>D2D1_ALPHA_MODE_PREMULTIPLIED</strong>, <strong>D2D1_ALPHA_MODE_STRAIGHT</strong>, or <strong>D2D1_ALPHA_MODE_IGNORE</strong>, this forces the newly created bitmap to use the specified alpha mode.</p>
        /// </remarks>
        /// <doc-id>hh847971</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapFromWicBitmap([In] IWICBitmapSource* wicBitmapSource,[In, Optional] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out] ID2D1Bitmap1** bitmap)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::CreateBitmapFromWicBitmap</unmanaged-short>
        internal unsafe void CreateBitmapFromWicBitmap(SharpDX.WIC.BitmapSource wicBitmapSource, SharpDX.Direct2D1.BitmapProperties1 bitmapProperties, out SharpDX.Direct2D1.Bitmap1 bitmap)
        {
            System.IntPtr wicBitmapSource_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.BitmapProperties1.__Native bitmapProperties_ = default (SharpDX.Direct2D1.BitmapProperties1.__Native);
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            wicBitmapSource_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(wicBitmapSource);
            if (bitmapProperties != null)
                bitmapProperties.__MarshalTo(ref bitmapProperties_);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)wicBitmapSource_, bitmapProperties == null ? (void *)0 : &bitmapProperties_, &bitmap_, (*(void ***)this._nativePointer)[58]);
            if (bitmap_ != System.IntPtr.Zero)
                bitmap = new SharpDX.Direct2D1.Bitmap1(bitmap_);
            else
                bitmap = null;
            if (bitmapProperties != null)
                bitmapProperties.__MarshalFree(ref bitmapProperties_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a color context.</p>
        /// </summary>
        /// <param name = "space"><dd>  <p>The space  of color context to create.</p> </dd></param>
        /// <param name = "rofileRef"><dd>  <p>A buffer containing the ICC profile bytes used to initialize the color context when <em>space</em> is <strong>D2D1_COLOR_SPACE_CUSTOM</strong>.  For other types, the parameter is ignored and should be set to <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "profileSize"><dd>  <p>The size in bytes of <em>Profile</em>.</p> </dd></param>
        /// <param name = "colorContext"><dd>  <p>When this method returns, contains the address of a reference to a new color context object.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The new color context can be used in <strong><see cref = "SharpDX.Direct2D1.BitmapProperties1"/></strong> to initialize the color context of a created bitmap.</p><p>When <em>space</em> is <strong>D2D1_COLOR_SPACE_CUSTOM</strong>, <em>profile</em> and <em>profileSize</em> must be specified.  Otherwise, these parameters should be set to <strong><c>null</c></strong> and zero respectively.  When the space is D2D1_COLOR_SPACE_CUSTOM, the model field of the profile header is inspected to determine if this profile is sRGB or scRGB and the color space is updated respectively.  Otherwise the space remains custom.</p>
        /// </remarks>
        /// <doc-id>hh404485</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateColorContext([In] D2D1_COLOR_SPACE space,[In, Buffer, Optional] const unsigned char* profile,[In] unsigned int profileSize,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::CreateColorContext</unmanaged-short>
        internal unsafe void CreateColorContext(SharpDX.Direct2D1.ColorSpace space, System.Byte[] rofileRef, System.Int32 profileSize, SharpDX.Direct2D1.ColorContext colorContext)
        {
            System.IntPtr colorContext_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *rofileRef_ = rofileRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)space), rofileRef_, profileSize, &colorContext_, (*(void ***)this._nativePointer)[59]);
            (colorContext).NativePointer = colorContext_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a color context by loading it from the specified filename.  The profile bytes are the contents of the file specified by <em>Filename</em>.</p>
        /// </summary>
        /// <param name = "filename"><dd>  <p>The path to the file containing the profile bytes to initialize the color context with.</p> </dd></param>
        /// <param name = "colorContext"><dd>  <p>When this method returns, contains the address of a reference to a new color context.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The new color context can be used in <strong><see cref = "SharpDX.Direct2D1.BitmapProperties1"/></strong> to initialize the color context of a created bitmap.  The model field of the profile header is inspected to determine whether this profile is sRGB or scRGB and the color space is updated respectively.  Otherwise the space is  custom.</p>
        /// </remarks>
        /// <doc-id>hh404488</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateColorContextFromFilename([In] const wchar_t* filename,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::CreateColorContextFromFilename</unmanaged-short>
        internal unsafe void CreateColorContextFromFilename(System.String filename, SharpDX.Direct2D1.ColorContext colorContext)
        {
            System.IntPtr colorContext_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (char *filename_ = filename)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)filename_, &colorContext_, (*(void ***)this._nativePointer)[60]);
            (colorContext).NativePointer = colorContext_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a color context from an <strong><see cref = "SharpDX.WIC.ColorContext"/></strong>.  The <strong>D2D1ColorContext</strong> space of the resulting context varies, see Remarks for more info.</p>
        /// </summary>
        /// <param name = "wicColorContext">No documentation.</param>
        /// <param name = "colorContext">No documentation.</param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The new color context can be used in <strong><see cref = "SharpDX.Direct2D1.BitmapProperties1"/></strong> to initialize the color context of a created bitmap.  The model field of the profile header is inspected to determine whether this profile is sRGB or scRGB and the color space is updated respectively.  Otherwise the space is  custom.</p>
        /// </remarks>
        /// <doc-id>hh404491</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateColorContextFromWicColorContext([In] IWICColorContext* wicColorContext,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::CreateColorContextFromWicColorContext</unmanaged-short>
        internal unsafe void CreateColorContextFromWicColorContext(SharpDX.WIC.ColorContext wicColorContext, SharpDX.Direct2D1.ColorContext colorContext)
        {
            System.IntPtr wicColorContext_ = System.IntPtr.Zero;
            System.IntPtr colorContext_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            wicColorContext_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.ColorContext>(wicColorContext);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)wicColorContext_, &colorContext_, (*(void ***)this._nativePointer)[61]);
            (colorContext).NativePointer = colorContext_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a bitmap from a DXGI surface that can be set as a target surface or have additional color context information specified.</p>
        /// </summary>
        /// <param name = "surface"><dd>  <p>The DXGI surface from which the bitmap can be created.  </p> <strong>Note</strong>??The DXGI surface must have been created from the same Direct3D device that the Direct2D device context is associated with. ? </dd></param>
        /// <param name = "bitmapProperties"><dd>  <p>The bitmap properties specified in addition to the surface. </p> </dd></param>
        /// <param name = "bitmap"><dd>  <p>When this method returns, contains the address of a reference to a new bitmap object.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>If the bitmap properties are not specified, the following information is assumed: </p><ul> <li>The bitmap DPI is 96.</li> <li>The pixel format matches that of the surface.</li> <li>The returned bitmap will inherit the bind flags of the DXGI surface.<ul> <li>However, only the subset of flags meaningful to Direct2D will be inherited. For example, D3D10_USAGE_DYNAMIC is not compatible with any public Direct2D flags.</li> </ul> </li> <li>The color context is unknown.</li> <li>The alpha mode of the bitmap will be premultiplied (common case) or straight (A8).
        /// </li> </ul><p>If the bitmap properties are specified, the bitmap properties will be used as follows:</p><ul> <li>The bitmap DPI will be specified by the bitmap properties.</li> <li>If both dpiX and dpiY are 0, the bitmap DPI will be 96.</li> <li>The pixel format must be compatible with the shader resource view or render target view of the surface.</li> <li>The bitmap options must be compatible with the bind flags of the DXGI surface. However, they may be a subset. This will influence what resource views are created by the bitmap.</li> <li>The color context information will be used from the bitmap properties, if specified.</li> </ul>
        /// </remarks>
        /// <doc-id>hh404482</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapFromDxgiSurface([In] IDXGISurface* surface,[In, Optional] const D2D1_BITMAP_PROPERTIES1* bitmapProperties,[Out, Fast] ID2D1Bitmap1** bitmap)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::CreateBitmapFromDxgiSurface</unmanaged-short>
        internal unsafe void CreateBitmapFromDxgiSurface(SharpDX.DXGI.Surface surface, SharpDX.Direct2D1.BitmapProperties1 bitmapProperties, SharpDX.Direct2D1.Bitmap1 bitmap)
        {
            System.IntPtr surface_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.BitmapProperties1.__Native bitmapProperties_ = default (SharpDX.Direct2D1.BitmapProperties1.__Native);
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            surface_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Surface>(surface);
            if (bitmapProperties != null)
                bitmapProperties.__MarshalTo(ref bitmapProperties_);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)surface_, bitmapProperties == null ? (void *)0 : &bitmapProperties_, &bitmap_, (*(void ***)this._nativePointer)[62]);
            (bitmap).NativePointer = bitmap_;
            if (bitmapProperties != null)
                bitmapProperties.__MarshalFree(ref bitmapProperties_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an effect for the specified class ID. </p>
        /// </summary>
        /// <param name = "effectId"><dd>  <p>The class ID of the effect to create. See Built-in Effects for a list of effect IDs.</p> </dd></param>
        /// <param name = "effect"><dd>  <p>When this method returns, contains the address of a reference to a new effect.</p> </dd></param>
        /// <returns><p> The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call. </td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation. </td></tr> <tr><td><see cref = "EffectIsNotRegistered"/></td><td>The specified effect is not registered by the system.</td></tr> <tr><td><see cref = "InsufficientDeviceCapabilities"/> </td><td>The effect requires capabilities not supported by the D2D device.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p> If the  created effect is a custom effect that is implemented in a DLL, this doesn't increment the reference count for that DLL.  If the application deletes an effect while that effect is loaded, the resulting behavior is unpredictable. </p>
        /// </remarks>
        /// <doc-id>hh404500</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateEffect([In] const GUID&amp; effectId,[Out, Fast] ID2D1Effect** effect)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::CreateEffect</unmanaged-short>
        internal unsafe void CreateEffect(System.Guid effectId, SharpDX.Direct2D1.Effect effect)
        {
            System.IntPtr effect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &effectId, &effect_, (*(void ***)this._nativePointer)[63]);
            (effect).NativePointer = effect_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a gradient stop collection, enabling the gradient to contain color channels with values outside of [0,1] and also enabling rendering to a high-color render target with interpolation in sRGB space.</p>
        /// </summary>
        /// <param name = "straightAlphaGradientStops"><dd>  <p>An array of color values and offsets.</p> </dd></param>
        /// <param name = "straightAlphaGradientStopsCount"><dd>  <p>The number of elements in the <em>gradientStops</em> array.</p> </dd></param>
        /// <param name = "preInterpolationSpace"><dd>  <p>Specifies both the input color space and the space in which the color interpolation occurs.</p> </dd></param>
        /// <param name = "postInterpolationSpace"><dd>  <p>The color space that colors will be converted to after interpolation occurs.</p> </dd></param>
        /// <param name = "bufferPrecision"><dd>  <p>The precision of the texture used to hold interpolated values.</p> <strong>Note</strong>??This method will fail if the underlying Direct3D device does not support the requested buffer precision.  Use <strong>ID2D1DeviceContext::IsBufferPrecisionSupported</strong> to determine what is supported. ? </dd></param>
        /// <param name = "extendMode"><dd>  <p>Defines how colors outside of the range defined by the stop collection are determined.</p> </dd></param>
        /// <param name = "colorInterpolationMode"><dd>  <p>Defines how colors are interpolated.  D2D1_COLOR_INTERPOLATION_MODE_PREMULTIPLIED is the default, see Remarks for more info.</p> </dd></param>
        /// <param name = "gradientStopCollection1"><dd>  <p>The new gradient stop collection.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>This method linearly interpolates between the color stops. An optional color space conversion is applied post-interpolation. Whether and how this gamma conversion is applied is determined by the pre- and post-interpolation. This method will fail if the device context does not support the requested buffer precision.</p><p>In order to get the desired result, you need to ensure that the inputs are specified in the correct color space. 
        /// </p><p>You must always specify colors in straight alpha, regardless of interpolation mode being premultiplied or straight. The interpolation mode only affects the interpolated values. Likewise, the stops returned by <strong>ID2D1GradientStopCollection::GetGradientStops</strong> will always have straight alpha. </p><p>If you specify <strong>D2D1_COLOR_INTERPOLATION_MODE_PREMULTIPLIED</strong>, then all stops are premultiplied before interpolation, and then un-premultiplied before color conversion.
        /// </p><p>Starting with Windows?8, the interpolation behavior of this method has changed.  </p><p>The table here shows the behavior in Windows?7 and earlier.</p><table> <tr><th>Gamma</th><th>Before Interpolation Behavior</th><th>After Interpolation Behavior</th><th>GetColorInteroplationGamma
        /// (output color space)
        /// </th></tr> <tr><td>1.0</td><td>Clamps the inputs and then converts from sRGB to scRGB.</td><td>Converts from scRGB to sRGB post-interpolation.</td><td>1.0</td></tr> <tr><td>2.2</td><td>Clamps the inputs.</td><td>No Operation</td><td>2.2</td></tr> </table><p>?</p><p>The table here shows the behavior in Windows?8 and later.</p><table> <tr><th>Gamma</th><th>Before Interpolation Behavior</th><th>After Interpolation Behavior</th><th>GetColorInteroplationGamma
        /// (output color space)
        /// </th></tr> <tr><td>sRGB to scRGB</td><td>No Operation</td><td>Clamps the outputs and then converts from sRGB to scRGB.</td><td>1.0</td></tr> <tr><td>scRGB to sRGB</td><td>No Operation</td><td>Clamps the outputs and then converts from sRGB to scRGB.</td><td>2.2</td></tr> <tr><td>sRGB to sRGB</td><td>No Operation</td><td>No Operation</td><td>2.2</td></tr> <tr><td>scRGB to scRGB</td><td>No Operation</td><td>No Operation</td><td>1.0</td></tr> </table><p>?</p>
        /// </remarks>
        /// <doc-id>hh404502</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateGradientStopCollection([In, Buffer] const D2D1_GRADIENT_STOP* straightAlphaGradientStops,[In] unsigned int straightAlphaGradientStopsCount,[In] D2D1_COLOR_SPACE preInterpolationSpace,[In] D2D1_COLOR_SPACE postInterpolationSpace,[In] D2D1_BUFFER_PRECISION bufferPrecision,[In] D2D1_EXTEND_MODE extendMode,[In] D2D1_COLOR_INTERPOLATION_MODE colorInterpolationMode,[Out, Fast] ID2D1GradientStopCollection1** gradientStopCollection1)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::CreateGradientStopCollection</unmanaged-short>
        internal unsafe void CreateGradientStopCollection(SharpDX.Direct2D1.GradientStop[] straightAlphaGradientStops, System.Int32 straightAlphaGradientStopsCount, SharpDX.Direct2D1.ColorSpace preInterpolationSpace, SharpDX.Direct2D1.ColorSpace postInterpolationSpace, SharpDX.Direct2D1.BufferPrecision bufferPrecision, SharpDX.Direct2D1.ExtendMode extendMode, SharpDX.Direct2D1.ColorInterpolationMode colorInterpolationMode, SharpDX.Direct2D1.GradientStopCollection1 gradientStopCollection1)
        {
            System.IntPtr gradientStopCollection1_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *straightAlphaGradientStops_ = straightAlphaGradientStops)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, straightAlphaGradientStops_, straightAlphaGradientStopsCount, unchecked ((System.Int32)preInterpolationSpace), unchecked ((System.Int32)postInterpolationSpace), unchecked ((System.Int32)bufferPrecision), unchecked ((System.Int32)extendMode), unchecked ((System.Int32)colorInterpolationMode), &gradientStopCollection1_, (*(void ***)this._nativePointer)[64]);
            (gradientStopCollection1).NativePointer = gradientStopCollection1_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an image brush. The input image can be any type of image, including a bitmap, effect, or a command list.
        /// </p>
        /// </summary>
        /// <param name = "image"><dd>  <p>The image to be used as a source for the image brush.</p> </dd></param>
        /// <param name = "imageBrushProperties"><dd>  <p>The properties specific to an image brush.</p> </dd></param>
        /// <param name = "brushProperties"><dd>  <p>Properties  common to all brushes.</p> </dd></param>
        /// <param name = "imageBrush"><dd>  <p>When this method returns, contains the address of a reference to the  input rectangles.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The image brush can be used to fill an arbitrary geometry, an opacity mask or text.</p><p>This sample illustrates drawing a rectangle with an image brush.</p><pre><see cref = "SharpDX.Result"/>
        /// CreatePatternBrush( __in <see cref = "SharpDX.Direct2D1.DeviceContext"/> *pDeviceContext, __deref_out <see cref = "SharpDX.Direct2D1.ImageBrush"/> **ppImageBrush )
        /// { <see cref = "SharpDX.Result"/> hr = <see cref = "SharpDX.Result.Ok"/>; <see cref = "SharpDX.Direct2D1.Image"/> *pOldTarget = <c>null</c>; pDeviceContext-&gt;GetTarget(&amp;pOldTarget); <see cref = "SharpDX.Direct2D1.CommandList"/> *pCommandList = <c>null</c>; hr = pDeviceContext-&gt;CreateCommandList(&amp;pCommandList); if (SUCCEEDED(hr)) {    pDeviceContext-&gt;SetTarget(pCommandList); hr = RenderPatternToCommandList(pDeviceContext); } pDeviceContext-&gt;SetTarget(pOldTarget); <see cref = "SharpDX.Direct2D1.ImageBrush"/> *pImageBrush = <c>null</c>; if (SUCCEEDED(hr)) {         hr = pDeviceContext-&gt;CreateImageBrush( pCommandList, D2D1::ImageBrushProperties( D2D1::RectF(198, 298, 370, 470), D2D1_EXTEND_MODE_WRAP, D2D1_EXTEND_MODE_WRAP, D2D1_INTERPOLATION_MODE_LINEAR ), &amp;pImageBrush ); } // Fill a rectangle with the image brush. if (SUCCEEDED(hr)) { pDeviceContext-&gt;FillRectangle( D2D1::RectF(0, 0, 100, 100), pImageBrush); } SafeRelease(&amp;pImageBrush); SafeRelease(&amp;pCommandList); SafeRelease(&amp;pOldTarget); return hr;
        /// }</pre>
        /// </remarks>
        /// <doc-id>hh404506</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateImageBrush([In, Optional] ID2D1Image* image,[In] const D2D1_IMAGE_BRUSH_PROPERTIES* imageBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1ImageBrush** imageBrush)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::CreateImageBrush</unmanaged-short>
        internal unsafe void CreateImageBrush(SharpDX.Direct2D1.Image image, ref SharpDX.Direct2D1.ImageBrushProperties imageBrushProperties, SharpDX.Direct2D1.BrushProperties? brushProperties, SharpDX.Direct2D1.ImageBrush imageBrush)
        {
            System.IntPtr image_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.BrushProperties brushProperties_;
            System.IntPtr imageBrush_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            image_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Image>(image);
            if (brushProperties != null)
                brushProperties_ = brushProperties.Value;
            fixed (void *imageBrushProperties_ = &imageBrushProperties)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)image_, imageBrushProperties_, brushProperties == null ? (void *)0 : &brushProperties_, &imageBrush_, (*(void ***)this._nativePointer)[65]);
            (imageBrush).NativePointer = imageBrush_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a bitmap brush, the input image is a Direct2D bitmap object.</p>
        /// </summary>
        /// <param name = "bitmap"><dd>  <p>The bitmap to use as the brush.</p> </dd></param>
        /// <param name = "bitmapBrushProperties"><dd>  <p>A bitmap brush properties structure.</p> </dd></param>
        /// <param name = "brushProperties"><dd>  <p>A brush properties structure.</p> </dd></param>
        /// <param name = "bitmapBrush"><dd>  <p>The address of the newly created bitmap brush object.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh847970</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateBitmapBrush([In, Optional] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_BITMAP_BRUSH_PROPERTIES1* bitmapBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1BitmapBrush1** bitmapBrush)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::CreateBitmapBrush</unmanaged-short>
        internal unsafe void CreateBitmapBrush(SharpDX.Direct2D1.Bitmap bitmap, SharpDX.Direct2D1.BitmapBrushProperties1? bitmapBrushProperties, SharpDX.Direct2D1.BrushProperties? brushProperties, SharpDX.Direct2D1.BitmapBrush1 bitmapBrush)
        {
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.BitmapBrushProperties1 bitmapBrushProperties_;
            SharpDX.Direct2D1.BrushProperties brushProperties_;
            System.IntPtr bitmapBrush_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            bitmap_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Bitmap>(bitmap);
            if (bitmapBrushProperties != null)
                bitmapBrushProperties_ = bitmapBrushProperties.Value;
            if (brushProperties != null)
                brushProperties_ = brushProperties.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)bitmap_, bitmapBrushProperties == null ? (void *)0 : &bitmapBrushProperties_, brushProperties == null ? (void *)0 : &brushProperties_, &bitmapBrush_, (*(void ***)this._nativePointer)[66]);
            (bitmapBrush).NativePointer = bitmapBrush_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a <strong><see cref = "SharpDX.Direct2D1.CommandList"/></strong> object.</p>
        /// </summary>
        /// <param name = "commandList">No documentation.</param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>A <strong><see cref = "SharpDX.Direct2D1.CommandList"/></strong> can store Direct2D commands to be displayed later through <strong>ID2D1DeviceContext::DrawImage</strong> or through an image brush.</p>
        /// </remarks>
        /// <doc-id>hh404494</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::CreateCommandList([Out, Fast] ID2D1CommandList** commandList)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::CreateCommandList</unmanaged-short>
        internal unsafe void CreateCommandList(SharpDX.Direct2D1.CommandList commandList)
        {
            System.IntPtr commandList_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &commandList_, (*(void ***)this._nativePointer)[67]);
            (commandList).NativePointer = commandList_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Indicates whether the format is supported by the device context.  The formats supported are usually determined by the underlying hardware.</p>
        /// </summary>
        /// <param name = "format"><dd>  <p>The DXGI format to check.</p> </dd></param>
        /// <returns><p>Returns TRUE if the format is supported.  Returns <see cref = "SharpDX.Result.False"/> if the format is not supported.</p></returns>
        /// <remarks>
        /// <p>You can use supported formats in the <strong><see cref = "SharpDX.Direct2D1.PixelFormat"/></strong> structure to create bitmaps and render targets. Direct2D doesn't support all DXGI formats, even though they may have some level of Direct3D support by the hardware.
        /// </p>
        /// </remarks>
        /// <doc-id>hh847982</doc-id>
        /// <unmanaged>BOOL ID2D1DeviceContext::IsDxgiFormatSupported([In] DXGI_FORMAT format)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::IsDxgiFormatSupported</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool IsDxgiFormatSupported(SharpDX.DXGI.Format format)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, unchecked ((System.Int32)format), (*(void ***)this._nativePointer)[68]);
            return __result__;
        }

        /// <summary>
        /// <p>Indicates whether the buffer precision is supported by the underlying Direct3D <strong>device.</strong> </p>
        /// </summary>
        /// <param name = "bufferPrecision">No documentation.</param>
        /// <returns><p>Returns TRUE if the buffer precision is supported.  Returns <see cref = "SharpDX.Result.False"/> if the buffer precision is not supported.</p></returns>
        /// <doc-id>dn441541</doc-id>
        /// <unmanaged>BOOL ID2D1DeviceContext::IsBufferPrecisionSupported([In] D2D1_BUFFER_PRECISION bufferPrecision)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::IsBufferPrecisionSupported</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool IsBufferPrecisionSupported(SharpDX.Direct2D1.BufferPrecision bufferPrecision)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, unchecked ((System.Int32)bufferPrecision), (*(void ***)this._nativePointer)[69]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the bounds of an image without the world transform of the context applied.</p>
        /// </summary>
        /// <param name = "image"><dd>  <p>The image whose bounds will be calculated.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains a reference to the bounds of the image in device independent pixels (DIPs) and in local space.</p> </dd></returns>
        /// <remarks>
        /// <p>The image bounds don't include multiplication by the world transform.  They do reflect the current DPI, unit mode, and interpolation mode of the context.   To get the bounds that include the world transform, use <strong>ID2D1DeviceContext::GetImageWorldBounds</strong>.</p><p>The returned bounds reflect which pixels would be impacted by calling <strong>DrawImage</strong> with a  target offset of (0,0) and an identity world transform matrix. They do not reflect the current clip rectangle set on the device context or the extent of the context's current target image.</p>
        /// </remarks>
        /// <doc-id>hh404515</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::GetImageLocalBounds([In] ID2D1Image* image,[Out] D2D_RECT_F* localBounds)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::GetImageLocalBounds</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawRectangleF GetImageLocalBounds(SharpDX.Direct2D1.Image image)
        {
            System.IntPtr image_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangleF localBounds;
            SharpDX.Result __result__;
            image_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Image>(image);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)image_, &localBounds, (*(void ***)this._nativePointer)[70]);
            __result__.CheckError();
            return localBounds;
        }

        /// <summary>
        /// <p>Gets the bounds of an image with the world transform of the context applied.</p>
        /// </summary>
        /// <param name = "image"><dd>  <p>The image whose bounds will be calculated.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains a reference to the bounds of the image in device independent pixels (DIPs).</p> </dd></returns>
        /// <remarks>
        /// <p>The image bounds reflect the current DPI, unit mode, and world transform of the context.  To get bounds which don't include the world transform, use <strong>ID2D1DeviceContext::GetImageLocalBounds</strong>. </p><p>The returned bounds reflect which pixels would be impacted by calling <strong>DrawImage</strong> with the same image and a target offset of (0,0).  They do not reflect the current clip rectangle set on the device context or the extent of the context?s current target image.
        /// </p>
        /// </remarks>
        /// <doc-id>hh847979</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::GetImageWorldBounds([In] ID2D1Image* image,[Out] D2D_RECT_F* worldBounds)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::GetImageWorldBounds</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawRectangleF GetImageWorldBounds(SharpDX.Direct2D1.Image image)
        {
            System.IntPtr image_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangleF worldBounds;
            SharpDX.Result __result__;
            image_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Image>(image);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)image_, &worldBounds, (*(void ***)this._nativePointer)[71]);
            __result__.CheckError();
            return worldBounds;
        }

        /// <summary>
        /// <p> Gets the world-space bounds in DIPs of the glyph run using the device context DPI. </p>
        /// </summary>
        /// <param name = "baselineOrigin"><dd>  <p>The origin of the baseline for the glyph run.</p> </dd></param>
        /// <param name = "glyphRun"><dd>  <p>The glyph run to render.</p> </dd></param>
        /// <param name = "measuringMode"><dd>  <p>The DirectWrite measuring mode that indicates how glyph metrics are used to measure text when it is formatted.</p> </dd></param>
        /// <returns><dd>  <p>The bounds of the glyph run in DIPs and in world space.</p> </dd></returns>
        /// <remarks>
        /// <p>The image bounds reflect the current DPI, unit mode, and world transform of the context. </p>
        /// </remarks>
        /// <doc-id>hh847978</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::GetGlyphRunWorldBounds([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] DWRITE_MEASURING_MODE measuringMode,[Out] D2D_RECT_F* bounds)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::GetGlyphRunWorldBounds</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawRectangleF GetGlyphRunWorldBounds(SharpDX.Mathematics.Interop.RawVector2 baselineOrigin, SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.Direct2D1.MeasuringMode measuringMode)
        {
            SharpDX.DirectWrite.GlyphRun.__Native glyphRun_ = default (SharpDX.DirectWrite.GlyphRun.__Native);
            SharpDX.Mathematics.Interop.RawRectangleF bounds;
            SharpDX.Result __result__;
            glyphRun.__MarshalTo(ref glyphRun_);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, baselineOrigin, &glyphRun_, unchecked ((System.Int32)measuringMode), &bounds, (*(void ***)this._nativePointer)[72]);
            glyphRun.__MarshalFree(ref glyphRun_);
            __result__.CheckError();
            return bounds;
        }

        /// <summary>
        /// <p>Gets the device associated with a device context.</p>
        /// </summary>
        /// <param name = "device"><dd>  <p>When this method returns, contains the address of a reference to a Direct2D device associated with this device context.</p> </dd></param>
        /// <remarks>
        /// <p>The application can retrieve the device even if it is created from an earlier render target code-path. The application must use an <strong><see cref = "SharpDX.Direct2D1.DeviceContext"/></strong> interface and then call <strong>GetDevice</strong>. Some functionality for controlling all of the resources for a set of device contexts is maintained only on an <strong><see cref = "SharpDX.Direct2D1.Device"/></strong> object.</p>
        /// </remarks>
        /// <doc-id>hh404513</doc-id>
        /// <unmanaged>void ID2D1DeviceContext::GetDevice([Out] ID2D1Device** device)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::GetDevice</unmanaged-short>
        internal unsafe void GetDevice(out SharpDX.Direct2D1.Device device)
        {
            System.IntPtr device_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &device_, (*(void ***)this._nativePointer)[73]);
            if (device_ != System.IntPtr.Zero)
                device = new SharpDX.Direct2D1.Device(device_);
            else
                device = null;
        }

        /// <summary>
        /// <p>The bitmap or command list to which the Direct2D device context will now render.</p>
        /// </summary>
        /// <param name = "image">No documentation.</param>
        /// <remarks>
        /// <p>The target can be changed at any time, including while the context is drawing.</p><p>The target can be either a bitmap created with the <strong>D2D1_BITMAP_OPTIONS_TARGET</strong> flag, or it can be a command list. Other kinds of images cannot be set as a target. For example, you cannot set the output of an effect as target. If the target is not valid the context will enter the <strong><see cref = "InvalidTarget"/> </strong>error state.</p><p>You cannot  use <strong>SetTarget</strong> to render to a bitmap/command list from multiple device contexts simultaneously. An image is considered ?being rendered to? if it has ever been set on a device context within a <strong>BeginDraw</strong>/<strong>EndDraw</strong> timespan. If an attempt is made to render to an image through multiple device contexts, all subsequent device contexts after the first will enter an error state. </p><p>Callers wishing to attach an image to a second device context should first call <strong>EndDraw</strong> on the first device context.
        /// </p><p>Here is an example of the correct calling order.</p><pre>pDC1-&gt;BeginDraw();
        /// pDC1-&gt;SetTarget(pImage);
        /// // ?
        /// pDC1-&gt;EndDraw(); pDC2-&gt;BeginDraw();
        /// pDC2-&gt;SetTarget(pImage);
        /// // ?
        /// pDC2-&gt;EndDraw();
        /// </pre><p>Here is an example of the incorrect calling order.</p><pre>pDC1-&gt;BeginDraw();
        /// pDC2-&gt;BeginDraw(); pDC1-&gt;SetTarget(pImage); // ... pDC1-&gt;SetTarget(<c>null</c>); pDC2-&gt;SetTarget(pImage); // This call is invalid, even though pImage is no longer set on pDC1. // ... pDC1-&gt;EndDraw(); // This EndDraw SUCCEEDs.
        /// pDC2-&gt;EndDraw(); // This EndDraw FAILs </pre><strong>Note</strong>??Changing the target does not change the bitmap that an <see cref = "System.IntPtr"/> render target presents from, nor does it change the bitmap that a DC render target blts to/from.?<p>This API makes it easy for an application to use a bitmap as a source (like in <strong>DrawBitmap</strong>) and as a destination at the same time.  Attempting to use a bitmap as a source on the same device context to which it is bound as a target will put the device context into the <see cref = "BitmapBoundAsTarget"/> error state.</p><p>It is acceptable to have a bitmap bound as a target bitmap on multiple render targets at once.  Applications that do this must properly synchronize rendering with <strong>Flush</strong> or <strong>EndDraw</strong>.</p><p>You can change the target at any time, including while the context is drawing.</p><p>You can set the target to <c>null</c>, in which case drawing calls will put the device context into an error state with <see cref = "WrongState"/>.  Calling <strong>SetTarget</strong> with a <c>null</c> target does not restore the original target bitmap to the device context.</p><p>If the device context has an outstanding <see cref = "System.IntPtr"/>, the context will enter the <strong><see cref = "WrongState"/></strong> error state.  The target will not be changed.</p><p>If the bitmap and the device context are not in the same resource domain, the context will enter <strong>\</strong> error state.  The target will not be changed.</p><p> <strong>ID2D1RenderTarget::GetPixelSize</strong> returns the size of the current target bitmap (or 0, 0) if there is no bitmap bound).
        /// <strong>ID2D1RenderTarget::GetSize</strong> returns the pixel size of the current bitmap scaled by the DPI of the render target.
        /// <strong>SetTarget</strong> does not affect the DPI of the render target.
        /// </p><p> <strong>ID2D1RenderTarget::GetPixelFormat</strong> returns the pixel format of the current target bitmap (or <strong>DXGI_FORMAT_UNKNOWN</strong>, <strong>D2D1_ALPHA_MODE_UNKNOWN</strong> if there is none).</p><p> <strong>ID2D1Bitmap::CopyFromRenderTarget</strong> copies from the currently bound target bitmap.</p>
        /// </remarks>
        /// <doc-id>hh404533</doc-id>
        /// <unmanaged>void ID2D1DeviceContext::SetTarget([In, Optional] ID2D1Image* image)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::SetTarget</unmanaged-short>
        internal unsafe void SetTarget(SharpDX.Direct2D1.Image image)
        {
            System.IntPtr image_ = System.IntPtr.Zero;
            image_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Image>(image);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)image_, (*(void ***)this._nativePointer)[74]);
        }

        /// <summary>
        /// <p>Gets the target currently associated with the device context.</p>
        /// </summary>
        /// <param name = "image"><dd>  <p>When this method returns, contains the address of a reference to the target currently associated with the device context.</p> </dd></param>
        /// <remarks>
        /// <p>If a target is not associated with the device context, <em>target</em> will contain <strong><c>null</c></strong> when the methods returns.</p><p>If the currently selected target is a bitmap rather than a command list, the application can gain access to the initial bitmaps created by using one of the following methods:</p><ul> <li> <strong>CreateHwndRenderTarget</strong> </li> <li> <strong>CreateDxgiSurfaceRenderTarget</strong> </li> <li> <strong>CreateWicBitmapRenderTarget</strong> </li> <li> <strong>CreateDCRenderTarget</strong> </li> <li> <strong>CreateCompatibleRenderTarget</strong> </li> </ul><p>It is not possible for an application to destroy these bitmaps.  All of these bitmaps are bindable as bitmap targets.  However not all of these bitmaps can be used as bitmap sources for  <strong><see cref = "SharpDX.Direct2D1.RenderTarget"/></strong> methods.</p><p> <strong>CreateDxgiSurfaceRenderTarget</strong> will create a bitmap that is usable as a bitmap source if the DXGI surface is bindable as a shader resource view.</p><p> <strong>CreateCompatibleRenderTarget</strong> will always create bitmaps that are usable as a bitmap source.</p><p> <strong>ID2D1RenderTarget::BeginDraw</strong> will copy from the <see cref = "System.IntPtr"/> to the original bitmap associated with it.  <strong>ID2D1RenderTarget::EndDraw</strong> will copy from the original bitmap to the <see cref = "System.IntPtr"/>.  </p><p> <strong><see cref = "SharpDX.WIC.Bitmap"/></strong> objects will be locked in the following circumstances:</p><ul> <li>BeginDraw has been called and the currently selected target bitmap is a WIC bitmap.</li> <li>A WIC bitmap is set as the target of a device context after BeginDraw has been called and before EndDraw has been called.</li> <li>Any of the ID2D1Bitmap::Copy* methods are called with a WIC bitmap as either the source or destination.</li> </ul><p><see cref = "SharpDX.WIC.Bitmap"/> objects will be unlocked in the following circumstances:</p><ul> <li>EndDraw is called and the currently selected target bitmap is a WIC bitmap.</li> <li>A WIC bitmap is removed as the target of a device context between the calls to BeginDraw and EndDraw.</li> <li>Any of the ID2D1Bitmap::Copy* methods are called with a WIC bitmap as either the source or destination.</li> </ul><p>Direct2D will only lock bitmaps that are not currently locked.</p><p>Calling <strong>QueryInterface</strong> for <strong><see cref = "SharpDX.Direct2D1.GdiInteropRenderTarget"/></strong> will always succeed.  <strong>ID2D1GdiInteropRenderTarget::GetDC</strong> will return a device context corresponding to the currently bound target bitmap.  GetDC will fail if the target bitmap was not created with the GDI_COMPATIBLE flag set.</p><p> <strong>ID2D1HwndRenderTarget::Resize</strong> will return <strong><see cref = "InvalidCall"/></strong> if there are any outstanding references to the original target bitmap associated with the render target.</p><p>Although the target can be a command list, it cannot be any other type of image. It cannot be the output image of an effect.</p>
        /// </remarks>
        /// <doc-id>hh404523</doc-id>
        /// <unmanaged>void ID2D1DeviceContext::GetTarget([Out, Optional] ID2D1Image** image)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::GetTarget</unmanaged-short>
        internal unsafe void GetTarget(out SharpDX.Direct2D1.Image image)
        {
            System.IntPtr image_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &image_, (*(void ***)this._nativePointer)[75]);
            if (image_ != System.IntPtr.Zero)
                image = new SharpDX.Direct2D1.Image(image_);
            else
                image = null;
        }

        /// <summary>
        /// <p>Sets the rendering controls for the given device context. </p>
        /// </summary>
        /// <param name = "renderingControls"><dd>  <p>The rendering controls to be applied.</p> </dd></param>
        /// <remarks>
        /// <p> The rendering controls allow the  application to tune the precision, performance, and resource usage of rendering operations.</p>
        /// </remarks>
        /// <doc-id>hh404530</doc-id>
        /// <unmanaged>void ID2D1DeviceContext::SetRenderingControls([In] const D2D1_RENDERING_CONTROLS* renderingControls)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::SetRenderingControls</unmanaged-short>
        internal unsafe void SetRenderingControls(SharpDX.Direct2D1.RenderingControls renderingControls)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &renderingControls, (*(void ***)this._nativePointer)[76]);
        }

        /// <summary>
        /// <p>Gets the rendering controls that have been applied to the context.</p>
        /// </summary>
        /// <param name = "renderingControls"><dd>  <p>When this method returns, contains a reference to the rendering controls for this context.</p> </dd></param>
        /// <doc-id>hh404519</doc-id>
        /// <unmanaged>void ID2D1DeviceContext::GetRenderingControls([Out] D2D1_RENDERING_CONTROLS* renderingControls)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::GetRenderingControls</unmanaged-short>
        internal unsafe void GetRenderingControls(out SharpDX.Direct2D1.RenderingControls renderingControls)
        {
            renderingControls = default (SharpDX.Direct2D1.RenderingControls);
            fixed (void *renderingControls_ = &renderingControls)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, renderingControls_, (*(void ***)this._nativePointer)[77]);
        }

        /// <summary>
        /// <p>Changes the primitive blend mode that is used for all rendering operations in the device context.</p>
        /// </summary>
        /// <param name = "primitiveBlend"><dd>  <p>The primitive blend to use.</p> </dd></param>
        /// <remarks>
        /// <p>The primitive blend will apply to all of the primitive drawn on the context, unless this is overridden with the <em>compositeMode</em> parameter on the <strong>DrawImage</strong> API.</p><p> The primitive blend applies to the interior of any primitives drawn on the context. In the case of <strong>DrawImage</strong>, this will be implied by the image rectangle, offset and world transform.</p><p>If the primitive blend is anything other than <strong>D2D1_PRIMITIVE_BLEND_SOURCE_OVER</strong> then ClearType rendering will be turned off. If the application explicitly forces ClearType rendering in these modes, the drawing context will be placed in an error state. <see cref = "WrongState"/> will be returned from either <strong>EndDraw</strong> or <strong>Flush</strong>.
        /// </p>
        /// </remarks>
        /// <doc-id>hh404527</doc-id>
        /// <unmanaged>void ID2D1DeviceContext::SetPrimitiveBlend([In] D2D1_PRIMITIVE_BLEND primitiveBlend)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::SetPrimitiveBlend</unmanaged-short>
        internal unsafe void SetPrimitiveBlend(SharpDX.Direct2D1.PrimitiveBlend primitiveBlend)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)primitiveBlend), (*(void ***)this._nativePointer)[78]);
        }

        /// <summary>
        /// <p>Returns the currently set primitive blend used by the device context.  </p>
        /// </summary>
        /// <returns><p>The current primitive blend. The default value is <strong>D2D1_PRIMITIVE_BLEND_SOURCE_OVER</strong>.</p></returns>
        /// <doc-id>hh404517</doc-id>
        /// <unmanaged>D2D1_PRIMITIVE_BLEND ID2D1DeviceContext::GetPrimitiveBlend()</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::GetPrimitiveBlend</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.PrimitiveBlend GetPrimitiveBlend()
        {
            SharpDX.Direct2D1.PrimitiveBlend __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1PrimitiveBlend(this._nativePointer, (*(void ***)this._nativePointer)[79]);
            return __result__;
        }

        /// <summary>
        /// <p>Sets what units will be used to interpret values passed into the device context.</p><p></p>
        /// </summary>
        /// <param name = "unitMode"><dd>  <p>An enumeration defining how passed-in units will be interpreted by the device context.</p> </dd></param>
        /// <remarks>
        /// <p> This method will affect all properties and parameters affected by <strong>SetDpi</strong> and <strong>GetDpi</strong>. This affects all coordinates, lengths, and other properties that are  not explicitly defined as being in another unit. For example:</p><ul> <li><strong>SetUnitMode</strong> will affect a coordinate passed  into <strong>ID2D1DeviceContext::DrawLine</strong>, and the scaling of a  geometry passed into <strong>ID2D1DeviceContext::FillGeometry</strong>. </li> <li><strong>SetUnitMode</strong> will not affect the value returned by <strong>ID2D1Bitmap::GetPixelSize</strong>. </li> </ul>
        /// </remarks>
        /// <doc-id>hh404539</doc-id>
        /// <unmanaged>void ID2D1DeviceContext::SetUnitMode([In] D2D1_UNIT_MODE unitMode)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::SetUnitMode</unmanaged-short>
        internal unsafe void SetUnitMode(SharpDX.Direct2D1.UnitMode unitMode)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)unitMode), (*(void ***)this._nativePointer)[80]);
        }

        /// <summary>
        /// <p>Gets the mode that  is being used to interpret values by the device context.</p>
        /// </summary>
        /// <returns><p>The  unit mode.</p></returns>
        /// <doc-id>hh404525</doc-id>
        /// <unmanaged>D2D1_UNIT_MODE ID2D1DeviceContext::GetUnitMode()</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::GetUnitMode</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.UnitMode GetUnitMode()
        {
            SharpDX.Direct2D1.UnitMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1UnitMode(this._nativePointer, (*(void ***)this._nativePointer)[81]);
            return __result__;
        }

        /// <summary>
        /// <p>Draws a series of glyphs to the device context.</p>
        /// </summary>
        /// <param name = "baselineOrigin"><dd>  <p>Origin of first glyph in the series.</p> </dd></param>
        /// <param name = "glyphRun"><dd>  <p>The glyphs to render.</p> </dd></param>
        /// <param name = "glyphRunDescription"><dd>  <p>Supplementary glyph series information.</p> </dd></param>
        /// <param name = "foregroundBrush"><dd>  <p>The brush that defines the text color.</p> </dd></param>
        /// <param name = "measuringMode"><dd>  <p>The measuring mode of the glyph series, used to determine the advances and offsets. The default value is DWRITE_MEASURING_MODE_NATURAL.</p> </dd></param>
        /// <remarks>
        /// <p>The <em>glyphRunDescription</em> is ignored when rendering, but can be useful for printing and serialization of rendering commands, such as to an XPS or SVG file. This extends <strong>ID2D1RenderTarget::DrawGlyphRun</strong>, which lacked the glyph run description.</p>
        /// </remarks>
        /// <doc-id>hh404508</doc-id>
        /// <unmanaged>void ID2D1DeviceContext::DrawGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] const DWRITE_GLYPH_RUN_DESCRIPTION* glyphRunDescription,[In] ID2D1Brush* foregroundBrush,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::DrawGlyphRun</unmanaged-short>
        public unsafe void DrawGlyphRun(SharpDX.Mathematics.Interop.RawVector2 baselineOrigin, SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.DirectWrite.GlyphRunDescription glyphRunDescription, SharpDX.Direct2D1.Brush foregroundBrush, SharpDX.Direct2D1.MeasuringMode measuringMode)
        {
            SharpDX.DirectWrite.GlyphRun.__Native glyphRun_ = default (SharpDX.DirectWrite.GlyphRun.__Native);
            SharpDX.DirectWrite.GlyphRunDescription.__Native glyphRunDescription_ = default (SharpDX.DirectWrite.GlyphRunDescription.__Native);
            System.IntPtr foregroundBrush_ = System.IntPtr.Zero;
            glyphRun.__MarshalTo(ref glyphRun_);
            if (glyphRunDescription != null)
                glyphRunDescription.__MarshalTo(ref glyphRunDescription_);
            foregroundBrush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(foregroundBrush);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, baselineOrigin, &glyphRun_, glyphRunDescription == null ? (void *)0 : &glyphRunDescription_, (void *)foregroundBrush_, unchecked ((System.Int32)measuringMode), (*(void ***)this._nativePointer)[82]);
            glyphRun.__MarshalFree(ref glyphRun_);
            if (glyphRunDescription != null)
                glyphRunDescription.__MarshalFree(ref glyphRunDescription_);
        }

        /// <summary>
        /// <p></p><p>A command list cannot reference effects which are part of effect graphs that consume the command list.</p>
        /// </summary>
        /// <param name = "image">No documentation.</param>
        /// <param name = "targetOffset">No documentation.</param>
        /// <param name = "imageRectangle">No documentation.</param>
        /// <param name = "interpolationMode">No documentation.</param>
        /// <param name = "compositeMode">No documentation.</param>
        /// <doc-id>jj835880</doc-id>
        /// <unmanaged>void ID2D1DeviceContext::DrawImage([In] ID2D1Image* image,[In, Optional] const D2D_POINT_2F* targetOffset,[In, Optional] const D2D_RECT_F* imageRectangle,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In] D2D1_COMPOSITE_MODE compositeMode)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::DrawImage</unmanaged-short>
        public unsafe void DrawImage(SharpDX.Direct2D1.Image image, SharpDX.Mathematics.Interop.RawVector2? targetOffset, SharpDX.Mathematics.Interop.RawRectangleF? imageRectangle, SharpDX.Direct2D1.InterpolationMode interpolationMode, SharpDX.Direct2D1.CompositeMode compositeMode)
        {
            System.IntPtr image_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawVector2 targetOffset_;
            SharpDX.Mathematics.Interop.RawRectangleF imageRectangle_;
            image_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Image>(image);
            if (targetOffset != null)
                targetOffset_ = targetOffset.Value;
            if (imageRectangle != null)
                imageRectangle_ = imageRectangle.Value;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)image_, targetOffset == null ? (void *)0 : &targetOffset_, imageRectangle == null ? (void *)0 : &imageRectangle_, unchecked ((System.Int32)interpolationMode), unchecked ((System.Int32)compositeMode), (*(void ***)this._nativePointer)[83]);
        }

        /// <summary>
        /// <p>Draw a metafile to the device context.</p>
        /// </summary>
        /// <param name = "gdiMetafile"><dd>  <p>The metafile to draw.</p> </dd></param>
        /// <param name = "targetOffset"><dd>  <p>The offset from the upper left corner of the render target.</p> </dd></param>
        /// <doc-id>jj841147</doc-id>
        /// <unmanaged>void ID2D1DeviceContext::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_POINT_2F* targetOffset)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::DrawGdiMetafile</unmanaged-short>
        public unsafe void DrawGdiMetafile(SharpDX.Direct2D1.GdiMetafile gdiMetafile, SharpDX.Mathematics.Interop.RawVector2? targetOffset)
        {
            System.IntPtr gdiMetafile_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawVector2 targetOffset_;
            gdiMetafile_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.GdiMetafile>(gdiMetafile);
            if (targetOffset != null)
                targetOffset_ = targetOffset.Value;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)gdiMetafile_, targetOffset == null ? (void *)0 : &targetOffset_, (*(void ***)this._nativePointer)[84]);
        }

        /// <summary>
        /// <p>Draws a bitmap to the render target.</p>
        /// </summary>
        /// <param name = "bitmap"><dd>  <p>The bitmap to draw.</p> </dd></param>
        /// <param name = "destinationRectangle"><dd>  <p>The destination rectangle. The default is the size of the bitmap and the location is the upper left corner of the render target.</p> </dd></param>
        /// <param name = "opacity"><dd>  <p>The opacity of the bitmap.</p> </dd></param>
        /// <param name = "interpolationMode"><dd>  <p>The interpolation mode to use.</p> </dd></param>
        /// <param name = "sourceRectangle"><dd>  <p>An optional source rectangle.</p> </dd></param>
        /// <param name = "erspectiveTransformRef"><dd>  <p>An optional perspective transform.</p> </dd></param>
        /// <remarks>
        /// <p>The destinationRectangle parameter defines the rectangle in the target where the bitmap will appear (in device-independent pixels (DIPs)).  This is affected by the currently set transform and the perspective transform, if set.  If <c>null</c> is specified, then the destination rectangle is (left=0, top=0, right = width(sourceRectangle), bottom = height(sourceRectangle)). </p><p>The <em>sourceRectangle</em> parameter defines the sub-rectangle of the source bitmap (in DIPs).  <strong>DrawBitmap</strong> will clip this rectangle to the size of the source bitmap, thus making it impossible to sample outside of the bitmap.  If <c>null</c> is specified, then the source rectangle is taken to be the size of the source bitmap. </p><p>If you specify <em>perspectiveTransform</em> it is applied to the rect in addition to the transform set on the render target.</p>
        /// </remarks>
        /// <doc-id>jj841144</doc-id>
        /// <unmanaged>void ID2D1DeviceContext::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_F* destinationRectangle,[In] float opacity,[In] D2D1_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D_RECT_F* sourceRectangle,[In, Optional] const D2D_MATRIX_4X4_F* perspectiveTransform)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::DrawBitmap</unmanaged-short>
        public unsafe void DrawBitmap(SharpDX.Direct2D1.Bitmap bitmap, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, System.Single opacity, SharpDX.Direct2D1.InterpolationMode interpolationMode, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle, SharpDX.Mathematics.Interop.RawMatrix? erspectiveTransformRef)
        {
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangleF destinationRectangle_;
            SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle_;
            SharpDX.Mathematics.Interop.RawMatrix erspectiveTransformRef_;
            bitmap_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Bitmap>(bitmap);
            if (destinationRectangle != null)
                destinationRectangle_ = destinationRectangle.Value;
            if (sourceRectangle != null)
                sourceRectangle_ = sourceRectangle.Value;
            if (erspectiveTransformRef != null)
                erspectiveTransformRef_ = erspectiveTransformRef.Value;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)bitmap_, destinationRectangle == null ? (void *)0 : &destinationRectangle_, opacity, unchecked ((System.Int32)interpolationMode), sourceRectangle == null ? (void *)0 : &sourceRectangle_, erspectiveTransformRef == null ? (void *)0 : &erspectiveTransformRef_, (*(void ***)this._nativePointer)[85]);
        }

        /// <summary>
        /// <p>Push a layer onto the clip and layer stack of the device context.</p>
        /// </summary>
        /// <param name = "layerParameters"><dd>  <p>The parameters that defines the layer.</p> </dd></param>
        /// <param name = "layer"><dd>  <p>The layer resource to push on the device context that receives subsequent drawing operations. </p> <strong>Note</strong>??If a layer is not specified, Direct2D manages the layer resource automatically. ? </dd></param>
        /// <doc-id>hh847983</doc-id>
        /// <unmanaged>void ID2D1DeviceContext::PushLayer([In] const D2D1_LAYER_PARAMETERS1* layerParameters,[In, Optional] ID2D1Layer* layer)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::PushLayer</unmanaged-short>
        public unsafe void PushLayer(ref SharpDX.Direct2D1.LayerParameters1 layerParameters, SharpDX.Direct2D1.Layer layer)
        {
            SharpDX.Direct2D1.LayerParameters1.__Native layerParameters_ = default (SharpDX.Direct2D1.LayerParameters1.__Native);
            System.IntPtr layer_ = System.IntPtr.Zero;
            layerParameters.__MarshalTo(ref layerParameters_);
            layer_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Layer>(layer);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &layerParameters_, (void *)layer_, (*(void ***)this._nativePointer)[86]);
            layerParameters.__MarshalFree(ref layerParameters_);
        }

        /// <summary>
        /// <p>This indicates that a portion of an effect's input is invalid. This method can be called many times.</p><p>You can use this method to propagate invalid rectangles through an effect graph. You can query Direct2D using the <strong>GetEffectInvalidRectangles</strong> method.</p><strong>Note</strong>??Direct2D does not automatically use these invalid rectangles to reduce the region of an effect that is rendered.?<p>You can also use this method to invalidate caches that have accumulated while rendering effects that have the <strong>D2D1_PROPERTY_CACHED</strong> property set to true.</p>
        /// </summary>
        /// <param name = "effect">No documentation.</param>
        /// <param name = "input">No documentation.</param>
        /// <param name = "inputRectangle">No documentation.</param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh847980</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::InvalidateEffectInputRectangle([In] ID2D1Effect* effect,[In] unsigned int input,[In] const D2D_RECT_F* inputRectangle)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::InvalidateEffectInputRectangle</unmanaged-short>
        public unsafe void InvalidateEffectInputRectangle(SharpDX.Direct2D1.Effect effect, System.Int32 input, SharpDX.Mathematics.Interop.RawRectangleF inputRectangle)
        {
            System.IntPtr effect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            effect_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Effect>(effect);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)effect_, input, &inputRectangle, (*(void ***)this._nativePointer)[87]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the number of invalid output rectangles that have accumulated on the effect. </p>
        /// </summary>
        /// <param name = "effect"><dd>  <p>The effect to count the invalid rectangles on.</p> </dd></param>
        /// <returns><dd>  <p>The returned rectangle count.</p> </dd></returns>
        /// <doc-id>hh847975</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::GetEffectInvalidRectangleCount([In] ID2D1Effect* effect,[Out] unsigned int* rectangleCount)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::GetEffectInvalidRectangleCount</unmanaged-short>
        internal unsafe System.Int32 GetEffectInvalidRectangleCount(SharpDX.Direct2D1.Effect effect)
        {
            System.IntPtr effect_ = System.IntPtr.Zero;
            System.Int32 rectangleCount;
            SharpDX.Result __result__;
            effect_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Effect>(effect);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)effect_, &rectangleCount, (*(void ***)this._nativePointer)[88]);
            __result__.CheckError();
            return rectangleCount;
        }

        /// <summary>
        /// <p>Gets the invalid rectangles that have accumulated since the last time the effect was drawn and <strong>EndDraw</strong> was then called on the device context.</p>
        /// </summary>
        /// <param name = "effect">No documentation.</param>
        /// <param name = "rectangles">No documentation.</param>
        /// <param name = "rectanglesCount">No documentation.</param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p> </p><strong>Note</strong>??Direct2D does not automatically use these invalid rectangles to reduce the region of an effect that is rendered.?<p>You can use the <strong>InvalidateEffectInputRectangle</strong> method to specify invalidated rectangles for Direct2D to propagate through an effect graph.</p><p>If multiple invalid rectangles are requested, the rectangles that this method returns may overlap. When this is the case, the rectangle count might be lower than the count that <strong>GetEffectInvalidRectangleCount</strong>.</p>
        /// </remarks>
        /// <doc-id>hh847976</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::GetEffectInvalidRectangles([In] ID2D1Effect* effect,[Out, Buffer] D2D_RECT_F* rectangles,[In] unsigned int rectanglesCount)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::GetEffectInvalidRectangles</unmanaged-short>
        internal unsafe void GetEffectInvalidRectangles(SharpDX.Direct2D1.Effect effect, SharpDX.Mathematics.Interop.RawRectangleF[] rectangles, System.Int32 rectanglesCount)
        {
            System.IntPtr effect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            effect_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Effect>(effect);
            fixed (void *rectangles_ = rectangles)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)effect_, rectangles_, rectanglesCount, (*(void ***)this._nativePointer)[89]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Returns the input rectangles that are required to be supplied by the caller to produce the given output rectangle.  </p>
        /// </summary>
        /// <param name = "renderEffect"><dd>  <p>The image whose output is being rendered.</p> </dd></param>
        /// <param name = "renderImageRectangle"><dd>  <p>The portion of the output image whose inputs are being inspected.</p> </dd></param>
        /// <param name = "inputDescriptions"><dd>  <p> A list of the inputs whos rectangles are being queried. </p> </dd></param>
        /// <param name = "requiredInputRects"><dd>  <p>The input rectangles returned to the caller.</p> </dd></param>
        /// <param name = "inputCount"><dd>  <p>The number of inputs.</p> </dd></param>
        /// <returns><p> A failure code, this will typically only be because an effect in the chain returned some error. </p></returns>
        /// <remarks>
        /// <p>The caller should be very careful not to place a reliance on the required input rectangles returned.  Small changes for correctness to an effect's behavior can result in different rectangles being returned.  In addition, different kinds of optimization applied inside the render can also influence the result. </p>
        /// </remarks>
        /// <doc-id>hh847977</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext::GetEffectRequiredInputRectangles([In] ID2D1Effect* renderEffect,[In, Optional] const D2D_RECT_F* renderImageRectangle,[In, Buffer] const D2D1_EFFECT_INPUT_DESCRIPTION* inputDescriptions,[Out, Buffer] D2D_RECT_F* requiredInputRects,[In] unsigned int inputCount)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::GetEffectRequiredInputRectangles</unmanaged-short>
        internal unsafe void GetEffectRequiredInputRectangles(SharpDX.Direct2D1.Effect renderEffect, SharpDX.Mathematics.Interop.RawRectangleF? renderImageRectangle, SharpDX.Direct2D1.EffectInputDescription[] inputDescriptions, SharpDX.Mathematics.Interop.RawRectangleF[] requiredInputRects, System.Int32 inputCount)
        {
            System.IntPtr renderEffect_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangleF renderImageRectangle_;
            SharpDX.Direct2D1.EffectInputDescription.__Native[] inputDescriptions_ = new SharpDX.Direct2D1.EffectInputDescription.__Native[inputDescriptions.Length];
            SharpDX.Result __result__;
            renderEffect_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Effect>(renderEffect);
            if (renderImageRectangle != null)
                renderImageRectangle_ = renderImageRectangle.Value;
            for (int i = 0; i < inputDescriptions.Length; ++i)
                inputDescriptions[i].__MarshalTo(ref (inputDescriptions_)[i]);
            fixed (void *requiredInputRects_ = requiredInputRects)
                fixed (void *_inputDescriptions = inputDescriptions_)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)renderEffect_, renderImageRectangle == null ? (void *)0 : &renderImageRectangle_, _inputDescriptions, requiredInputRects_, inputCount, (*(void ***)this._nativePointer)[90]);
            for (int i = 0; i < inputDescriptions.Length; ++i)
                inputDescriptions[i].__MarshalFree(ref (inputDescriptions_)[i]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Fill using the alpha channel of the supplied opacity mask bitmap. The brush opacity will be modulated by the mask. The render target antialiasing mode must be set to aliased.</p>
        /// </summary>
        /// <param name = "opacityMask"><dd>  <p>The bitmap that acts as the opacity mask</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush to use for filling the primitive.</p> </dd></param>
        /// <param name = "destinationRectangle"><dd>  <p>The destination rectangle to output to in the render target</p> </dd></param>
        /// <param name = "sourceRectangle"><dd>  <p>The source rectangle from the opacity mask bitmap.</p> </dd></param>
        /// <doc-id>hh847974</doc-id>
        /// <unmanaged>void ID2D1DeviceContext::FillOpacityMask([In] ID2D1Bitmap* opacityMask,[In] ID2D1Brush* brush,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext::FillOpacityMask</unmanaged-short>
        public unsafe void FillOpacityMask(SharpDX.Direct2D1.Bitmap opacityMask, SharpDX.Direct2D1.Brush brush, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle)
        {
            System.IntPtr opacityMask_ = System.IntPtr.Zero;
            System.IntPtr brush_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangleF destinationRectangle_;
            SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle_;
            opacityMask_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Bitmap>(opacityMask);
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            if (destinationRectangle != null)
                destinationRectangle_ = destinationRectangle.Value;
            if (sourceRectangle != null)
                sourceRectangle_ = sourceRectangle.Value;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)opacityMask_, (void *)brush_, destinationRectangle == null ? (void *)0 : &destinationRectangle_, sourceRectangle == null ? (void *)0 : &sourceRectangle_, (*(void ***)this._nativePointer)[91]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("d37f57e4-6908-459f-a199-e72f24f79987")]
    public partial class DeviceContext1 : SharpDX.Direct2D1.DeviceContext
    {
        public DeviceContext1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceContext1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceContext1(nativePtr);
        /// <summary>
        /// <p>Creates a device-dependent representation of the fill of the geometry that can be subsequently rendered.</p>
        /// </summary>
        /// <param name = "geometry"><dd>  <p>The geometry to realize.</p> </dd></param>
        /// <param name = "flatteningTolerance"><dd>  <p>The flattening tolerance to use when converting Beziers to line segments. This parameter shares the same units as the coordinates of the geometry.</p> </dd></param>
        /// <param name = "geometryRealization"><dd>  <p>When this method returns, contains the address of a reference to a new geometry realization object.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>This method is used in conjunction with <strong>ID2D1DeviceContext1::DrawGeometryRealization</strong>. The <strong>D2D1::ComputeFlatteningTolerance</strong> helper API may be used to determine the proper flattening tolerance.</p><p>If the provided stroke style specifies a stroke transform type other than <strong>D2D1_STROKE_TRANSFORM_TYPE_NORMAL</strong>, then the stroke will be realized assuming the identity transform and a DPI of 96.</p>
        /// </remarks>
        /// <doc-id>dn280462</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext1::CreateFilledGeometryRealization([In] ID2D1Geometry* geometry,[In] float flatteningTolerance,[Out, Fast] ID2D1GeometryRealization** geometryRealization)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext1::CreateFilledGeometryRealization</unmanaged-short>
        internal unsafe void CreateFilledGeometryRealization(SharpDX.Direct2D1.Geometry geometry, System.Single flatteningTolerance, SharpDX.Direct2D1.GeometryRealization geometryRealization)
        {
            System.IntPtr geometry_ = System.IntPtr.Zero;
            System.IntPtr geometryRealization_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            geometry_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Geometry>(geometry);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)geometry_, flatteningTolerance, &geometryRealization_, (*(void ***)this._nativePointer)[92]);
            (geometryRealization).NativePointer = geometryRealization_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a device-dependent representation of the stroke of a geometry that can be subsequently rendered.</p>
        /// </summary>
        /// <param name = "geometry"><dd>  <p>The geometry to realize.</p> </dd></param>
        /// <param name = "flatteningTolerance"><dd>  <p>The flattening tolerance to use when converting Beziers to line segments. This parameter shares the same units as the coordinates of the geometry.</p> </dd></param>
        /// <param name = "strokeWidth"><dd>  <p>The width of the stroke. This parameter shares the same units as the coordinates of the geometry.</p> </dd></param>
        /// <param name = "strokeStyle"><dd>  <p>The stroke style (optional).</p> </dd></param>
        /// <param name = "geometryRealization"><dd>  <p>When this method returns, contains the address of a reference to a new geometry realization object.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>This method is used in conjunction with <strong>ID2D1DeviceContext1::DrawGeometryRealization</strong>. The <strong>D2D1::ComputeFlatteningTolerance</strong> helper API may be used to determine the proper flattening tolerance.</p><p>If the provided stroke style specifies a stroke transform type other than <strong>D2D1_STROKE_TRANSFORM_TYPE_NORMAL</strong>, then the stroke will be realized assuming the identity transform and a DPI of 96.</p>
        /// </remarks>
        /// <doc-id>dn280463</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext1::CreateStrokedGeometryRealization([In] ID2D1Geometry* geometry,[In] float flatteningTolerance,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[Out, Fast] ID2D1GeometryRealization** geometryRealization)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext1::CreateStrokedGeometryRealization</unmanaged-short>
        internal unsafe void CreateStrokedGeometryRealization(SharpDX.Direct2D1.Geometry geometry, System.Single flatteningTolerance, System.Single strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle, SharpDX.Direct2D1.GeometryRealization geometryRealization)
        {
            System.IntPtr geometry_ = System.IntPtr.Zero;
            System.IntPtr strokeStyle_ = System.IntPtr.Zero;
            System.IntPtr geometryRealization_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            geometry_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Geometry>(geometry);
            strokeStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.StrokeStyle>(strokeStyle);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)geometry_, flatteningTolerance, strokeWidth, (void *)strokeStyle_, &geometryRealization_, (*(void ***)this._nativePointer)[93]);
            (geometryRealization).NativePointer = geometryRealization_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Renders a given geometry realization to the target with the specified brush.</p>
        /// </summary>
        /// <param name = "geometryRealization"><dd>  <p>The geometry realization to be rendered.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush to render the realization with.</p> </dd></param>
        /// <remarks>
        /// <p> This method respects all currently set state (transform, DPI, unit mode, target image, clips, layers);  however, artifacts such as faceting may appear when rendering the realizations with a large effective scale (either via the transform or the DPI).  Callers should create their realizations with an appropriate flattening tolerance using either <strong>D2D1_DEFAULT_FLATTENING_TOLERANCE</strong> or <strong>ComputeFlatteningTolerance</strong> to compensate for this. </p><p>Additionally, callers should be aware of the safe render bounds when creating geometry realizations.  If a geometry extends outside of [-524,287, 524,287] DIPs in either the X- or the Y- direction in its original (pre-transform) coordinate space,  then it may be clipped to those bounds when it is realized. This clipping will be visible even if the realization is subsequently transformed to fit within the safe render bounds.</p>
        /// </remarks>
        /// <doc-id>dn280464</doc-id>
        /// <unmanaged>void ID2D1DeviceContext1::DrawGeometryRealization([In] ID2D1GeometryRealization* geometryRealization,[In] ID2D1Brush* brush)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext1::DrawGeometryRealization</unmanaged-short>
        public unsafe void DrawGeometryRealization(SharpDX.Direct2D1.GeometryRealization geometryRealization, SharpDX.Direct2D1.Brush brush)
        {
            System.IntPtr geometryRealization_ = System.IntPtr.Zero;
            System.IntPtr brush_ = System.IntPtr.Zero;
            geometryRealization_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.GeometryRealization>(geometryRealization);
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)geometryRealization_, (void *)brush_, (*(void ***)this._nativePointer)[94]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("394ea6a3-0c34-4321-950b-6ca20f0be6c7")]
    public partial class DeviceContext2 : SharpDX.Direct2D1.DeviceContext1
    {
        public DeviceContext2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceContext2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceContext2(nativePtr);
        /// <summary>
        /// <p>Creates a new <strong><see cref = "SharpDX.Direct2D1.Ink"/></strong> object that starts at the given point.</p>
        /// </summary>
        /// <param name = "startPoint">No documentation.</param>
        /// <param name = "ink">No documentation.</param>
        /// <returns><p><see cref = "SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "SharpDX.Result"/>.</p></returns>
        /// <doc-id>dn900368</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateInk([In] const D2D1_INK_POINT* startPoint,[Out, Fast] ID2D1Ink** ink)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext2::CreateInk</unmanaged-short>
        internal unsafe void CreateInk(SharpDX.Direct2D1.InkPoint startPoint, SharpDX.Direct2D1.Ink ink)
        {
            System.IntPtr ink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &startPoint, &ink_, (*(void ***)this._nativePointer)[95]);
            (ink).NativePointer = ink_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new <strong><see cref = "SharpDX.Direct2D1.InkStyle"/></strong> object, for use with ink  rendering methods such as <strong>DrawInk</strong>.</p>
        /// </summary>
        /// <param name = "inkStyleProperties">No documentation.</param>
        /// <param name = "inkStyle">No documentation.</param>
        /// <returns><p><see cref = "SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "SharpDX.Result"/>.</p></returns>
        /// <doc-id>dn900369</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateInkStyle([In, Optional] const D2D1_INK_STYLE_PROPERTIES* inkStyleProperties,[Out, Fast] ID2D1InkStyle** inkStyle)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext2::CreateInkStyle</unmanaged-short>
        internal unsafe void CreateInkStyle(SharpDX.Direct2D1.InkStyleProperties? inkStyleProperties, SharpDX.Direct2D1.InkStyle inkStyle)
        {
            SharpDX.Direct2D1.InkStyleProperties inkStyleProperties_;
            System.IntPtr inkStyle_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (inkStyleProperties != null)
                inkStyleProperties_ = inkStyleProperties.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, inkStyleProperties == null ? (void *)0 : &inkStyleProperties_, &inkStyle_, (*(void ***)this._nativePointer)[96]);
            (inkStyle).NativePointer = inkStyle_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new <strong><see cref = "SharpDX.Direct2D1.GradientMesh"/></strong> instance using the given array of patches.</p>
        /// </summary>
        /// <param name = "atchesRef">No documentation.</param>
        /// <param name = "patchesCount">No documentation.</param>
        /// <param name = "gradientMesh">No documentation.</param>
        /// <returns><p><see cref = "SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "SharpDX.Result"/>.</p></returns>
        /// <doc-id>dn890790</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateGradientMesh([In, Buffer] const D2D1_GRADIENT_MESH_PATCH* patches,[In] unsigned int patchesCount,[Out, Fast] ID2D1GradientMesh** gradientMesh)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext2::CreateGradientMesh</unmanaged-short>
        internal unsafe void CreateGradientMesh(SharpDX.Direct2D1.GradientMeshPatch[] atchesRef, System.Int32 patchesCount, SharpDX.Direct2D1.GradientMesh gradientMesh)
        {
            System.IntPtr gradientMesh_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *atchesRef_ = atchesRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, atchesRef_, patchesCount, &gradientMesh_, (*(void ***)this._nativePointer)[97]);
            (gradientMesh).NativePointer = gradientMesh_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an image source object from a WIC bitmap source, while populating all pixel memory within the image source.   The image is loaded and stored while using a minimal amount of memory.</p>
        /// </summary>
        /// <param name = "wicBitmapSource"><dd>  <p>The WIC bitmap source to create the image source from.</p> </dd></param>
        /// <param name = "loadingOptions"><dd>  <p>Options for creating the image source.  Default options are used if <c>null</c>.</p> </dd></param>
        /// <param name = "alphaMode"><dd>  <p>Receives the new image source instance.</p> </dd></param>
        /// <param name = "imageSource"><dd>  <p>Receives the new image source instance.</p> </dd></param>
        /// <returns><p><see cref = "SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "SharpDX.Result"/>.</p></returns>
        /// <remarks>
        /// <p> This method creates an image source which can be used to draw the image.  </p><p>This method supports images that exceed the maximum texture size.  Large images are internally stored within a sparse tile cache.   </p><p> This API supports the same set of pixel formats and alpha modes supported by <strong>CreateBitmapFromWicBitmap</strong>.   If the GPU does not support a given pixel format, this method will return <see cref = "UnsupportedPixelFormat"/>.  This method does not apply adjustments such as gamma  or alpha premultiplication which affect the appearance of the image. </p><p>This method automatically selects an appropriate storage format to minimize GPU memory usage., such as using separate  luminance and chrominance textures for JPEG images. </p><p>If the loadingOptions argument is <c>null</c>, D2D uses D2D1_IMAGE_SOURCE_LOADING_OPTIONS_NONE.</p>
        /// </remarks>
        /// <doc-id>dn890793</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateImageSourceFromWic([In] IWICBitmapSource* wicBitmapSource,[In] D2D1_IMAGE_SOURCE_LOADING_OPTIONS loadingOptions,[In] D2D1_ALPHA_MODE alphaMode,[Out, Fast] ID2D1ImageSourceFromWic** imageSource)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext2::CreateImageSourceFromWic</unmanaged-short>
        internal unsafe void CreateImageSourceFromWic(SharpDX.WIC.BitmapSource wicBitmapSource, SharpDX.Direct2D1.ImageSourceLoadingOptions loadingOptions, SharpDX.Direct2D1.AlphaMode alphaMode, SharpDX.Direct2D1.ImageSourceFromWic imageSource)
        {
            System.IntPtr wicBitmapSource_ = System.IntPtr.Zero;
            System.IntPtr imageSource_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            wicBitmapSource_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(wicBitmapSource);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)wicBitmapSource_, unchecked ((System.Int32)loadingOptions), unchecked ((System.Int32)alphaMode), &imageSource_, (*(void ***)this._nativePointer)[98]);
            (imageSource).NativePointer = imageSource_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a 3D lookup table for mapping a 3-channel input to a 3-channel output. The table data must be provided in 4-channel format.</p>
        /// </summary>
        /// <param name = "precision"><dd>  <p>Precision of the input lookup table data.</p> </dd></param>
        /// <param name = "extents"><dd>  <p>Number of lookup table elements per dimension (X, Y, Z).</p> </dd></param>
        /// <param name = "data"><dd>  <p>Buffer holding the lookup table data.</p> </dd></param>
        /// <param name = "dataCount"><dd>  <p>Size of the lookup table data buffer.</p> </dd></param>
        /// <param name = "strides"><dd>  <p>An array containing two values.  The first value is the size in bytes from one row (X dimension) of LUT data to the next.   The second value is the size in bytes from one LUT data plane (X and Y dimensions) to the next.</p> </dd></param>
        /// <param name = "lookupTable"><dd>  <p>Receives the new lookup table instance.</p> </dd></param>
        /// <returns><p><see cref = "SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "SharpDX.Result"/>.</p></returns>
        /// <doc-id>dn900373</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateLookupTable3D([In] D2D1_BUFFER_PRECISION precision,[In, Buffer] const unsigned int* extents,[In, Buffer] const unsigned char* data,[In] unsigned int dataCount,[In, Buffer] const unsigned int* strides,[Out, Fast] ID2D1LookupTable3D** lookupTable)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext2::CreateLookupTable3D</unmanaged-short>
        internal unsafe void CreateLookupTable3D(SharpDX.Direct2D1.BufferPrecision precision, System.Int32[] extents, System.Byte[] data, System.Int32 dataCount, System.Int32[] strides, SharpDX.Direct2D1.LookupTable3D lookupTable)
        {
            System.IntPtr lookupTable_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *strides_ = strides)
                fixed (void *data_ = data)
                    fixed (void *extents_ = extents)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)precision), extents_, data_, dataCount, strides_, &lookupTable_, (*(void ***)this._nativePointer)[99]);
            (lookupTable).NativePointer = lookupTable_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an image source from a set of DXGI surface(s).  The YCbCr surface(s) are converted to RGBA automatically during subsequent drawing.</p>
        /// </summary>
        /// <param name = "surfaces"><dd>  <p>The DXGI surfaces to create the image source from.</p> </dd></param>
        /// <param name = "surfaceCount"><dd>  <p>The number of surfaces provided; must be between one and three.</p> </dd></param>
        /// <param name = "colorSpace"><dd>  <p>The color space of the input.</p> </dd></param>
        /// <param name = "options"><dd>  <p>Options controlling color space conversions.</p> </dd></param>
        /// <param name = "imageSource"><dd>  <p>Receives the new image source instance.</p> </dd></param>
        /// <returns><p><see cref = "SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "SharpDX.Result"/>.</p></returns>
        /// <remarks>
        /// <p> This method creates an image source which can be used to draw the image. This method supports surfaces that use a limited set of DXGI formats and DXGI color space types.  Only the below set of combinations of color space types, surface formats, and surface counts are supported: </p><table> <tr><th>Color Space Type</th><th>Surface Count(s)</th><th>Surface Format(s)</th></tr> <tr><td>DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709</td><td>1</td><td> Standard D2D-supported pixel formats: <ul> <li>DXGI_FORMAT_A8_UNORM</li> <li>DXGI_FORMAT_R8_UNORM</li> <li>DXGI_FORMAT_R8G8_UNORM</li> <li>DXGI_FORMAT_R8G8B8A8_UNORM</li> <li>DXGI_FORMAT_B8G8R8A8_UNORM</li> <li>DXGI_FORMAT_B8G8R8X8_UNORM</li> <li>DXGI_FORMAT_R8G8B8A8_UNORM_SRGB</li> <li>DXGI_FORMAT_B8G8R8A8_UNORM_SRGB</li> <li>DXGI_FORMAT_R16G16B16A16_FLOAT</li> <li>DXGI_FORMAT_R16G16B16A16_UNORM</li> <li>DXGI_FORMAT_R32G32B32A32_FLOAT</li> <li>DXGI_FORMAT_BC1_UNORM</li> <li>DXGI_FORMAT_BC2_UNORM</li> <li>DXGI_FORMAT_BC3_UNORM</li> </ul> </td></tr> <tr><td>DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601</td><td>1, 2, 3</td><td> When Surface count is 1: <ul> <li>DXGI_FORMAT_AYUV</li> <li>DXGI_FORMAT_NV12</li> <li>DXGI_FORMAT_YUY2</li> <li>DXGI_FORMAT_P208</li> <li>DXGI_FORMAT_V208</li> <li>DXGI_FORMAT_V408</li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8G8_UNORM}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM}</li> </ul> </td></tr> <tr><td> DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601 <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P601</p> <p>DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709</p> <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P709</p> <p>DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020</p> <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020</p> </td><td>1,2,3</td><td> <p>When Surface count is 1: </p> <ul> <li>DXGI_FORMAT_NV12</li> <li>DXGI_FORMAT_YUY2</li> <li>DXGI_FORMAT_P208</li> <li>DXGI_FORMAT_V208</li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8G8_UNORM}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM}</li> </ul> </td></tr> </table><p>?</p><p>The GPU must also have sufficient support for a pixel format to be supported by D2D.  To determine whether D2D supports a format, call IsDxgiFormatSupported.</p><p>This API converts YCbCr formats to sRGB using the provided color space type and options.  RGBA data is assumed to be in the desired space, and D2D does not apply any conversion.</p><p> If multiple surfaces are provided, this method infers whether chroma planes are subsampled (by 2x) from the relative sizes of each corresponding source rectangle (or if the source rectangles parameter is <c>null</c>, the bounds of each surface).  The second and third rectangle must each be equal in size to the first rectangle, or to the first rectangle with one or both dimensions scaled by 0.5 (while rounding up). </p><p> If provided, the source rectangles must be within the bounds of the corresponding surface.  The source rectangles may have different origins. In this case, this method shifts the data from each plane to align with one another. </p>
        /// </remarks>
        /// <doc-id>dn890791</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateImageSourceFromDxgi([In, Buffer] IDXGISurface** surfaces,[In] unsigned int surfaceCount,[In] DXGI_COLOR_SPACE_TYPE colorSpace,[In] D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS options,[Out, Fast] ID2D1ImageSource** imageSource)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext2::CreateImageSourceFromDxgi</unmanaged-short>
        internal unsafe void CreateImageSourceFromDxgi(SharpDX.DXGI.Surface[] surfaces, System.Int32 surfaceCount, SharpDX.DXGI.ColorSpaceType colorSpace, SharpDX.Direct2D1.ImageSourceFromDxgiOptions options, SharpDX.Direct2D1.ImageSource imageSource)
        {
            System.IntPtr*surfaces_;
            surfaces_ = (System.IntPtr*)0;
            if (surfaces != null)
            {
                System.IntPtr*_surfaces = stackalloc System.IntPtr[surfaces.Length];
                surfaces_ = _surfaces;
            }

            System.IntPtr imageSource_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (surfaces != null)
                for (int i = 0; i < surfaces.Length; ++i)
                    (surfaces_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Surface>(surfaces[i]);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)surfaces_, surfaceCount, unchecked ((System.Int32)colorSpace), unchecked ((System.Int32)options), &imageSource_, (*(void ***)this._nativePointer)[100]);
            (imageSource).NativePointer = imageSource_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns the world bounds of a given gradient mesh.</p>
        /// </summary>
        /// <param name = "gradientMesh"><dd>  <p>The gradient mesh whose world bounds will be calculated.</p> </dd></param>
        /// <param name = "boundsRef"><dd>  <p>When this method returns, contains a reference to the bounds of the gradient mesh, in device independent pixels (DIPs).</p> </dd></param>
        /// <returns><p><see cref = "SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "SharpDX.Result"/>.</p></returns>
        /// <remarks>
        /// <p>The world bounds reflect the current DPI, unit mode, and world transform of the context. They indicate which pixels would be impacted by calling DrawGradientMesh with the given gradient mesh. 
        /// They do not reflect the current clip rectangle set on the device context or the extent of the context?s current target.</p>
        /// </remarks>
        /// <doc-id>dn900380</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext2::GetGradientMeshWorldBounds([In] ID2D1GradientMesh* gradientMesh,[Out] D2D_RECT_F* pBounds)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext2::GetGradientMeshWorldBounds</unmanaged-short>
        public unsafe void GetGradientMeshWorldBounds(SharpDX.Direct2D1.GradientMesh gradientMesh, out SharpDX.Mathematics.Interop.RawRectangleF boundsRef)
        {
            System.IntPtr gradientMesh_ = System.IntPtr.Zero;
            boundsRef = default (SharpDX.Mathematics.Interop.RawRectangleF);
            SharpDX.Result __result__;
            gradientMesh_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.GradientMesh>(gradientMesh);
            fixed (void *boundsRef_ = &boundsRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)gradientMesh_, boundsRef_, (*(void ***)this._nativePointer)[101]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Renders the given ink object using the given brush and ink style.</p>
        /// </summary>
        /// <param name = "ink"><dd>  <p>The ink object to be rendered.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush with which to render the ink object.</p> </dd></param>
        /// <param name = "inkStyle"><dd>  <p>The ink style to use when rendering the ink object.</p> </dd></param>
        /// <doc-id>dn900379</doc-id>
        /// <unmanaged>void ID2D1DeviceContext2::DrawInk([In] ID2D1Ink* ink,[In] ID2D1Brush* brush,[In, Optional] ID2D1InkStyle* inkStyle)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext2::DrawInk</unmanaged-short>
        public unsafe void DrawInk(SharpDX.Direct2D1.Ink ink, SharpDX.Direct2D1.Brush brush, SharpDX.Direct2D1.InkStyle inkStyle)
        {
            System.IntPtr ink_ = System.IntPtr.Zero;
            System.IntPtr brush_ = System.IntPtr.Zero;
            System.IntPtr inkStyle_ = System.IntPtr.Zero;
            ink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Ink>(ink);
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            inkStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.InkStyle>(inkStyle);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)ink_, (void *)brush_, (void *)inkStyle_, (*(void ***)this._nativePointer)[102]);
        }

        /// <summary>
        /// <p>Renders a given gradient mesh to the target.</p>
        /// </summary>
        /// <param name = "gradientMesh"><dd>  <p>The gradient mesh to be rendered.</p> </dd></param>
        /// <doc-id>dn900378</doc-id>
        /// <unmanaged>void ID2D1DeviceContext2::DrawGradientMesh([In] ID2D1GradientMesh* gradientMesh)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext2::DrawGradientMesh</unmanaged-short>
        public unsafe void DrawGradientMesh(SharpDX.Direct2D1.GradientMesh gradientMesh)
        {
            System.IntPtr gradientMesh_ = System.IntPtr.Zero;
            gradientMesh_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.GradientMesh>(gradientMesh);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)gradientMesh_, (*(void ***)this._nativePointer)[103]);
        }

        /// <summary>
        /// <p>Draws a metafile to the device context using the given source and destination rectangles.</p>
        /// </summary>
        /// <param name = "gdiMetafile"><dd>  <p>The metafile to draw.</p> </dd></param>
        /// <param name = "destinationRectangle"><dd>  <p>The rectangle in the target where the metafile will be drawn, relative to the upper left corner (defined in DIPs) of the render target.  If <c>null</c> is specified, the destination rectangle is {0, 0, w, h}, where w and h are the width and height of the metafile as reported by <strong>ID2D1GdiMetafile::GetBounds</strong>. </p> </dd></param>
        /// <param name = "sourceRectangle"><dd>  <p>The rectangle of the source metafile that will be drawn, relative to the upper left corner (defined in DIPs) of the metafile.  If <c>null</c> is specified, the source rectangle is the value returned by <strong>ID2D1GdiMetafile1::GetSourceBounds</strong>.</p> </dd></param>
        /// <doc-id>dn900375</doc-id>
        /// <unmanaged>void ID2D1DeviceContext2::DrawGdiMetafile([In] ID2D1GdiMetafile* gdiMetafile,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext2::DrawGdiMetafile</unmanaged-short>
        public unsafe void DrawGdiMetafile(SharpDX.Direct2D1.GdiMetafile gdiMetafile, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle)
        {
            System.IntPtr gdiMetafile_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangleF destinationRectangle_;
            SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle_;
            gdiMetafile_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.GdiMetafile>(gdiMetafile);
            if (destinationRectangle != null)
                destinationRectangle_ = destinationRectangle.Value;
            if (sourceRectangle != null)
                sourceRectangle_ = sourceRectangle.Value;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)gdiMetafile_, destinationRectangle == null ? (void *)0 : &destinationRectangle_, sourceRectangle == null ? (void *)0 : &sourceRectangle_, (*(void ***)this._nativePointer)[104]);
        }

        /// <summary>
        /// <p>Creates an image source which shares resources with an original.</p>
        /// </summary>
        /// <param name = "imageSource"><dd>  <p>The original image.</p> </dd></param>
        /// <param name = "ropertiesRef"><dd>  <p>Properties for the source image.</p> </dd></param>
        /// <param name = "transformedImageSource"><dd>  <p>Receives the new image source.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn934381</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateTransformedImageSource([In] ID2D1ImageSource* imageSource,[In] const D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES* properties,[Out, Fast] ID2D1TransformedImageSource** transformedImageSource)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext2::CreateTransformedImageSource</unmanaged-short>
        internal unsafe void CreateTransformedImageSource(SharpDX.Direct2D1.ImageSource imageSource, ref SharpDX.Direct2D1.TransformedImageSourceProperties ropertiesRef, SharpDX.Direct2D1.TransformedImageSource transformedImageSource)
        {
            System.IntPtr imageSource_ = System.IntPtr.Zero;
            System.IntPtr transformedImageSource_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            imageSource_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.ImageSource>(imageSource);
            fixed (void *ropertiesRef_ = &ropertiesRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)imageSource_, ropertiesRef_, &transformedImageSource_, (*(void ***)this._nativePointer)[105]);
            (transformedImageSource).NativePointer = transformedImageSource_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an image source from a set of DXGI surface(s).  The YCbCr surface(s) are converted to RGBA automatically during subsequent drawing.</p>
        /// </summary>
        /// <param name = "surfaces"><dd>  <p>The DXGI surfaces to create the image source from.</p> </dd></param>
        /// <param name = "surfaceCount"><dd>  <p>The number of surfaces provided; must be between one and three.</p> </dd></param>
        /// <param name = "colorSpace"><dd>  <p>The color space of the input.</p> </dd></param>
        /// <param name = "options"><dd>  <p>Options controlling color space conversions.</p> </dd></param>
        /// <param name = "imageSource"><dd>  <p>Receives the new image source instance.</p> </dd></param>
        /// <returns><p><see cref = "SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "SharpDX.Result"/>.</p></returns>
        /// <remarks>
        /// <p> This method creates an image source which can be used to draw the image. This method supports surfaces that use a limited set of DXGI formats and DXGI color space types.  Only the below set of combinations of color space types, surface formats, and surface counts are supported: </p><table> <tr><th>Color Space Type</th><th>Surface Count(s)</th><th>Surface Format(s)</th></tr> <tr><td>DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709</td><td>1</td><td> Standard D2D-supported pixel formats: <ul> <li>DXGI_FORMAT_A8_UNORM</li> <li>DXGI_FORMAT_R8_UNORM</li> <li>DXGI_FORMAT_R8G8_UNORM</li> <li>DXGI_FORMAT_R8G8B8A8_UNORM</li> <li>DXGI_FORMAT_B8G8R8A8_UNORM</li> <li>DXGI_FORMAT_B8G8R8X8_UNORM</li> <li>DXGI_FORMAT_R8G8B8A8_UNORM_SRGB</li> <li>DXGI_FORMAT_B8G8R8A8_UNORM_SRGB</li> <li>DXGI_FORMAT_R16G16B16A16_FLOAT</li> <li>DXGI_FORMAT_R16G16B16A16_UNORM</li> <li>DXGI_FORMAT_R32G32B32A32_FLOAT</li> <li>DXGI_FORMAT_BC1_UNORM</li> <li>DXGI_FORMAT_BC2_UNORM</li> <li>DXGI_FORMAT_BC3_UNORM</li> </ul> </td></tr> <tr><td>DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601</td><td>1, 2, 3</td><td> When Surface count is 1: <ul> <li>DXGI_FORMAT_AYUV</li> <li>DXGI_FORMAT_NV12</li> <li>DXGI_FORMAT_YUY2</li> <li>DXGI_FORMAT_P208</li> <li>DXGI_FORMAT_V208</li> <li>DXGI_FORMAT_V408</li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8G8_UNORM}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM}</li> </ul> </td></tr> <tr><td> DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601 <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P601</p> <p>DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709</p> <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P709</p> <p>DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020</p> <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020</p> </td><td>1,2,3</td><td> <p>When Surface count is 1: </p> <ul> <li>DXGI_FORMAT_NV12</li> <li>DXGI_FORMAT_YUY2</li> <li>DXGI_FORMAT_P208</li> <li>DXGI_FORMAT_V208</li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8G8_UNORM}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM}</li> </ul> </td></tr> </table><p>?</p><p>The GPU must also have sufficient support for a pixel format to be supported by D2D.  To determine whether D2D supports a format, call IsDxgiFormatSupported.</p><p>This API converts YCbCr formats to sRGB using the provided color space type and options.  RGBA data is assumed to be in the desired space, and D2D does not apply any conversion.</p><p> If multiple surfaces are provided, this method infers whether chroma planes are subsampled (by 2x) from the relative sizes of each corresponding source rectangle (or if the source rectangles parameter is <c>null</c>, the bounds of each surface).  The second and third rectangle must each be equal in size to the first rectangle, or to the first rectangle with one or both dimensions scaled by 0.5 (while rounding up). </p><p> If provided, the source rectangles must be within the bounds of the corresponding surface.  The source rectangles may have different origins. In this case, this method shifts the data from each plane to align with one another. </p>
        /// </remarks>
        /// <doc-id>dn890791</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateImageSourceFromDxgi([In, Buffer] IDXGISurface** surfaces,[In] unsigned int surfaceCount,[In] DXGI_COLOR_SPACE_TYPE colorSpace,[In] D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS options,[Out, Fast] ID2D1ImageSource** imageSource)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext2::CreateImageSourceFromDxgi</unmanaged-short>
        internal unsafe void CreateImageSourceFromDxgi(SharpDX.ComArray<SharpDX.DXGI.Surface> surfaces, System.Int32 surfaceCount, SharpDX.DXGI.ColorSpaceType colorSpace, SharpDX.Direct2D1.ImageSourceFromDxgiOptions options, SharpDX.Direct2D1.ImageSource imageSource)
        {
            System.IntPtr imageSource_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)(surfaces?.NativePointer ?? System.IntPtr.Zero), surfaceCount, unchecked ((System.Int32)colorSpace), unchecked ((System.Int32)options), &imageSource_, (*(void ***)this._nativePointer)[100]);
            (imageSource).NativePointer = imageSource_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an image source from a set of DXGI surface(s).  The YCbCr surface(s) are converted to RGBA automatically during subsequent drawing.</p>
        /// </summary>
        /// <param name = "surfaces"><dd>  <p>The DXGI surfaces to create the image source from.</p> </dd></param>
        /// <param name = "surfaceCount"><dd>  <p>The number of surfaces provided; must be between one and three.</p> </dd></param>
        /// <param name = "colorSpace"><dd>  <p>The color space of the input.</p> </dd></param>
        /// <param name = "options"><dd>  <p>Options controlling color space conversions.</p> </dd></param>
        /// <param name = "imageSource"><dd>  <p>Receives the new image source instance.</p> </dd></param>
        /// <returns><p><see cref = "SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "SharpDX.Result"/>.</p></returns>
        /// <remarks>
        /// <p> This method creates an image source which can be used to draw the image. This method supports surfaces that use a limited set of DXGI formats and DXGI color space types.  Only the below set of combinations of color space types, surface formats, and surface counts are supported: </p><table> <tr><th>Color Space Type</th><th>Surface Count(s)</th><th>Surface Format(s)</th></tr> <tr><td>DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709</td><td>1</td><td> Standard D2D-supported pixel formats: <ul> <li>DXGI_FORMAT_A8_UNORM</li> <li>DXGI_FORMAT_R8_UNORM</li> <li>DXGI_FORMAT_R8G8_UNORM</li> <li>DXGI_FORMAT_R8G8B8A8_UNORM</li> <li>DXGI_FORMAT_B8G8R8A8_UNORM</li> <li>DXGI_FORMAT_B8G8R8X8_UNORM</li> <li>DXGI_FORMAT_R8G8B8A8_UNORM_SRGB</li> <li>DXGI_FORMAT_B8G8R8A8_UNORM_SRGB</li> <li>DXGI_FORMAT_R16G16B16A16_FLOAT</li> <li>DXGI_FORMAT_R16G16B16A16_UNORM</li> <li>DXGI_FORMAT_R32G32B32A32_FLOAT</li> <li>DXGI_FORMAT_BC1_UNORM</li> <li>DXGI_FORMAT_BC2_UNORM</li> <li>DXGI_FORMAT_BC3_UNORM</li> </ul> </td></tr> <tr><td>DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601</td><td>1, 2, 3</td><td> When Surface count is 1: <ul> <li>DXGI_FORMAT_AYUV</li> <li>DXGI_FORMAT_NV12</li> <li>DXGI_FORMAT_YUY2</li> <li>DXGI_FORMAT_P208</li> <li>DXGI_FORMAT_V208</li> <li>DXGI_FORMAT_V408</li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8G8_UNORM}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM}</li> </ul> </td></tr> <tr><td> DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601 <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P601</p> <p>DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709</p> <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P709</p> <p>DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020</p> <p>DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020</p> </td><td>1,2,3</td><td> <p>When Surface count is 1: </p> <ul> <li>DXGI_FORMAT_NV12</li> <li>DXGI_FORMAT_YUY2</li> <li>DXGI_FORMAT_P208</li> <li>DXGI_FORMAT_V208</li> </ul> <p>When Surface Count is 2:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8G8_UNORM}</li> </ul> <p>When Surface Count is 3:</p> <ul> <li>{DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM, DXGI_FORMAT_R8_UNORM}</li> </ul> </td></tr> </table><p>?</p><p>The GPU must also have sufficient support for a pixel format to be supported by D2D.  To determine whether D2D supports a format, call IsDxgiFormatSupported.</p><p>This API converts YCbCr formats to sRGB using the provided color space type and options.  RGBA data is assumed to be in the desired space, and D2D does not apply any conversion.</p><p> If multiple surfaces are provided, this method infers whether chroma planes are subsampled (by 2x) from the relative sizes of each corresponding source rectangle (or if the source rectangles parameter is <c>null</c>, the bounds of each surface).  The second and third rectangle must each be equal in size to the first rectangle, or to the first rectangle with one or both dimensions scaled by 0.5 (while rounding up). </p><p> If provided, the source rectangles must be within the bounds of the corresponding surface.  The source rectangles may have different origins. In this case, this method shifts the data from each plane to align with one another. </p>
        /// </remarks>
        /// <doc-id>dn890791</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext2::CreateImageSourceFromDxgi([In, Buffer] IDXGISurface** surfaces,[In] unsigned int surfaceCount,[In] DXGI_COLOR_SPACE_TYPE colorSpace,[In] D2D1_IMAGE_SOURCE_FROM_DXGI_OPTIONS options,[Out, Fast] ID2D1ImageSource** imageSource)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext2::CreateImageSourceFromDxgi</unmanaged-short>
        private unsafe void CreateImageSourceFromDxgi(System.IntPtr surfaces, System.Int32 surfaceCount, SharpDX.DXGI.ColorSpaceType colorSpace, SharpDX.Direct2D1.ImageSourceFromDxgiOptions options, System.IntPtr imageSource)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)surfaces, surfaceCount, unchecked ((System.Int32)colorSpace), unchecked ((System.Int32)options), (void *)imageSource, (*(void ***)this._nativePointer)[100]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("235a7496-8351-414c-bcd4-6672ab2d8e00")]
    public partial class DeviceContext3 : SharpDX.Direct2D1.DeviceContext2
    {
        public DeviceContext3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceContext3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceContext3(nativePtr);
        /// <summary>
        /// <p>Creates a new, empty sprite batch. After creating a sprite batch, use <strong>ID2D1SpriteBatch::AddSprites</strong> to add sprites to it, then use <strong>ID2D1DeviceContext3::DrawSpriteBatch</strong> to draw it.</p>
        /// </summary>
        /// <param name = "spriteBatch">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>mt619827</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext3::CreateSpriteBatch([Out, Fast] ID2D1SpriteBatch** spriteBatch)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext3::CreateSpriteBatch</unmanaged-short>
        internal unsafe void CreateSpriteBatch(SharpDX.Direct2D1.SpriteBatch spriteBatch)
        {
            System.IntPtr spriteBatch_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &spriteBatch_, (*(void ***)this._nativePointer)[106]);
            (spriteBatch).NativePointer = spriteBatch_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Renders all sprites in the given sprite batch to the device context using the specified drawing options.</p>
        /// </summary>
        /// <param name = "spriteBatch"><dd>  <p>The sprite batch to draw.</p> </dd></param>
        /// <param name = "startIndex"><dd>  <p>The bitmap from which the sprites are to be sourced. Each sprite?s source rectangle refers to a portion of this bitmap.</p> </dd></param>
        /// <param name = "spriteCount"><dd>  <p>The interpolation mode to use when drawing this sprite batch. This determines how Direct2D interpolates pixels within the drawn sprites if scaling is performed.</p> </dd></param>
        /// <param name = "bitmap"><dd>  <p>The bitmap from which the sprites are to be sourced. Each sprite?s source rectangle refers to a portion of this bitmap.</p> </dd></param>
        /// <param name = "interpolationMode"><dd>  <p>The interpolation mode to use when drawing this sprite batch. This determines how Direct2D interpolates pixels within the drawn sprites if scaling is performed.</p> </dd></param>
        /// <param name = "spriteOptions"><dd>  <p>The additional drawing options, if any, to be used for this sprite batch.</p> </dd></param>
        /// <doc-id>mt619829</doc-id>
        /// <unmanaged>void ID2D1DeviceContext3::DrawSpriteBatch([In] ID2D1SpriteBatch* spriteBatch,[In] unsigned int startIndex,[In] unsigned int spriteCount,[In] ID2D1Bitmap* bitmap,[In] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode,[In] D2D1_SPRITE_OPTIONS spriteOptions)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext3::DrawSpriteBatch</unmanaged-short>
        public unsafe void DrawSpriteBatch(SharpDX.Direct2D1.SpriteBatch spriteBatch, System.Int32 startIndex, System.Int32 spriteCount, SharpDX.Direct2D1.Bitmap bitmap, SharpDX.Direct2D1.BitmapInterpolationMode interpolationMode, SharpDX.Direct2D1.SpriteOptions spriteOptions)
        {
            System.IntPtr spriteBatch_ = System.IntPtr.Zero;
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            spriteBatch_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SpriteBatch>(spriteBatch);
            bitmap_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Bitmap>(bitmap);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)spriteBatch_, startIndex, spriteCount, (void *)bitmap_, unchecked ((System.Int32)interpolationMode), unchecked ((System.Int32)spriteOptions), (*(void ***)this._nativePointer)[107]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("8c427831-3d90-4476-b647-c4fae349e4db")]
    public partial class DeviceContext4 : SharpDX.Direct2D1.DeviceContext3
    {
        public DeviceContext4(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceContext4(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceContext4(nativePtr);
        /// <summary>
        /// <p>Creates an SVG glyph style object.</p>
        /// </summary>
        /// <param name = "svgGlyphStyle"><dd>  <p>On completion points to the created <strong><see cref = "SharpDX.Direct2D1.SvgGlyphStyle"/></strong> object.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code.</p></returns>
        /// <doc-id>mt750183</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext4::CreateSvgGlyphStyle([Out] ID2D1SvgGlyphStyle** svgGlyphStyle)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext4::CreateSvgGlyphStyle</unmanaged-short>
        public unsafe void CreateSvgGlyphStyle(out SharpDX.Direct2D1.SvgGlyphStyle svgGlyphStyle)
        {
            System.IntPtr svgGlyphStyle_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &svgGlyphStyle_, (*(void ***)this._nativePointer)[108]);
            if (svgGlyphStyle_ != System.IntPtr.Zero)
                svgGlyphStyle = new SharpDX.Direct2D1.SvgGlyphStyle(svgGlyphStyle_);
            else
                svgGlyphStyle = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Represents a set of state and command buffers that are used to render to a target.</p><p>The device context can render to a target bitmap or a command list.
        /// </p>
        /// </summary>
        /// <param name = "text">No documentation.</param>
        /// <param name = "stringLength">No documentation.</param>
        /// <param name = "textFormat">No documentation.</param>
        /// <param name = "layoutRect">No documentation.</param>
        /// <param name = "defaultFillBrush">No documentation.</param>
        /// <param name = "svgGlyphStyle">No documentation.</param>
        /// <param name = "colorPaletteIndex">No documentation.</param>
        /// <param name = "options">No documentation.</param>
        /// <param name = "measuringMode">No documentation.</param>
        /// <remarks>
        /// <p> Any resource created from a device context can be shared with any other resource created from a device context when both contexts are created on the same device. </p>
        /// </remarks>
        /// <doc-id>hh404479</doc-id>
        /// <unmanaged>void ID2D1DeviceContext4::DrawTextW([In, Buffer] const wchar_t* string,[In] unsigned int stringLength,[In] IDWriteTextFormat* textFormat,[In] const D2D_RECT_F* layoutRect,[In, Optional] ID2D1Brush* defaultFillBrush,[In, Optional] ID2D1SvgGlyphStyle* svgGlyphStyle,[In] unsigned int colorPaletteIndex,[In] D2D1_DRAW_TEXT_OPTIONS options,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext4::DrawTextW</unmanaged-short>
        public unsafe void DrawText(System.String text, System.Int32 stringLength, SharpDX.DirectWrite.TextFormat textFormat, SharpDX.Mathematics.Interop.RawRectangleF layoutRect, SharpDX.Direct2D1.Brush defaultFillBrush, SharpDX.Direct2D1.SvgGlyphStyle svgGlyphStyle, System.Int32 colorPaletteIndex, SharpDX.Direct2D1.DrawTextOptions options, SharpDX.Direct2D1.MeasuringMode measuringMode)
        {
            System.IntPtr textFormat_ = System.IntPtr.Zero;
            System.IntPtr defaultFillBrush_ = System.IntPtr.Zero;
            System.IntPtr svgGlyphStyle_ = System.IntPtr.Zero;
            textFormat_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextFormat>(textFormat);
            defaultFillBrush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(defaultFillBrush);
            svgGlyphStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SvgGlyphStyle>(svgGlyphStyle);
            fixed (char *text_ = text)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)text_, stringLength, (void *)textFormat_, &layoutRect, (void *)defaultFillBrush_, (void *)svgGlyphStyle_, colorPaletteIndex, unchecked ((System.Int32)options), unchecked ((System.Int32)measuringMode), (*(void ***)this._nativePointer)[109]);
        }

        /// <summary>
        /// <p>Draws a text layout object. If the layout is not subsequently changed, this can be more efficient than DrawText when drawing the same layout repeatedly.</p>
        /// </summary>
        /// <param name = "origin"><dd>  <p>The point, described in device-independent pixels, at which the upper-left corner of the text described by <em>textLayout</em> is drawn.</p> </dd></param>
        /// <param name = "textLayout"><dd>  <p>The formatted text to draw. Any drawing effects that do not inherit from <strong><see cref = "SharpDX.Direct2D1.Resource"/></strong> are ignored. If there are drawing effects that inherit from <strong><see cref = "SharpDX.Direct2D1.Resource"/></strong> that are not brushes, this method fails and the render target is put in an error state. </p> </dd></param>
        /// <param name = "defaultFillBrush"><dd>  <p>The brush used to paint the text.</p> </dd></param>
        /// <param name = "svgGlyphStyle"><dd>  <p>The values for context-fill, context-stroke, and context-value that are used when rendering SVG glyphs.</p> </dd></param>
        /// <param name = "colorPaletteIndex"><dd>  <p>The index used to select a color palette within a color font.</p> </dd></param>
        /// <param name = "options"><dd>  <p> A value that indicates whether the text should be snapped to pixel boundaries and whether the text should be clipped to the layout rectangle.  The default value is <strong>D2D1_DRAW_TEXT_OPTIONS_NONE</strong>,  which indicates that text should be snapped to pixel boundaries and it should not be clipped to the layout rectangle. </p> </dd></param>
        /// <doc-id>mt750187</doc-id>
        /// <unmanaged>void ID2D1DeviceContext4::DrawTextLayout([In] D2D_POINT_2F origin,[In] IDWriteTextLayout* textLayout,[In, Optional] ID2D1Brush* defaultFillBrush,[In, Optional] ID2D1SvgGlyphStyle* svgGlyphStyle,[In] unsigned int colorPaletteIndex,[In] D2D1_DRAW_TEXT_OPTIONS options)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext4::DrawTextLayout</unmanaged-short>
        public unsafe void DrawTextLayout(SharpDX.Mathematics.Interop.RawVector2 origin, SharpDX.DirectWrite.TextLayout textLayout, SharpDX.Direct2D1.Brush defaultFillBrush, SharpDX.Direct2D1.SvgGlyphStyle svgGlyphStyle, System.Int32 colorPaletteIndex, SharpDX.Direct2D1.DrawTextOptions options)
        {
            System.IntPtr textLayout_ = System.IntPtr.Zero;
            System.IntPtr defaultFillBrush_ = System.IntPtr.Zero;
            System.IntPtr svgGlyphStyle_ = System.IntPtr.Zero;
            textLayout_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextLayout>(textLayout);
            defaultFillBrush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(defaultFillBrush);
            svgGlyphStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SvgGlyphStyle>(svgGlyphStyle);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, origin, (void *)textLayout_, (void *)defaultFillBrush_, (void *)svgGlyphStyle_, colorPaletteIndex, unchecked ((System.Int32)options), (*(void ***)this._nativePointer)[110]);
        }

        /// <summary>
        /// <p>Draws a color bitmap glyph run using one of the bitmap formats.</p>
        /// </summary>
        /// <param name = "glyphImageFormat"><dd>  <p>Specifies the format of the glyph image. Supported formats are DWRITE_GLYPH_IMAGE_FORMATS_PNG, DWRITE_GLYPH_IMAGE_FORMATS_JPEG, DWRITE_GLYPH_IMAGE_FORMATS_TIFF, or DWRITE_GLYPH_IMAGE_FORMATS_PREMULTIPLIED_B8G8R8A8.  This method will result in an error if the color glyph run does not contain the requested format. </p> <p>Only one format can be specified at a time, combinations of flags are not valid input.</p> </dd></param>
        /// <param name = "baselineOrigin"><dd>  <p>The origin of the baseline for the glyph run.</p> </dd></param>
        /// <param name = "glyphRun"><dd>  <p>The glyphs to render.</p> </dd></param>
        /// <param name = "measuringMode"><dd>  <p>Indicates the measuring method.</p> </dd></param>
        /// <param name = "bitmapSnapOption"><dd>  <p>Specifies the pixel snapping policy when rendering color bitmap glyphs.</p> </dd></param>
        /// <doc-id>mt750184</doc-id>
        /// <unmanaged>void ID2D1DeviceContext4::DrawColorBitmapGlyphRun([In] DWRITE_GLYPH_IMAGE_FORMATS glyphImageFormat,[In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] DWRITE_MEASURING_MODE measuringMode,[In] D2D1_COLOR_BITMAP_GLYPH_SNAP_OPTION bitmapSnapOption)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext4::DrawColorBitmapGlyphRun</unmanaged-short>
        public unsafe void DrawColorBitmapGlyphRun(SharpDX.Direct2D1.GlyphImageFormatS glyphImageFormat, SharpDX.Mathematics.Interop.RawVector2 baselineOrigin, SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.Direct2D1.MeasuringMode measuringMode, SharpDX.Direct2D1.ColorBitmapGlyphSnapOption bitmapSnapOption)
        {
            SharpDX.DirectWrite.GlyphRun.__Native glyphRun_ = default (SharpDX.DirectWrite.GlyphRun.__Native);
            glyphRun.__MarshalTo(ref glyphRun_);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, unchecked ((System.Int32)glyphImageFormat), baselineOrigin, &glyphRun_, unchecked ((System.Int32)measuringMode), unchecked ((System.Int32)bitmapSnapOption), (*(void ***)this._nativePointer)[111]);
            glyphRun.__MarshalFree(ref glyphRun_);
        }

        /// <summary>
        /// <p>Draws a color glyph run that has the format of DWRITE_GLYPH_IMAGE_FORMATS_SVG.</p>
        /// </summary>
        /// <param name = "baselineOrigin"><dd>  <p>The origin of the baseline for the glyph run.</p> </dd></param>
        /// <param name = "glyphRun"><dd>  <p>The glyphs to render.</p> </dd></param>
        /// <param name = "defaultFillBrush"><dd>  <p>The brush used to paint the specified glyphs.</p> </dd></param>
        /// <param name = "svgGlyphStyle"><dd>  <p>Values for context-fill, context-stroke, and context-value that are used when rendering SVG glyphs.</p> </dd></param>
        /// <param name = "colorPaletteIndex"><dd>  <p>The index used to select a color palette within a color font. Note that this not the same as the paletteIndex in the <see cref = "SharpDX.DirectWrite.ColorGlyphRun"/> struct, which is not relevant for SVG glyphs.</p> </dd></param>
        /// <param name = "measuringMode"><dd>  <p>Indicates the measuring method used for text layout.</p> </dd></param>
        /// <doc-id>mt750185</doc-id>
        /// <unmanaged>void ID2D1DeviceContext4::DrawSvgGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In, Optional] ID2D1Brush* defaultFillBrush,[In, Optional] ID2D1SvgGlyphStyle* svgGlyphStyle,[In] unsigned int colorPaletteIndex,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext4::DrawSvgGlyphRun</unmanaged-short>
        public unsafe void DrawSvgGlyphRun(SharpDX.Mathematics.Interop.RawVector2 baselineOrigin, SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.Direct2D1.Brush defaultFillBrush, SharpDX.Direct2D1.SvgGlyphStyle svgGlyphStyle, System.Int32 colorPaletteIndex, SharpDX.Direct2D1.MeasuringMode measuringMode)
        {
            SharpDX.DirectWrite.GlyphRun.__Native glyphRun_ = default (SharpDX.DirectWrite.GlyphRun.__Native);
            System.IntPtr defaultFillBrush_ = System.IntPtr.Zero;
            System.IntPtr svgGlyphStyle_ = System.IntPtr.Zero;
            glyphRun.__MarshalTo(ref glyphRun_);
            defaultFillBrush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(defaultFillBrush);
            svgGlyphStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SvgGlyphStyle>(svgGlyphStyle);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, baselineOrigin, &glyphRun_, (void *)defaultFillBrush_, (void *)svgGlyphStyle_, colorPaletteIndex, unchecked ((System.Int32)measuringMode), (*(void ***)this._nativePointer)[112]);
            glyphRun.__MarshalFree(ref glyphRun_);
        }

        /// <summary>
        /// <p> Retrieves an image of the color bitmap glyph from the color glyph cache. If the cache does not already contain the requested resource, it will be created. This method may be used to extend the lifetime of a glyph image even after it is evicted from the color glyph cache. </p>
        /// </summary>
        /// <param name = "glyphImageFormat"><dd>  <p>The format for the glyph image. If there is no image data in the requested format for the requested glyph, this method will return an error. </p> </dd></param>
        /// <param name = "glyphOrigin"><dd>  <p>The origin for the glyph.</p> </dd></param>
        /// <param name = "fontFace"><dd>  <p>Reference to a font face which contains font face type, appropriate file references, face identification data and various font data such as metrics, names and glyph outlines.</p> </dd></param>
        /// <param name = "fontEmSize"><dd>  <p>The specified font size affects the choice of which bitmap to use from the font. It also affects the output glyphTransform, causing  it to properly scale the glyph.</p> </dd></param>
        /// <param name = "glyphIndex"><dd>  <p>Index of the glyph.</p> </dd></param>
        /// <param name = "isSideways"><dd>  <p>If true, specifies that glyphs are rotated 90 degrees to the left and vertical metrics are used. Vertical writing is achieved by specifying isSideways as true and rotating the entire run 90 degrees to the right via a rotate transform.</p> </dd></param>
        /// <param name = "worldTransform"><dd>  <p>The transform to apply to the image. This input transform affects the choice of which bitmap to use from the font. It is also factored into the output glyphTransform.</p> </dd></param>
        /// <param name = "dpiX"><dd>  <p>Dots per inch along the x-axis.</p> </dd></param>
        /// <param name = "dpiY"><dd>  <p>Dots per inch along the y-axis.</p> </dd></param>
        /// <param name = "glyphTransform"><dd>  <p>Output transform, which transforms from the glyph's space to the same output space as the worldTransform. This includes the input glyphOrigin, the glyph's offset from the glyphOrigin, and any other required transformations.</p> </dd></param>
        /// <param name = "glyphImage"><dd>  <p>On completion contains the retrieved glyph image.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code.</p></returns>
        /// <doc-id>mt750189</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext4::GetColorBitmapGlyphImage([In] DWRITE_GLYPH_IMAGE_FORMATS glyphImageFormat,[In] D2D_POINT_2F glyphOrigin,[In] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] unsigned short glyphIndex,[In] BOOL isSideways,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float dpiX,[In] float dpiY,[Out] D2D_MATRIX_3X2_F* glyphTransform,[Out] ID2D1Image** glyphImage)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext4::GetColorBitmapGlyphImage</unmanaged-short>
        public unsafe void GetColorBitmapGlyphImage(SharpDX.Direct2D1.GlyphImageFormatS glyphImageFormat, SharpDX.Mathematics.Interop.RawVector2 glyphOrigin, SharpDX.DirectWrite.FontFace fontFace, System.Single fontEmSize, System.Int16 glyphIndex, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, System.Single dpiX, System.Single dpiY, out SharpDX.Mathematics.Interop.RawMatrix3x2 glyphTransform, out SharpDX.Direct2D1.Image glyphImage)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
            glyphTransform = default (SharpDX.Mathematics.Interop.RawMatrix3x2);
            System.IntPtr glyphImage_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFace_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFace>(fontFace);
            if (worldTransform != null)
                worldTransform_ = worldTransform.Value;
            fixed (void *glyphTransform_ = &glyphTransform)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, unchecked ((System.Int32)glyphImageFormat), glyphOrigin, (void *)fontFace_, fontEmSize, glyphIndex, isSideways, worldTransform == null ? (void *)0 : &worldTransform_, dpiX, dpiY, glyphTransform_, &glyphImage_, (*(void ***)this._nativePointer)[113]);
            if (glyphImage_ != System.IntPtr.Zero)
                glyphImage = new SharpDX.Direct2D1.Image(glyphImage_);
            else
                glyphImage = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Retrieves an image of the SVG glyph from the color glyph cache. If the cache  does not already contain the requested resource, it will be created. This method may be used to extend the lifetime of a glyph image even after it is evicted from the color glyph cache. </p>
        /// </summary>
        /// <param name = "glyphOrigin"><dd>  <p>Origin of the glyph.</p> </dd></param>
        /// <param name = "fontFace"><dd>  <p>Reference to a font face which contains font face type, appropriate file references, face identification data and various font data such as metrics, names and glyph outlines.</p> </dd></param>
        /// <param name = "fontEmSize"><dd>  <p>The specified font size affects the output glyphTransform, causing it to properly scale the glyph.</p> </dd></param>
        /// <param name = "glyphIndex"><dd>  <p>Index of the glyph to retrieve.</p> </dd></param>
        /// <param name = "isSideways"><dd>  <p>If true, specifies that glyphs are rotated 90 degrees to the left and vertical metrics are used. Vertical writing is achieved by specifying isSideways as true and rotating the entire run 90 degrees to the right via a rotate transform.</p> </dd></param>
        /// <param name = "worldTransform"><dd>  <p>The transform to apply to the image.</p> </dd></param>
        /// <param name = "defaultFillBrush"><dd>  <p>Describes how the area is painted.</p> </dd></param>
        /// <param name = "svgGlyphStyle"><dd>  <p>The values for context-fill, context-stroke, and context-value that are used when rendering SVG glyphs.</p> </dd></param>
        /// <param name = "colorPaletteIndex"><dd>  <p>The index used to select a color palette within a color font.  Note that this not the same as the paletteIndex in the <see cref = "SharpDX.DirectWrite.ColorGlyphRun"/> struct, which is not relevant for SVG glyphs.</p> </dd></param>
        /// <param name = "glyphTransform"><dd>  <p>Output transform, which transforms from the glyph's space to the same output space as the worldTransform.  This includes the input glyphOrigin, the glyph's offset from the glyphOrigin, and any other required transformations.</p> </dd></param>
        /// <param name = "glyphImage"><dd>  <p>On completion, contains the retrieved glyph image.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code.</p></returns>
        /// <doc-id>mt750190</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext4::GetSvgGlyphImage([In] D2D_POINT_2F glyphOrigin,[In] IDWriteFontFace* fontFace,[In] float fontEmSize,[In] unsigned short glyphIndex,[In] BOOL isSideways,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In, Optional] ID2D1Brush* defaultFillBrush,[In, Optional] ID2D1SvgGlyphStyle* svgGlyphStyle,[In] unsigned int colorPaletteIndex,[Out] D2D_MATRIX_3X2_F* glyphTransform,[Out] ID2D1CommandList** glyphImage)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext4::GetSvgGlyphImage</unmanaged-short>
        public unsafe void GetSvgGlyphImage(SharpDX.Mathematics.Interop.RawVector2 glyphOrigin, SharpDX.DirectWrite.FontFace fontFace, System.Single fontEmSize, System.Int16 glyphIndex, SharpDX.Mathematics.Interop.RawBool isSideways, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, SharpDX.Direct2D1.Brush defaultFillBrush, SharpDX.Direct2D1.SvgGlyphStyle svgGlyphStyle, System.Int32 colorPaletteIndex, out SharpDX.Mathematics.Interop.RawMatrix3x2 glyphTransform, out SharpDX.Direct2D1.CommandList glyphImage)
        {
            System.IntPtr fontFace_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
            System.IntPtr defaultFillBrush_ = System.IntPtr.Zero;
            System.IntPtr svgGlyphStyle_ = System.IntPtr.Zero;
            glyphTransform = default (SharpDX.Mathematics.Interop.RawMatrix3x2);
            System.IntPtr glyphImage_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fontFace_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.FontFace>(fontFace);
            if (worldTransform != null)
                worldTransform_ = worldTransform.Value;
            defaultFillBrush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(defaultFillBrush);
            svgGlyphStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SvgGlyphStyle>(svgGlyphStyle);
            fixed (void *glyphTransform_ = &glyphTransform)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, glyphOrigin, (void *)fontFace_, fontEmSize, glyphIndex, isSideways, worldTransform == null ? (void *)0 : &worldTransform_, (void *)defaultFillBrush_, (void *)svgGlyphStyle_, colorPaletteIndex, glyphTransform_, &glyphImage_, (*(void ***)this._nativePointer)[114]);
            if (glyphImage_ != System.IntPtr.Zero)
                glyphImage = new SharpDX.Direct2D1.CommandList(glyphImage_);
            else
                glyphImage = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("7836d248-68cc-4df6-b9e8-de991bf62eb7")]
    public partial class DeviceContext5 : SharpDX.Direct2D1.DeviceContext4
    {
        public DeviceContext5(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceContext5(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceContext5(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "inputXmlStream">No documentation.</param>
        /// <param name = "viewportSize">No documentation.</param>
        /// <param name = "svgDocument">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1DeviceContext5::CreateSvgDocument([In, Optional] IStream* inputXmlStream,[In] D2D_SIZE_F viewportSize,[Out] ID2D1SvgDocument** svgDocument)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext5::CreateSvgDocument</unmanaged-short>
        public unsafe void CreateSvgDocument(SharpDX.Win32.IStream inputXmlStream, SharpDX.Size2F viewportSize, out SharpDX.Direct2D1.SvgDocument svgDocument)
        {
            System.IntPtr inputXmlStream_ = System.IntPtr.Zero;
            System.IntPtr svgDocument_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            inputXmlStream_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Win32.IStream>(inputXmlStream);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)inputXmlStream_, viewportSize, &svgDocument_, (*(void ***)this._nativePointer)[115]);
            if (svgDocument_ != System.IntPtr.Zero)
                svgDocument = new SharpDX.Direct2D1.SvgDocument(svgDocument_);
            else
                svgDocument = null;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "svgDocument">No documentation.</param>
        /// <unmanaged>void ID2D1DeviceContext5::DrawSvgDocument([In] ID2D1SvgDocument* svgDocument)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext5::DrawSvgDocument</unmanaged-short>
        public unsafe void DrawSvgDocument(SharpDX.Direct2D1.SvgDocument svgDocument)
        {
            System.IntPtr svgDocument_ = System.IntPtr.Zero;
            svgDocument_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SvgDocument>(svgDocument);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)svgDocument_, (*(void ***)this._nativePointer)[116]);
        }

        /// <summary>
        /// <p>Creates a color context from a DXGI color space type. It is only valid to use this with the Color Management Effect in 'Best' mode.</p>
        /// </summary>
        /// <param name = "colorSpace"><dd>  <p>The color space to create the color context from.</p> </dd></param>
        /// <param name = "colorContext"><dd>  <p>The created color context.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code.</p></returns>
        /// <doc-id>mt797807</doc-id>
        /// <unmanaged>HRESULT ID2D1DeviceContext5::CreateColorContextFromDxgiColorSpace([In] DXGI_COLOR_SPACE_TYPE colorSpace,[Out, Fast] ID2D1ColorContext1** colorContext)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext5::CreateColorContextFromDxgiColorSpace</unmanaged-short>
        public unsafe void CreateColorContextFromDxgiColorSpace(SharpDX.DXGI.ColorSpaceType colorSpace, SharpDX.Direct2D1.ColorContext1 colorContext)
        {
            System.IntPtr colorContext_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)colorSpace), &colorContext_, (*(void ***)this._nativePointer)[117]);
            (colorContext).NativePointer = colorContext_;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "simpleProfile">No documentation.</param>
        /// <param name = "colorContext">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1DeviceContext5::CreateColorContextFromSimpleColorProfile([In] const D2D1_SIMPLE_COLOR_PROFILE* simpleProfile,[Out, Fast] ID2D1ColorContext1** colorContext)</unmanaged>
        /// <unmanaged-short>ID2D1DeviceContext5::CreateColorContextFromSimpleColorProfile</unmanaged-short>
        public unsafe void CreateColorContextFromSimpleColorProfile(ref SharpDX.Direct2D1.SimpleColorProfile simpleProfile, SharpDX.Direct2D1.ColorContext1 colorContext)
        {
            System.IntPtr colorContext_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *simpleProfile_ = &simpleProfile)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, simpleProfile_, &colorContext_, (*(void ***)this._nativePointer)[118]);
            (colorContext).NativePointer = colorContext_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("1c51bc64-de61-46fd-9899-63a5d8f03950")]
    public partial class DeviceContextRenderTarget : SharpDX.Direct2D1.RenderTarget
    {
        public DeviceContextRenderTarget(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DeviceContextRenderTarget(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DeviceContextRenderTarget(nativePtr);
        /// <summary>
        /// <p> Binds the render target to the device context to which it issues drawing commands.</p>
        /// </summary>
        /// <param name = "hDC"><dd>  <p>The device context to which the render target issues drawing commands.</p> </dd></param>
        /// <param name = "subRectRef"><dd>  <p>The dimensions of the handle to a device context (<see cref = "System.IntPtr"/>) to which the render target is bound. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Before you can render with the DC render target, you must use its <strong>BindDC</strong> method to associate it with a GDI DC.  You do this each time you  use a different DC, or the size of the area you want to draw to changes.</p>
        /// </remarks>
        /// <doc-id>dd371214</doc-id>
        /// <unmanaged>HRESULT ID2D1DCRenderTarget::BindDC([In] const HDC hDC,[In] const RECT* pSubRect)</unmanaged>
        /// <unmanaged-short>ID2D1DCRenderTarget::BindDC</unmanaged-short>
        public unsafe void BindDeviceContext(System.IntPtr hDC, SharpDX.Mathematics.Interop.RawRectangle subRectRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)hDC, &subRectRef, (*(void ***)this._nativePointer)[57]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("693ce632-7f2f-45de-93fe-18d88b37aa21")]
    public partial class DrawInformation : SharpDX.Direct2D1.RenderInformation
    {
        public DrawInformation(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DrawInformation(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DrawInformation(nativePtr);
        /// <summary>
        /// <p>Sets the constant buffer for this transform's pixel shader.</p>
        /// </summary>
        /// <param name = "buffer"><dd>  <p>The data applied to the constant buffer.</p> </dd></param>
        /// <param name = "bufferCount"><dd>  <p>The number of bytes of data in the constant buffer</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh847988</doc-id>
        /// <unmanaged>HRESULT ID2D1DrawInfo::SetPixelShaderConstantBuffer([In, Buffer] const unsigned char* buffer,[In] unsigned int bufferCount)</unmanaged>
        /// <unmanaged-short>ID2D1DrawInfo::SetPixelShaderConstantBuffer</unmanaged-short>
        internal unsafe void SetPixelShaderConstantBuffer(System.IntPtr buffer, System.Int32 bufferCount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)buffer, bufferCount, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the resource texture corresponding to the given shader texture index.</p>
        /// </summary>
        /// <param name = "textureIndex"><dd>  <p>The index of the texture to be bound to the pixel shader.</p> </dd></param>
        /// <param name = "resourceTexture"><dd>  <p>The created resource texture.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh847989</doc-id>
        /// <unmanaged>HRESULT ID2D1DrawInfo::SetResourceTexture([In] unsigned int textureIndex,[In] ID2D1ResourceTexture* resourceTexture)</unmanaged>
        /// <unmanaged-short>ID2D1DrawInfo::SetResourceTexture</unmanaged-short>
        public unsafe void SetResourceTexture(System.Int32 textureIndex, SharpDX.Direct2D1.ResourceTexture resourceTexture)
        {
            System.IntPtr resourceTexture_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            resourceTexture_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.ResourceTexture>(resourceTexture);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, textureIndex, (void *)resourceTexture_, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the constant buffer for this transform's vertex shader.</p>
        /// </summary>
        /// <param name = "buffer"><dd>  <p>The data applied to the constant buffer</p> </dd></param>
        /// <param name = "bufferCount"><dd>  <p>The number of bytes of data in the constant buffer.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>hh847991</doc-id>
        /// <unmanaged>HRESULT ID2D1DrawInfo::SetVertexShaderConstantBuffer([In, Buffer] const unsigned char* buffer,[In] unsigned int bufferCount)</unmanaged>
        /// <unmanaged-short>ID2D1DrawInfo::SetVertexShaderConstantBuffer</unmanaged-short>
        internal unsafe void SetVertexShaderConstantBuffer(System.IntPtr buffer, System.Int32 bufferCount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)buffer, bufferCount, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Set the shader instructions for this transform.</p>
        /// </summary>
        /// <param name = "shaderId"><dd>  <p>The resource id for the  shader.</p> </dd></param>
        /// <param name = "pixelOptions"><dd>  <p>Additional information provided to the renderer to indicate the operations the pixel shader does.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> If this call fails, the corresponding <strong><see cref = "SharpDX.Direct2D1.Effect"/></strong> instance is placed into an error state and will fail to Draw, it will place the context into an error state which can be retrieved through the <strong>ID2D1DeviceContext::EndDraw</strong> call. </p><p>Specifying <em>pixelOptions</em> other than D2D1_PIXEL_OPTIONS_NONE can enable the renderer to perform certain optimizations such as combining various parts of the effect graph together. If this information does not accurately describe the shader, indeterminate rendering artifacts can result.
        /// </p>
        /// </remarks>
        /// <doc-id>hh847987</doc-id>
        /// <unmanaged>HRESULT ID2D1DrawInfo::SetPixelShader([In] const GUID&amp; shaderId,[In] D2D1_PIXEL_OPTIONS pixelOptions)</unmanaged>
        /// <unmanaged-short>ID2D1DrawInfo::SetPixelShader</unmanaged-short>
        public unsafe void SetPixelShader(System.Guid shaderId, SharpDX.Direct2D1.PixelOptions pixelOptions)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &shaderId, unchecked ((System.Int32)pixelOptions), (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets a vertex buffer, a corresponding vertex shader, and options to control how the vertices are to be handled by the Direct2D context.</p>
        /// </summary>
        /// <param name = "vertexBuffer"><dd>  <p>The vertex buffer, if this is cleared, the default vertex shader and mapping to the transform rectangles will be used.</p> </dd></param>
        /// <param name = "vertexOptions"><dd>  <p>Options that influence how the renderer will interact with the vertex shader.</p> </dd></param>
        /// <param name = "blendDescription"><dd>  <p>How the vertices will be blended with the output texture.</p> </dd></param>
        /// <param name = "vertexRange"><dd>  <p>The set of vertices to use from the buffer.</p> </dd></param>
        /// <param name = "vertexShader"><dd>  <p>The <see cref = "System.Guid"/> of the vertex shader.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The vertex shaders associated with the vertex buffer through the vertex shader <see cref = "System.Guid"/> must have been loaded through the <strong>ID2D1EffectContext::LoadVertexShader</strong> method before this call is made.</p><p>If you pass the vertex option <strong>D2D1_VERTEX_OPTIONS_DO_NOT_CLEAR</strong>, then the method fails unless the blend description is exactly this: </p><pre><see cref = "SharpDX.Direct2D1.BlendDescription"/> blendDesc =  { D2D1_BLEND_ONE, D2D1_BLEND_ZERO, D2D1_BLEND_OPERATION_ADD, D2D1_BLEND_ONE, D2D1_BLEND_ZERO, D2D1_BLEND_OPERATION_ADD, { 1.0f, 1.0f, 1.0f, 1.0f } };</pre><p>If this call fails, the corresponding <strong><see cref = "SharpDX.Direct2D1.Effect"/></strong> instance is placed into an error state and fails to draw.</p><p> If blendDescription is <c>null</c>, a foreground-over blend mode is used.</p>
        /// </remarks>
        /// <doc-id>hh847990</doc-id>
        /// <unmanaged>HRESULT ID2D1DrawInfo::SetVertexProcessing([In, Optional] ID2D1VertexBuffer* vertexBuffer,[In] D2D1_VERTEX_OPTIONS vertexOptions,[In, Optional] const D2D1_BLEND_DESCRIPTION* blendDescription,[In, Optional] const D2D1_VERTEX_RANGE* vertexRange,[In, Optional] const GUID* vertexShader)</unmanaged>
        /// <unmanaged-short>ID2D1DrawInfo::SetVertexProcessing</unmanaged-short>
        public unsafe void SetVertexProcessing(SharpDX.Direct2D1.VertexBuffer vertexBuffer, SharpDX.Direct2D1.VertexOptions vertexOptions, SharpDX.Direct2D1.BlendDescription? blendDescription = null, SharpDX.Direct2D1.VertexRange? vertexRange = null, System.Guid? vertexShader = null)
        {
            System.IntPtr vertexBuffer_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.BlendDescription blendDescription_;
            SharpDX.Direct2D1.VertexRange vertexRange_;
            System.Guid vertexShader_;
            SharpDX.Result __result__;
            vertexBuffer_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.VertexBuffer>(vertexBuffer);
            if (blendDescription != null)
                blendDescription_ = blendDescription.Value;
            if (vertexRange != null)
                vertexRange_ = vertexRange.Value;
            if (vertexShader != null)
                vertexShader_ = vertexShader.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)vertexBuffer_, unchecked ((System.Int32)vertexOptions), blendDescription == null ? (void *)0 : &blendDescription_, vertexRange == null ? (void *)0 : &vertexRange_, vertexShader == null ? (void *)0 : &vertexShader_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("28506e39-ebf6-46a1-bb47-fd85565ab957")]
    public partial class DrawingStateBlock : SharpDX.Direct2D1.Resource
    {
        public DrawingStateBlock(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DrawingStateBlock(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DrawingStateBlock(nativePtr);
        /// <summary>
        /// <p>Retrieves or sets the antialiasing mode, transform, and tags portion of the drawing state.</p>
        /// </summary>
        /// <doc-id>dd371223</doc-id>
        /// <unmanaged>GetDescription / SetDescription</unmanaged>
        /// <unmanaged-short>GetDescription</unmanaged-short>
        public SharpDX.Direct2D1.DrawingStateDescription Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }

            set => SetDescription(ref value);
        }

        /// <summary>
        /// <p>Retrieves or sets the text-rendering configuration of the drawing state.</p>
        /// </summary>
        /// <doc-id>dd371227</doc-id>
        /// <unmanaged>GetTextRenderingParams / SetTextRenderingParams</unmanaged>
        /// <unmanaged-short>GetTextRenderingParams</unmanaged-short>
        public SharpDX.DirectWrite.RenderingParams TextRenderingParams
        {
            get
            {
                GetTextRenderingParams(out var __output__);
                return __output__;
            }

            set => SetTextRenderingParams(value);
        }

        /// <summary>
        /// <p>Retrieves the antialiasing mode, transform, and tags portion of the drawing state.</p>
        /// </summary>
        /// <param name = "stateDescription"><dd>  <p>When this method returns, contains the antialiasing mode, transform, and tags portion of the drawing state. You must allocate storage for this parameter.</p> </dd></param>
        /// <doc-id>dd371223</doc-id>
        /// <unmanaged>void ID2D1DrawingStateBlock::GetDescription([Out] D2D1_DRAWING_STATE_DESCRIPTION* stateDescription)</unmanaged>
        /// <unmanaged-short>ID2D1DrawingStateBlock::GetDescription</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct2D1.DrawingStateDescription stateDescription)
        {
            stateDescription = default (SharpDX.Direct2D1.DrawingStateDescription);
            fixed (void *stateDescription_ = &stateDescription)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, stateDescription_, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p>Specifies the antialiasing mode, transform, and tags portion of the drawing state.</p>
        /// </summary>
        /// <param name = "stateDescription"><dd>  <p>The antialiasing mode, transform, and tags portion of the drawing state.</p> </dd></param>
        /// <doc-id>dd371231</doc-id>
        /// <unmanaged>void ID2D1DrawingStateBlock::SetDescription([In] const D2D1_DRAWING_STATE_DESCRIPTION* stateDescription)</unmanaged>
        /// <unmanaged-short>ID2D1DrawingStateBlock::SetDescription</unmanaged-short>
        internal unsafe void SetDescription(ref SharpDX.Direct2D1.DrawingStateDescription stateDescription)
        {
            fixed (void *stateDescription_ = &stateDescription)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, stateDescription_, (*(void ***)this._nativePointer)[5]);
        }

        /// <summary>
        /// <p>Specifies the text-rendering configuration of the drawing state.</p>
        /// </summary>
        /// <param name = "textRenderingParams"><dd>  <p>The text-rendering configuration of the drawing state, or <c>null</c> to use default settings.</p> </dd></param>
        /// <doc-id>dd371237</doc-id>
        /// <unmanaged>void ID2D1DrawingStateBlock::SetTextRenderingParams([In, Optional] IDWriteRenderingParams* textRenderingParams)</unmanaged>
        /// <unmanaged-short>ID2D1DrawingStateBlock::SetTextRenderingParams</unmanaged-short>
        internal unsafe void SetTextRenderingParams(SharpDX.DirectWrite.RenderingParams textRenderingParams)
        {
            System.IntPtr textRenderingParams_ = System.IntPtr.Zero;
            textRenderingParams_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.RenderingParams>(textRenderingParams);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)textRenderingParams_, (*(void ***)this._nativePointer)[6]);
        }

        /// <summary>
        /// <p>Retrieves the text-rendering configuration of the drawing state.</p>
        /// </summary>
        /// <param name = "textRenderingParams"><dd>  <p>When this method returns, contains the address of a reference to an <strong><see cref = "SharpDX.DirectWrite.RenderingParams"/></strong> object that describes the text-rendering configuration of the drawing state.</p> </dd></param>
        /// <doc-id>dd371227</doc-id>
        /// <unmanaged>void ID2D1DrawingStateBlock::GetTextRenderingParams([Out, Optional] IDWriteRenderingParams** textRenderingParams)</unmanaged>
        /// <unmanaged-short>ID2D1DrawingStateBlock::GetTextRenderingParams</unmanaged-short>
        internal unsafe void GetTextRenderingParams(out SharpDX.DirectWrite.RenderingParams textRenderingParams)
        {
            System.IntPtr textRenderingParams_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &textRenderingParams_, (*(void ***)this._nativePointer)[7]);
            if (textRenderingParams_ != System.IntPtr.Zero)
                textRenderingParams = new SharpDX.DirectWrite.RenderingParams(textRenderingParams_);
            else
                textRenderingParams = null;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("689f1f85-c72e-4e33-8f19-85754efd5ace")]
    public partial class DrawingStateBlock1 : SharpDX.Direct2D1.DrawingStateBlock
    {
        public DrawingStateBlock1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DrawingStateBlock1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DrawingStateBlock1(nativePtr);
        /// <summary>
        /// <p>Gets or sets the antialiasing mode, transform, tags, primitive blend, and unit mode portion of the drawing state.</p>
        /// </summary>
        /// <doc-id>hh871453</doc-id>
        /// <unmanaged>GetDescription / SetDescription</unmanaged>
        /// <unmanaged-short>GetDescription</unmanaged-short>
        public SharpDX.Direct2D1.DrawingStateDescription1 Description
        {
            get
            {
                GetDescription(out var __output__);
                return __output__;
            }

            set => SetDescription(ref value);
        }

        /// <summary>
        /// <p>Gets the antialiasing mode, transform, tags, primitive blend, and unit mode portion of the drawing state.</p>
        /// </summary>
        /// <param name = "stateDescription"><dd>  <p>When this method returns, contains the antialiasing mode, transform, tags, primitive blend, and unit mode portion of the drawing state. You must allocate storage for this parameter.</p> </dd></param>
        /// <doc-id>hh871453</doc-id>
        /// <unmanaged>void ID2D1DrawingStateBlock1::GetDescription([Out] D2D1_DRAWING_STATE_DESCRIPTION1* stateDescription)</unmanaged>
        /// <unmanaged-short>ID2D1DrawingStateBlock1::GetDescription</unmanaged-short>
        internal unsafe void GetDescription(out SharpDX.Direct2D1.DrawingStateDescription1 stateDescription)
        {
            stateDescription = default (SharpDX.Direct2D1.DrawingStateDescription1);
            fixed (void *stateDescription_ = &stateDescription)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, stateDescription_, (*(void ***)this._nativePointer)[8]);
        }

        /// <summary>
        /// <p>Sets the <strong><see cref = "SharpDX.Direct2D1.DrawingStateDescription1"/></strong> associated with this drawing state block.</p>
        /// </summary>
        /// <param name = "stateDescription">No documentation.</param>
        /// <doc-id>hh871454</doc-id>
        /// <unmanaged>void ID2D1DrawingStateBlock1::SetDescription([In] const D2D1_DRAWING_STATE_DESCRIPTION1* stateDescription)</unmanaged>
        /// <unmanaged-short>ID2D1DrawingStateBlock1::SetDescription</unmanaged-short>
        internal unsafe void SetDescription(ref SharpDX.Direct2D1.DrawingStateDescription1 stateDescription)
        {
            fixed (void *stateDescription_ = &stateDescription)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, stateDescription_, (*(void ***)this._nativePointer)[9]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("36bfdcb6-9739-435d-a30d-a653beff6a6f")]
    public partial interface DrawTransform : SharpDX.Direct2D1.Transform
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("36bfdcb6-9739-435d-a30d-a653beff6a6f")]
    public partial class DrawTransformNative : SharpDX.Direct2D1.TransformNative, SharpDX.Direct2D1.DrawTransform
    {
        public DrawTransformNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator DrawTransformNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new DrawTransformNative(nativePtr);
        /// <summary>
        /// <p> Provides the GPU render info interface to the transform implementation.</p>
        /// </summary>
        /// <remarks>
        /// <p>The transform can maintain a  reference to this interface for its lifetime. If any properties change on the transform, it can apply these changes to the corresponding <em>drawInfo</em> interface. </p><p>This is also used to determine that the corresponding nodes in the graph are dirty.</p>
        /// </remarks>
        /// <doc-id>hh847993</doc-id>
        /// <unmanaged>SetDrawInfo</unmanaged>
        /// <unmanaged-short>SetDrawInfo</unmanaged-short>
        public SharpDX.Direct2D1.DrawInformation DrawInfo_
        {
            set => SetDrawInfo_(value);
        }

        /// <summary>
        /// <p> Provides the GPU render info interface to the transform implementation.</p>
        /// </summary>
        /// <param name = "drawInfo"><dd>  <p>The interface supplied back to the calling method to allow it to specify the GPU based transform pass.</p> </dd></param>
        /// <returns><p>Any <see cref = "SharpDX.Result"/> value can be returned when implementing this method. A failure will be returned from the corresponding <strong>ID2D1DeviceContext::EndDraw</strong> call.</p></returns>
        /// <remarks>
        /// <p>The transform can maintain a  reference to this interface for its lifetime. If any properties change on the transform, it can apply these changes to the corresponding <em>drawInfo</em> interface. </p><p>This is also used to determine that the corresponding nodes in the graph are dirty.</p>
        /// </remarks>
        /// <doc-id>hh847993</doc-id>
        /// <unmanaged>HRESULT ID2D1DrawTransform::SetDrawInfo([In] ID2D1DrawInfo* drawInfo)</unmanaged>
        /// <unmanaged-short>ID2D1DrawTransform::SetDrawInfo</unmanaged-short>
        internal unsafe void SetDrawInfo_(SharpDX.Direct2D1.DrawInformation drawInfo)
        {
            System.IntPtr drawInfo_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            drawInfo_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.DrawInformation>(drawInfo);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)drawInfo_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("28211a43-7d89-476f-8181-2d6159b220ad")]
    public partial class Effect : SharpDX.Direct2D1.Properties
    {
        public Effect(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Effect(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Effect(nativePtr);
                ///<summary>Constant ArithmeticComposite</summary>
        ///<unmanaged>CLSID_D2D1ArithmeticComposite</unmanaged>
        public static readonly System.Guid ArithmeticComposite = new System.Guid("fc151437-049a-4784-a24a-f1c4daf20987");
                ///<summary>Constant Atlas</summary>
        ///<unmanaged>CLSID_D2D1Atlas</unmanaged>
        public static readonly System.Guid Atlas = new System.Guid("913e2be4-fdcf-4fe2-a5f0-2454f14ff408");
                ///<summary>Constant BitmapSource</summary>
        ///<unmanaged>CLSID_D2D1BitmapSource</unmanaged>
        public static readonly System.Guid BitmapSource = new System.Guid("5fb6c24d-c6dd-4231-9404-50f4d5c3252d");
                ///<summary>Constant Blend</summary>
        ///<unmanaged>CLSID_D2D1Blend</unmanaged>
        public static readonly System.Guid Blend = new System.Guid("81c5b77b-13f8-4cdd-ad20-c890547ac65d");
                ///<summary>Constant Border</summary>
        ///<unmanaged>CLSID_D2D1Border</unmanaged>
        public static readonly System.Guid Border = new System.Guid("2a2d49c0-4acf-43c7-8c6a-7c4a27874d27");
                ///<summary>Constant Brightness</summary>
        ///<unmanaged>CLSID_D2D1Brightness</unmanaged>
        public static readonly System.Guid Brightness = new System.Guid("8cea8d1e-77b0-4986-b3b9-2f0c0eae7887");
                ///<summary>Constant ColorManagement</summary>
        ///<unmanaged>CLSID_D2D1ColorManagement</unmanaged>
        public static readonly System.Guid ColorManagement = new System.Guid("1a28524c-fdd6-4aa4-ae8f-837eb8267b37");
                ///<summary>Constant ColorMatrix</summary>
        ///<unmanaged>CLSID_D2D1ColorMatrix</unmanaged>
        public static readonly System.Guid ColorMatrix = new System.Guid("921f03d6-641c-47df-852d-b4bb6153ae11");
                ///<summary>Constant Composite</summary>
        ///<unmanaged>CLSID_D2D1Composite</unmanaged>
        public static readonly System.Guid Composite = new System.Guid("48fc9f51-f6ac-48f1-8b58-3b28ac46f76d");
                ///<summary>Constant ConvolveMatrix</summary>
        ///<unmanaged>CLSID_D2D1ConvolveMatrix</unmanaged>
        public static readonly System.Guid ConvolveMatrix = new System.Guid("407f8c08-5533-4331-a341-23cc3877843e");
                ///<summary>Constant Crop</summary>
        ///<unmanaged>CLSID_D2D1Crop</unmanaged>
        public static readonly System.Guid Crop = new System.Guid("e23f7110-0e9a-4324-af47-6a2c0c46f35b");
                ///<summary>Constant DirectionalBlur</summary>
        ///<unmanaged>CLSID_D2D1DirectionalBlur</unmanaged>
        public static readonly System.Guid DirectionalBlur = new System.Guid("174319a6-58e9-49b2-bb63-caf2c811a3db");
                ///<summary>Constant DiscreteTransfer</summary>
        ///<unmanaged>CLSID_D2D1DiscreteTransfer</unmanaged>
        public static readonly System.Guid DiscreteTransfer = new System.Guid("90866fcd-488e-454b-af06-e5041b66c36c");
                ///<summary>Constant DisplacementMap</summary>
        ///<unmanaged>CLSID_D2D1DisplacementMap</unmanaged>
        public static readonly System.Guid DisplacementMap = new System.Guid("edc48364-0417-4111-9450-43845fa9f890");
                ///<summary>Constant DistantDiffuse</summary>
        ///<unmanaged>CLSID_D2D1DistantDiffuse</unmanaged>
        public static readonly System.Guid DistantDiffuse = new System.Guid("3e7efd62-a32d-46d4-a83c-5278889ac954");
                ///<summary>Constant DistantSpecular</summary>
        ///<unmanaged>CLSID_D2D1DistantSpecular</unmanaged>
        public static readonly System.Guid DistantSpecular = new System.Guid("428c1ee5-77b8-4450-8ab5-72219c21abda");
                ///<summary>Constant DpiCompensation</summary>
        ///<unmanaged>CLSID_D2D1DpiCompensation</unmanaged>
        public static readonly System.Guid DpiCompensation = new System.Guid("6c26c5c7-34e0-46fc-9cfd-e5823706e228");
                ///<summary>Constant Flood</summary>
        ///<unmanaged>CLSID_D2D1Flood</unmanaged>
        public static readonly System.Guid Flood = new System.Guid("61c23c20-ae69-4d8e-94cf-50078df638f2");
                ///<summary>Constant GammaTransfer</summary>
        ///<unmanaged>CLSID_D2D1GammaTransfer</unmanaged>
        public static readonly System.Guid GammaTransfer = new System.Guid("409444c4-c419-41a0-b0c1-8cd0c0a18e42");
                ///<summary>Constant GaussianBlur</summary>
        ///<unmanaged>CLSID_D2D1GaussianBlur</unmanaged>
        public static readonly System.Guid GaussianBlur = new System.Guid("1feb6d69-2fe6-4ac9-8c58-1d7f93e7a6a5");
                ///<summary>Constant Scale</summary>
        ///<unmanaged>CLSID_D2D1Scale</unmanaged>
        public static readonly System.Guid Scale = new System.Guid("9daf9369-3846-4d0e-a44e-0c607934a5d7");
                ///<summary>Constant Histogram</summary>
        ///<unmanaged>CLSID_D2D1Histogram</unmanaged>
        public static readonly System.Guid Histogram = new System.Guid("881db7d0-f7ee-4d4d-a6d2-4697acc66ee8");
                ///<summary>Constant HueRotation</summary>
        ///<unmanaged>CLSID_D2D1HueRotation</unmanaged>
        public static readonly System.Guid HueRotation = new System.Guid("0f4458ec-4b32-491b-9e85-bd73f44d3eb6");
                ///<summary>Constant LinearTransfer</summary>
        ///<unmanaged>CLSID_D2D1LinearTransfer</unmanaged>
        public static readonly System.Guid LinearTransfer = new System.Guid("ad47c8fd-63ef-4acc-9b51-67979c036c06");
                ///<summary>Constant LuminanceToAlpha</summary>
        ///<unmanaged>CLSID_D2D1LuminanceToAlpha</unmanaged>
        public static readonly System.Guid LuminanceToAlpha = new System.Guid("41251ab7-0beb-46f8-9da7-59e93fcce5de");
                ///<summary>Constant Morphology</summary>
        ///<unmanaged>CLSID_D2D1Morphology</unmanaged>
        public static readonly System.Guid Morphology = new System.Guid("eae6c40d-626a-4c2d-bfcb-391001abe202");
                ///<summary>Constant OpacityMetadata</summary>
        ///<unmanaged>CLSID_D2D1OpacityMetadata</unmanaged>
        public static readonly System.Guid OpacityMetadata = new System.Guid("6c53006a-4450-4199-aa5b-ad1656fece5e");
                ///<summary>Constant PointDiffuse</summary>
        ///<unmanaged>CLSID_D2D1PointDiffuse</unmanaged>
        public static readonly System.Guid PointDiffuse = new System.Guid("b9e303c3-c08c-4f91-8b7b-38656bc48c20");
                ///<summary>Constant PointSpecular</summary>
        ///<unmanaged>CLSID_D2D1PointSpecular</unmanaged>
        public static readonly System.Guid PointSpecular = new System.Guid("09c3ca26-3ae2-4f09-9ebc-ed3865d53f22");
                ///<summary>Constant Premultiply</summary>
        ///<unmanaged>CLSID_D2D1Premultiply</unmanaged>
        public static readonly System.Guid Premultiply = new System.Guid("06eab419-deed-4018-80d2-3e1d471adeb2");
                ///<summary>Constant Saturation</summary>
        ///<unmanaged>CLSID_D2D1Saturation</unmanaged>
        public static readonly System.Guid Saturation = new System.Guid("5cb2d9cf-327d-459f-a0ce-40c0b2086bf7");
                ///<summary>Constant Shadow</summary>
        ///<unmanaged>CLSID_D2D1Shadow</unmanaged>
        public static readonly System.Guid Shadow = new System.Guid("c67ea361-1863-4e69-89db-695d3e9a5b6b");
                ///<summary>Constant SpotDiffuse</summary>
        ///<unmanaged>CLSID_D2D1SpotDiffuse</unmanaged>
        public static readonly System.Guid SpotDiffuse = new System.Guid("818a1105-7932-44f4-aa86-08ae7b2f2c93");
                ///<summary>Constant SpotSpecular</summary>
        ///<unmanaged>CLSID_D2D1SpotSpecular</unmanaged>
        public static readonly System.Guid SpotSpecular = new System.Guid("edae421e-7654-4a37-9db8-71acc1beb3c1");
                ///<summary>Constant TableTransfer</summary>
        ///<unmanaged>CLSID_D2D1TableTransfer</unmanaged>
        public static readonly System.Guid TableTransfer = new System.Guid("5bf818c3-5e43-48cb-b631-868396d6a1d4");
                ///<summary>Constant Tile</summary>
        ///<unmanaged>CLSID_D2D1Tile</unmanaged>
        public static readonly System.Guid Tile = new System.Guid("b0784138-3b76-4bc5-b13b-0fa2ad02659f");
                ///<summary>Constant Turbulence</summary>
        ///<unmanaged>CLSID_D2D1Turbulence</unmanaged>
        public static readonly System.Guid Turbulence = new System.Guid("cf2bb6ae-889a-4ad7-ba29-a2fd732c9fc9");
                ///<summary>Constant UnPremultiply</summary>
        ///<unmanaged>CLSID_D2D1UnPremultiply</unmanaged>
        public static readonly System.Guid UnPremultiply = new System.Guid("fb9ac489-ad8d-41ed-9999-bb6347d110f7");
                ///<summary>Constant YCbCr</summary>
        ///<unmanaged>CLSID_D2D1YCbCr</unmanaged>
        public static readonly System.Guid YCbCr = new System.Guid("99503cc1-66c7-45c9-a875-8ad8a7914401");
                ///<summary>Constant Contrast</summary>
        ///<unmanaged>CLSID_D2D1Contrast</unmanaged>
        public static readonly System.Guid Contrast = new System.Guid("b648a78a-0ed5-4f80-a94a-8e825aca6b77");
                ///<summary>Constant RgbToHue</summary>
        ///<unmanaged>CLSID_D2D1RgbToHue</unmanaged>
        public static readonly System.Guid RgbToHue = new System.Guid("23f3e5ec-91e8-4d3d-ad0a-afadc1004aa1");
                ///<summary>Constant HueToRgb</summary>
        ///<unmanaged>CLSID_D2D1HueToRgb</unmanaged>
        public static readonly System.Guid HueToRgb = new System.Guid("7b78a6bd-0141-4def-8a52-6356ee0cbdd5");
                ///<summary>Constant ChromaKey</summary>
        ///<unmanaged>CLSID_D2D1ChromaKey</unmanaged>
        public static readonly System.Guid ChromaKey = new System.Guid("74c01f5b-2a0d-408c-88e2-c7a3c7197742");
                ///<summary>Constant Emboss</summary>
        ///<unmanaged>CLSID_D2D1Emboss</unmanaged>
        public static readonly System.Guid Emboss = new System.Guid("b1c5eb2b-0348-43f0-8107-4957cacba2ae");
                ///<summary>Constant Exposure</summary>
        ///<unmanaged>CLSID_D2D1Exposure</unmanaged>
        public static readonly System.Guid Exposure = new System.Guid("b56c8cfa-f634-41ee-bee0-ffa617106004");
                ///<summary>Constant Grayscale</summary>
        ///<unmanaged>CLSID_D2D1Grayscale</unmanaged>
        public static readonly System.Guid Grayscale = new System.Guid("36dde0eb-3725-42e0-836d-52fb20aee644");
                ///<summary>Constant Invert</summary>
        ///<unmanaged>CLSID_D2D1Invert</unmanaged>
        public static readonly System.Guid Invert = new System.Guid("e0c3784d-cb39-4e84-b6fd-6b72f0810263");
                ///<summary>Constant Posterize</summary>
        ///<unmanaged>CLSID_D2D1Posterize</unmanaged>
        public static readonly System.Guid Posterize = new System.Guid("2188945e-33a3-4366-b7bc-086bd02d0884");
                ///<summary>Constant Sepia</summary>
        ///<unmanaged>CLSID_D2D1Sepia</unmanaged>
        public static readonly System.Guid Sepia = new System.Guid("3a1af410-5f1d-4dbe-84df-915da79b7153");
                ///<summary>Constant Sharpen</summary>
        ///<unmanaged>CLSID_D2D1Sharpen</unmanaged>
        public static readonly System.Guid Sharpen = new System.Guid("c9b887cb-c5ff-4dc5-9779-273dcf417c7d");
                ///<summary>Constant Straighten</summary>
        ///<unmanaged>CLSID_D2D1Straighten</unmanaged>
        public static readonly System.Guid Straighten = new System.Guid("4da47b12-79a3-4fb0-8237-bbc3b2a4de08");
                ///<summary>Constant TemperatureTint</summary>
        ///<unmanaged>CLSID_D2D1TemperatureTint</unmanaged>
        public static readonly System.Guid TemperatureTint = new System.Guid("89176087-8af9-4a08-aeb1-895f38db1766");
                ///<summary>Constant Vignette</summary>
        ///<unmanaged>CLSID_D2D1Vignette</unmanaged>
        public static readonly System.Guid Vignette = new System.Guid("c00c40be-5e67-4ca3-95b4-f4b02c115135");
                ///<summary>Constant EdgeDetection</summary>
        ///<unmanaged>CLSID_D2D1EdgeDetection</unmanaged>
        public static readonly System.Guid EdgeDetection = new System.Guid("eff583ca-cb07-4aa9-ac5d-2cc44c76460f");
                ///<summary>Constant HighlightsShadows</summary>
        ///<unmanaged>CLSID_D2D1HighlightsShadows</unmanaged>
        public static readonly System.Guid HighlightsShadows = new System.Guid("cadc8384-323f-4c7e-a361-2e2b24df6ee4");
                ///<summary>Constant LookupTable3D</summary>
        ///<unmanaged>CLSID_D2D1LookupTable3D</unmanaged>
        public static readonly System.Guid LookupTable3D = new System.Guid("349e0eda-0088-4a79-9ca3-c7e300202020");
                ///<summary>Constant Opacity</summary>
        ///<unmanaged>CLSID_D2D1Opacity</unmanaged>
        public static readonly System.Guid Opacity = new System.Guid("811d79a4-de28-4454-8094-c64685f8bd4c");
                ///<summary>Constant AlphaMask</summary>
        ///<unmanaged>CLSID_D2D1AlphaMask</unmanaged>
        public static readonly System.Guid AlphaMask = new System.Guid("c80ecff0-3fd5-4f05-8328-c5d1724b4f0a");
                ///<summary>Constant CrossFade</summary>
        ///<unmanaged>CLSID_D2D1CrossFade</unmanaged>
        public static readonly System.Guid CrossFade = new System.Guid("12f575e8-4db1-485f-9a84-03a07dd3829f");
                ///<summary>Constant Tint</summary>
        ///<unmanaged>CLSID_D2D1Tint</unmanaged>
        public static readonly System.Guid Tint = new System.Guid("36312b17-f7dd-4014-915d-ffca768cf211");
                ///<summary>Constant AffineTransform2D</summary>
        ///<unmanaged>CLSID_D2D12DAffineTransform</unmanaged>
        public static readonly System.Guid AffineTransform2D = new System.Guid("6aa97485-6354-4cfc-908c-e4a74f62c96c");
                ///<summary>Constant PerspectiveTransform3D</summary>
        ///<unmanaged>CLSID_D2D13DPerspectiveTransform</unmanaged>
        public static readonly System.Guid PerspectiveTransform3D = new System.Guid("c2844d0b-3d86-46e7-85ba-526c9240f3fb");
                ///<summary>Constant Transform3D</summary>
        ///<unmanaged>CLSID_D2D13DTransform</unmanaged>
        public static readonly System.Guid Transform3D = new System.Guid("e8467b04-ec61-4b8a-b5de-d4d73debea5a");
        /// <summary>
        /// <p>Gets or sets the number of inputs to the effect. </p>
        /// </summary>
        /// <doc-id>hh404582</doc-id>
        /// <unmanaged>GetInputCount / SetInputCount</unmanaged>
        /// <unmanaged-short>GetInputCount</unmanaged-short>
        public System.Int32 InputCount
        {
            get => GetInputCount();
            set => SetInputCount(value);
        }

        /// <summary>
        /// <p>Gets the output image from the effect. </p>
        /// </summary>
        /// <remarks>
        /// <p>The output image  can be set as an input to another effect, or can be directly passed into the <strong><see cref = "SharpDX.Direct2D1.DeviceContext"/></strong> in order to render the effect. </p><p>It is  also possible to use <strong>QueryInterface</strong> to retrieve the same output image.</p>
        /// </remarks>
        /// <doc-id>hh404585</doc-id>
        /// <unmanaged>GetOutput</unmanaged>
        /// <unmanaged-short>GetOutput</unmanaged-short>
        public SharpDX.Direct2D1.Image Output
        {
            get
            {
                GetOutput(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Sets the given input image by index. </p>
        /// </summary>
        /// <param name = "index"><dd>  <p>The index of the image to set.</p> </dd></param>
        /// <param name = "input"><dd>  <p>The input image to set.</p> </dd></param>
        /// <param name = "invalidate"><dd>  <p>Whether to invalidate the graph at the location of the effect input</p> </dd></param>
        /// <remarks>
        /// <p>If the input index is out of range, the input image is ignored. </p>
        /// </remarks>
        /// <doc-id>hh404591</doc-id>
        /// <unmanaged>void ID2D1Effect::SetInput([In] unsigned int index,[In, Optional] ID2D1Image* input,[In] BOOL invalidate)</unmanaged>
        /// <unmanaged-short>ID2D1Effect::SetInput</unmanaged-short>
        public unsafe void SetInput(System.Int32 index, SharpDX.Direct2D1.Image input, SharpDX.Mathematics.Interop.RawBool invalidate)
        {
            System.IntPtr input_ = System.IntPtr.Zero;
            input_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Image>(input);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, index, (void *)input_, invalidate, (*(void ***)this._nativePointer)[14]);
        }

        /// <summary>
        /// <p>Allows the application to change the number of inputs to an effect.</p>
        /// </summary>
        /// <param name = "inputCount"><dd>  <p>The number of inputs to the effect.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are invalid.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Failed to allocate necessary memory.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>Most effects do not support a variable number of inputs. Use <strong>ID2D1Properties::GetValue</strong> with the <strong>D2D1_PROPERTY_MIN_INPUTS</strong> and <strong>D2D1_PROPERTY_MAX_INPUTS</strong> values to determine the number of inputs supported by an effect.</p><p>If the input count is less than the minimum or more than the maximum supported inputs, the call will fail.</p><p>If the input count is unchanged, the call will succeed with <strong><see cref = "SharpDX.Result.Ok"/></strong>. </p><p>Any inputs currently selected on the effect will be unaltered by this call unless the number of inputs is made smaller. If the number of inputs is made smaller, inputs beyond the selected range will be released.</p><p>If the method fails, the existing input and input count will remain unchanged.</p>
        /// </remarks>
        /// <doc-id>hh404594</doc-id>
        /// <unmanaged>HRESULT ID2D1Effect::SetInputCount([In] unsigned int inputCount)</unmanaged>
        /// <unmanaged-short>ID2D1Effect::SetInputCount</unmanaged-short>
        internal unsafe void SetInputCount(System.Int32 inputCount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, inputCount, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Represents a basic image-processing construct in Direct2D.</p>
        /// </summary>
        /// <param name = "index">No documentation.</param>
        /// <remarks>
        /// <p>An effect takes zero or more input images, and has an output image. The images that are input into and output from an effect are lazily evaluated. This definition is sufficient to allow an arbitrary graph of effects to be created from the application by feeding output images into the input image of the next effect in the chain.</p>
        /// </remarks>
        /// <doc-id>hh404566</doc-id>
        /// <unmanaged>void ID2D1Effect::GetInput([In] unsigned int index,[Out, Optional] ID2D1Image** input)</unmanaged>
        /// <unmanaged-short>ID2D1Effect::GetInput</unmanaged-short>
        public unsafe SharpDX.Direct2D1.Image GetInput(System.Int32 index)
        {
            SharpDX.Direct2D1.Image input;
            System.IntPtr input_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, index, &input_, (*(void ***)this._nativePointer)[16]);
            if (input_ != System.IntPtr.Zero)
                input = new SharpDX.Direct2D1.Image(input_);
            else
                input = null;
            return input;
        }

        /// <summary>
        /// <p>Gets the number of inputs to the effect. </p>
        /// </summary>
        /// <returns><p>This method returns the number of inputs to the effect. </p></returns>
        /// <doc-id>hh404582</doc-id>
        /// <unmanaged>unsigned int ID2D1Effect::GetInputCount()</unmanaged>
        /// <unmanaged-short>ID2D1Effect::GetInputCount</unmanaged-short>
        internal unsafe System.Int32 GetInputCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[17]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the output image from the effect. </p>
        /// </summary>
        /// <param name = "outputImage"><dd>  <p>When this method returns, contains the address of a reference to the output image for the effect.</p> </dd></param>
        /// <remarks>
        /// <p>The output image  can be set as an input to another effect, or can be directly passed into the <strong><see cref = "SharpDX.Direct2D1.DeviceContext"/></strong> in order to render the effect. </p><p>It is  also possible to use <strong>QueryInterface</strong> to retrieve the same output image.</p>
        /// </remarks>
        /// <doc-id>hh404585</doc-id>
        /// <unmanaged>void ID2D1Effect::GetOutput([Out] ID2D1Image** outputImage)</unmanaged>
        /// <unmanaged-short>ID2D1Effect::GetOutput</unmanaged-short>
        internal unsafe void GetOutput(out SharpDX.Direct2D1.Image outputImage)
        {
            System.IntPtr outputImage_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &outputImage_, (*(void ***)this._nativePointer)[18]);
            if (outputImage_ != System.IntPtr.Zero)
                outputImage = new SharpDX.Direct2D1.Image(outputImage_);
            else
                outputImage = null;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3d9f916b-27dc-4ad7-b4f1-64945340f563")]
    public partial class EffectContext : SharpDX.ComObject
    {
        public EffectContext(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator EffectContext(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new EffectContext(nativePtr);
        /// <summary>
        /// <p>Gets the unit mapping that an effect will use for properties that could be in either dots per inch (dpi) or pixels.</p>
        /// </summary>
        /// <param name = "dpiX"><dd>  <p>The dpi on the x-axis.</p> </dd></param>
        /// <param name = "dpiY"><dd>  <p>The dpi on the y-axis.</p> </dd></param>
        /// <remarks>
        /// <p> If the <strong><see cref = "SharpDX.Direct2D1.UnitMode"/></strong> is <strong>D2D1_UNIT_MODE_PIXELS</strong>, both <em>dpiX</em> and <em>dpiY</em> will be set to 96.</p>
        /// </remarks>
        /// <doc-id>hh404472</doc-id>
        /// <unmanaged>void ID2D1EffectContext::GetDpi([Out] float* dpiX,[Out] float* dpiY)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::GetDpi</unmanaged-short>
        internal unsafe void GetDpi(out System.Single dpiX, out System.Single dpiY)
        {
            fixed (void *dpiY_ = &dpiY)
                fixed (void *dpiX_ = &dpiX)
                    SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, dpiX_, dpiY_, (*(void ***)this._nativePointer)[3]);
        }

        /// <summary>
        /// <p> Creates a Direct2D effect for the specified  class ID. This is the same as <strong>ID2D1DeviceContext::CreateEffect</strong> so custom effects can create other effects and wrap them in a transform. </p>
        /// </summary>
        /// <param name = "effectId">No documentation.</param>
        /// <param name = "effect">No documentation.</param>
        /// <returns><p>The method returns an <see cref = "SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call. </td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation. </td></tr> <tr><td><see cref = "EffectIsNotRegistered"/></td><td>The specified effect is not registered by the system.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The created effect does not reference count the DLL from which the effect was created. If the caller unregisters an effect while this effect is loaded, the resulting behavior is unpredictable.</p>
        /// </remarks>
        /// <doc-id>hh404467</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateEffect([In] const GUID&amp; effectId,[Out, Fast] ID2D1Effect** effect)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::CreateEffect</unmanaged-short>
        internal unsafe void CreateEffect(System.Guid effectId, SharpDX.Direct2D1.Effect effect)
        {
            System.IntPtr effect_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &effectId, &effect_, (*(void ***)this._nativePointer)[4]);
            (effect).NativePointer = effect_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>This indicates the maximum feature level from the provided list which is supported by the device. If none of the provided levels are supported, then this API fails with <see cref = "InsufficientDeviceCapabilities"/>.</p>
        /// </summary>
        /// <param name = "featureLevels"><dd>  <p>The feature levels provided by the application.</p> </dd></param>
        /// <param name = "featureLevelsCount"><dd>  <p>The count of feature levels provided by the application</p> </dd></param>
        /// <returns><dd>  <p>The maximum feature level from the <em>featureLevels</em> list which is supported by the D2D device.</p> </dd></returns>
        /// <doc-id>hh404473</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::GetMaximumSupportedFeatureLevel([In, Buffer] const D3D_FEATURE_LEVEL* featureLevels,[In] unsigned int featureLevelsCount,[Out] D3D_FEATURE_LEVEL* maximumSupportedFeatureLevel)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::GetMaximumSupportedFeatureLevel</unmanaged-short>
        internal unsafe SharpDX.Direct3D.FeatureLevel GetMaximumSupportedFeatureLevel(SharpDX.Direct3D.FeatureLevel[] featureLevels, System.Int32 featureLevelsCount)
        {
            SharpDX.Direct3D.FeatureLevel maximumSupportedFeatureLevel;
            SharpDX.Result __result__;
            fixed (void *featureLevels_ = featureLevels)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, featureLevels_, featureLevelsCount, &maximumSupportedFeatureLevel, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
            return maximumSupportedFeatureLevel;
        }

        /// <summary>
        /// <p>Wraps an effect graph into a single transform node and then inserted into a transform graph. This allows an effect to aggregate other effects. This will typically be done in order to allow the effect properties to be re-expressed with a different contract, or to allow different components to integrate each-other?s effects.</p>
        /// </summary>
        /// <param name = "effect"><dd>  <p>The effect to be wrapped in a transform node.</p> </dd></param>
        /// <returns><dd>  <p>The returned transform node that encapsulates the effect graph.</p> </dd></returns>
        /// <doc-id>hh404470</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateTransformNodeFromEffect([In] ID2D1Effect* effect,[Out] ID2D1TransformNode** transformNode)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::CreateTransformNodeFromEffect</unmanaged-short>
        public unsafe SharpDX.Direct2D1.TransformNode CreateTransformNodeFromEffect(SharpDX.Direct2D1.Effect effect)
        {
            System.IntPtr effect_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.TransformNode transformNode;
            System.IntPtr transformNode_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            effect_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Effect>(effect);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)effect_, &transformNode_, (*(void ***)this._nativePointer)[6]);
            if (transformNode_ != System.IntPtr.Zero)
                transformNode = new SharpDX.Direct2D1.TransformNodeNative(transformNode_);
            else
                transformNode = null;
            __result__.CheckError();
            return transformNode;
        }

        /// <summary>
        /// <p>This creates a blend transform that can be inserted into a transform graph.  </p>
        /// </summary>
        /// <param name = "numInputs"><dd>  <p>The number of inputs to the blend transform.</p> </dd></param>
        /// <param name = "blendDescription"><dd>  <p>Describes the blend transform that is to be created.</p> </dd></param>
        /// <param name = "transform"><dd>  <p>The returned blend transform.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh404461</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateBlendTransform([In] unsigned int numInputs,[In] const D2D1_BLEND_DESCRIPTION* blendDescription,[Out, Fast] ID2D1BlendTransform** transform)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::CreateBlendTransform</unmanaged-short>
        internal unsafe void CreateBlendTransform(System.Int32 numInputs, ref SharpDX.Direct2D1.BlendDescription blendDescription, SharpDX.Direct2D1.BlendTransform transform)
        {
            System.IntPtr transform_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *blendDescription_ = &blendDescription)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, numInputs, blendDescription_, &transform_, (*(void ***)this._nativePointer)[7]);
            (transform).NativePointer = transform_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a transform that extends its input infinitely in every direction based on the passed in extend mode.</p>
        /// </summary>
        /// <param name = "extendModeX"><dd>  <p>The extend mode in the X-axis direction.</p> </dd></param>
        /// <param name = "extendModeY"><dd>  <p>The extend mode in the Y-axis direction.</p> </dd></param>
        /// <param name = "transform"><dd>  <p>The returned transform.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh404463</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateBorderTransform([In] D2D1_EXTEND_MODE extendModeX,[In] D2D1_EXTEND_MODE extendModeY,[Out, Fast] ID2D1BorderTransform** transform)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::CreateBorderTransform</unmanaged-short>
        internal unsafe void CreateBorderTransform(SharpDX.Direct2D1.ExtendMode extendModeX, SharpDX.Direct2D1.ExtendMode extendModeY, SharpDX.Direct2D1.BorderTransform transform)
        {
            System.IntPtr transform_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)extendModeX), unchecked ((System.Int32)extendModeY), &transform_, (*(void ***)this._nativePointer)[8]);
            (transform).NativePointer = transform_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates and returns an offset transform.</p>
        /// </summary>
        /// <param name = "offset"><dd>  <p>The offset amount.</p> </dd></param>
        /// <param name = "transform"><dd>  <p>When this method returns, contains the address of a reference to an offset transform object.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>An offset transform is used to offset an input bitmap without having to insert a rendering pass. An offset transform is automatically inserted by an Affine transform if the transform evaluates to a pixel-aligned transform.</p>
        /// </remarks>
        /// <doc-id>hh404468</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateOffsetTransform([In] POINT offset,[Out, Fast] ID2D1OffsetTransform** transform)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::CreateOffsetTransform</unmanaged-short>
        internal unsafe void CreateOffsetTransform(SharpDX.Mathematics.Interop.RawPoint offset, SharpDX.Direct2D1.OffsetTransform transform)
        {
            System.IntPtr transform_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, offset, &transform_, (*(void ***)this._nativePointer)[9]);
            (transform).NativePointer = transform_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates and returns a bounds adjustment  transform.</p>
        /// </summary>
        /// <param name = "outputRectangle"><dd>  <p>The initial output rectangle for the bounds adjustment transform.</p> </dd></param>
        /// <param name = "transform"><dd>  <p>The returned bounds adjustment transform.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>A support transform can be used for two different reasons.</p><ul> <li>To indicate that a region of its input image is already transparent black. This can increase efficiency for rendering bitmaps. <strong>Note</strong>??If the indicated region does NOT contain only transparent black pixels, then rendering results are undefined. ? </li> <li>To increase the size of the input image. The expanded area will be treated as transparent black
        /// </li> </ul>
        /// </remarks>
        /// <doc-id>hh871456</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateBoundsAdjustmentTransform([In] const RECT* outputRectangle,[Out, Fast] ID2D1BoundsAdjustmentTransform** transform)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::CreateBoundsAdjustmentTransform</unmanaged-short>
        internal unsafe void CreateBoundsAdjustmentTransform(SharpDX.Mathematics.Interop.RawRectangle outputRectangle, SharpDX.Direct2D1.BoundsAdjustmentTransform transform)
        {
            System.IntPtr transform_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &outputRectangle, &transform_, (*(void ***)this._nativePointer)[10]);
            (transform).NativePointer = transform_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Loads the given shader by its unique ID. Loading the shader multiple times is ignored. When the shader is loaded it is also handed to the driver to JIT, if it hasn?t been already.</p>
        /// </summary>
        /// <param name = "shaderId"><dd>  <p>The unique id that identifies the shader.</p> </dd></param>
        /// <param name = "shaderBuffer"><dd>  <p>The buffer that contains the shader to register.</p> </dd></param>
        /// <param name = "shaderBufferCount"><dd>  <p>The size of the shader buffer in bytes.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The shader you specify must be compiled,  not  in raw HLSL code.</p>
        /// </remarks>
        /// <doc-id>hh404476</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::LoadPixelShader([In] const GUID&amp; shaderId,[In, Buffer] const unsigned char* shaderBuffer,[In] unsigned int shaderBufferCount)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::LoadPixelShader</unmanaged-short>
        internal unsafe void LoadPixelShader(System.Guid shaderId, System.Byte[] shaderBuffer, System.Int32 shaderBufferCount)
        {
            SharpDX.Result __result__;
            fixed (void *shaderBuffer_ = shaderBuffer)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &shaderId, shaderBuffer_, shaderBufferCount, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Loads the given shader by its unique ID. Loading the shader multiple times is ignored. When the shader is loaded it is also handed to the driver to JIT, if it hasn?t been already.</p>
        /// </summary>
        /// <param name = "resourceId"><dd>  <p>The unique id that identifies the shader.</p> </dd></param>
        /// <param name = "shaderBuffer"><dd>  <p>The buffer that contains the shader to register.</p> </dd></param>
        /// <param name = "shaderBufferCount"><dd>  <p>The size of the shader buffer in bytes.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The shader you specify must be compiled,  not  in raw HLSL code.</p>
        /// </remarks>
        /// <doc-id>hh404477</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::LoadVertexShader([In] const GUID&amp; resourceId,[In, Buffer] const unsigned char* shaderBuffer,[In] unsigned int shaderBufferCount)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::LoadVertexShader</unmanaged-short>
        internal unsafe void LoadVertexShader(System.Guid resourceId, System.Byte[] shaderBuffer, System.Int32 shaderBufferCount)
        {
            SharpDX.Result __result__;
            fixed (void *shaderBuffer_ = shaderBuffer)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &resourceId, shaderBuffer_, shaderBufferCount, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Loads the given shader by its unique ID. Loading the shader multiple times is ignored. When the shader is loaded it is also handed to the driver to JIT, if it hasn?t been already.</p>
        /// </summary>
        /// <param name = "resourceId"><dd>  <p>The unique id that identifies the shader.</p> </dd></param>
        /// <param name = "shaderBuffer"><dd>  <p>The buffer that contains the shader to register.</p> </dd></param>
        /// <param name = "shaderBufferCount"><dd>  <p>The size of the shader buffer in bytes.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The shader you specify must be compiled,  not  in raw HLSL code.</p>
        /// </remarks>
        /// <doc-id>hh404475</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::LoadComputeShader([In] const GUID&amp; resourceId,[In, Buffer] const unsigned char* shaderBuffer,[In] unsigned int shaderBufferCount)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::LoadComputeShader</unmanaged-short>
        internal unsafe void LoadComputeShader(System.Guid resourceId, System.Byte[] shaderBuffer, System.Int32 shaderBufferCount)
        {
            SharpDX.Result __result__;
            fixed (void *shaderBuffer_ = shaderBuffer)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &resourceId, shaderBuffer_, shaderBufferCount, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>This tests to see if the given shader is loaded.</p>
        /// </summary>
        /// <param name = "shaderId"><dd>  <p>The unique id that identifies the shader.</p> </dd></param>
        /// <returns><p>Whether the shader is loaded.</p></returns>
        /// <doc-id>hh404474</doc-id>
        /// <unmanaged>BOOL ID2D1EffectContext::IsShaderLoaded([In] const GUID&amp; shaderId)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::IsShaderLoaded</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool IsShaderLoaded(System.Guid shaderId)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, &shaderId, (*(void ***)this._nativePointer)[14]);
            return __result__;
        }

        /// <summary>
        /// <p>Creates or finds the given resource texture, depending on whether a resource id is specified. It also optionally initializes the texture with the specified data.</p>
        /// </summary>
        /// <param name = "resourceId"><dd>  <p>An optional reference to the unique id that identifies the lookup table.</p> </dd></param>
        /// <param name = "resourceTextureProperties"><dd>  <p>The properties used to create the resource texture.</p> </dd></param>
        /// <param name = "data"><dd>  <p>The optional data to be loaded into the resource texture.</p> </dd></param>
        /// <param name = "strides"><dd>  <p>An optional reference to the stride to advance through the resource texture, according to dimension.</p> </dd></param>
        /// <param name = "dataSize"><dd>  <p>The size, in bytes, of the data.</p> </dd></param>
        /// <param name = "resourceTexture"><dd>  <p>The returned texture that can be used as a resource in a Direct2D effect.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh404469</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateResourceTexture([In, Optional] const GUID* resourceId,[In] const D2D1_RESOURCE_TEXTURE_PROPERTIES* resourceTextureProperties,[In, Buffer, Optional] const unsigned char* data,[In, Buffer, Optional] const unsigned int* strides,[In] unsigned int dataSize,[Out, Fast] ID2D1ResourceTexture** resourceTexture)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::CreateResourceTexture</unmanaged-short>
        internal unsafe void CreateResourceTexture(System.Guid? resourceId, System.IntPtr resourceTextureProperties, System.Byte[] data, System.Int32[] strides, System.Int32 dataSize, SharpDX.Direct2D1.ResourceTexture resourceTexture)
        {
            System.Guid resourceId_;
            System.IntPtr resourceTexture_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (resourceId != null)
                resourceId_ = resourceId.Value;
            fixed (void *strides_ = strides)
                fixed (void *data_ = data)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, resourceId == null ? (void *)0 : &resourceId_, (void *)resourceTextureProperties, data_, strides_, dataSize, &resourceTexture_, (*(void ***)this._nativePointer)[15]);
            (resourceTexture).NativePointer = resourceTexture_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Finds the given resource texture if it has already been created with <strong>ID2D1EffectContext::CreateResourceTexture</strong> with the same <see cref = "System.Guid"/>.</p>
        /// </summary>
        /// <param name = "resourceId">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh871457</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::FindResourceTexture([In] const GUID* resourceId,[Out] ID2D1ResourceTexture** resourceTexture)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::FindResourceTexture</unmanaged-short>
        public unsafe SharpDX.Direct2D1.ResourceTexture FindResourceTexture(System.Guid resourceId)
        {
            SharpDX.Direct2D1.ResourceTexture resourceTexture;
            System.IntPtr resourceTexture_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &resourceId, &resourceTexture_, (*(void ***)this._nativePointer)[16]);
            if (resourceTexture_ != System.IntPtr.Zero)
                resourceTexture = new SharpDX.Direct2D1.ResourceTexture(resourceTexture_);
            else
                resourceTexture = null;
            return resourceTexture;
        }

        /// <summary>
        /// <p>Creates a vertex buffer or finds a standard vertex buffer and optionally initializes it with vertices. The returned buffer can be specified in the render info to specify both a vertex shader and or to pass custom vertices to the standard vertex shader used by Direct2D. </p>
        /// </summary>
        /// <param name = "vertexBufferProperties">No documentation.</param>
        /// <param name = "resourceId">No documentation.</param>
        /// <param name = "customVertexBufferProperties">No documentation.</param>
        /// <param name = "buffer">No documentation.</param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh404471</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateVertexBuffer([In] const D2D1_VERTEX_BUFFER_PROPERTIES* vertexBufferProperties,[In, Optional] const GUID* resourceId,[In, Optional] const D2D1_CUSTOM_VERTEX_BUFFER_PROPERTIES* customVertexBufferProperties,[Out, Fast] ID2D1VertexBuffer** buffer)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::CreateVertexBuffer</unmanaged-short>
        internal unsafe void CreateVertexBuffer(SharpDX.Direct2D1.VertexBufferProperties vertexBufferProperties, System.Guid? resourceId, System.IntPtr customVertexBufferProperties, SharpDX.Direct2D1.VertexBuffer buffer)
        {
            SharpDX.Direct2D1.VertexBufferProperties.__Native vertexBufferProperties_ = default (SharpDX.Direct2D1.VertexBufferProperties.__Native);
            System.Guid resourceId_;
            System.IntPtr buffer_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            vertexBufferProperties.__MarshalTo(ref vertexBufferProperties_);
            if (resourceId != null)
                resourceId_ = resourceId.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &vertexBufferProperties_, resourceId == null ? (void *)0 : &resourceId_, (void *)customVertexBufferProperties, &buffer_, (*(void ***)this._nativePointer)[17]);
            (buffer).NativePointer = buffer_;
            vertexBufferProperties.__MarshalFree(ref vertexBufferProperties_);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>This finds the given vertex buffer if it has already been created with <strong>ID2D1EffectContext::CreateVertexBuffer</strong> with the same <see cref = "System.Guid"/>.</p>
        /// </summary>
        /// <param name = "resourceId">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh871458</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::FindVertexBuffer([In] const GUID* resourceId,[Out] ID2D1VertexBuffer** buffer)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::FindVertexBuffer</unmanaged-short>
        public unsafe SharpDX.Direct2D1.VertexBuffer FindVertexBuffer(System.Guid resourceId)
        {
            SharpDX.Direct2D1.VertexBuffer buffer;
            System.IntPtr buffer_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &resourceId, &buffer_, (*(void ***)this._nativePointer)[18]);
            if (buffer_ != System.IntPtr.Zero)
                buffer = new SharpDX.Direct2D1.VertexBuffer(buffer_);
            else
                buffer = null;
            return buffer;
        }

        /// <summary>
        /// <p>Creates a color context from a color space.  </p><p>If the color space is Custom, the context is initialized from the <em>profile</em> and <em>profileSize</em> parameters.</p><p>If the color space is not Custom, the context is       initialized with the profile bytes associated with the color space. The <em>profile</em> and <em>profileSize</em> parameters are ignored.</p>
        /// </summary>
        /// <param name = "space"><dd>  <p>The space  of color context to create.</p> </dd></param>
        /// <param name = "rofileRef"><dd>  <p>A buffer containing the ICC profile bytes used to initialize the color context when <em>space</em> is <strong>D2D1_COLOR_SPACE_CUSTOM</strong>.  For other types, the parameter is ignored and should be set to <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "profileSize"><dd>  <p>The size in bytes of <em>Profile</em>.</p> </dd></param>
        /// <param name = "colorContext"><dd>  <p>When this method returns, contains the address of a reference to a new color context object.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh404464</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateColorContext([In] D2D1_COLOR_SPACE space,[In, Buffer, Optional] const unsigned char* profile,[In] unsigned int profileSize,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::CreateColorContext</unmanaged-short>
        internal unsafe void CreateColorContext(SharpDX.Direct2D1.ColorSpace space, System.Byte[] rofileRef, System.Int32 profileSize, SharpDX.Direct2D1.ColorContext colorContext)
        {
            System.IntPtr colorContext_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *rofileRef_ = rofileRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)space), rofileRef_, profileSize, &colorContext_, (*(void ***)this._nativePointer)[19]);
            (colorContext).NativePointer = colorContext_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a color context by loading it from the specified filename.  The profile bytes are the contents of the file specified by <em>filename</em>.</p>
        /// </summary>
        /// <param name = "filename"><dd>  <p>The path to the file containing the profile bytes to initialize the color context with.</p> </dd></param>
        /// <param name = "colorContext"><dd>  <p>When this method returns, contains the address of a reference to a new color context.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh404465</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateColorContextFromFilename([In] const wchar_t* filename,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::CreateColorContextFromFilename</unmanaged-short>
        internal unsafe void CreateColorContextFromFilename(System.String filename, SharpDX.Direct2D1.ColorContext colorContext)
        {
            System.IntPtr colorContext_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (char *filename_ = filename)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)filename_, &colorContext_, (*(void ***)this._nativePointer)[20]);
            (colorContext).NativePointer = colorContext_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a color context from an <strong><see cref = "SharpDX.WIC.ColorContext"/></strong>.  The <strong>D2D1ColorContext</strong> space of the resulting context varies, see Remarks for more info.</p>
        /// </summary>
        /// <param name = "wicColorContext">No documentation.</param>
        /// <param name = "colorContext">No documentation.</param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The new color context can be used in <strong><see cref = "SharpDX.Direct2D1.BitmapProperties1"/></strong> to initialize the color context of a created bitmap.  The model field of the profile header is inspected to determine whether this profile is sRGB or scRGB and the color space is updated respectively.  Otherwise the space is  custom.</p>
        /// </remarks>
        /// <doc-id>hh404466</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::CreateColorContextFromWicColorContext([In] IWICColorContext* wicColorContext,[Out, Fast] ID2D1ColorContext** colorContext)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::CreateColorContextFromWicColorContext</unmanaged-short>
        internal unsafe void CreateColorContextFromWicColorContext(SharpDX.WIC.ColorContext wicColorContext, SharpDX.Direct2D1.ColorContext colorContext)
        {
            System.IntPtr wicColorContext_ = System.IntPtr.Zero;
            System.IntPtr colorContext_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            wicColorContext_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.ColorContext>(wicColorContext);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)wicColorContext_, &colorContext_, (*(void ***)this._nativePointer)[21]);
            (colorContext).NativePointer = colorContext_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>This indicates whether an optional capability is supported by the D3D device.</p>
        /// </summary>
        /// <param name = "feature"><dd>  <p>The feature to query support for.</p> </dd></param>
        /// <param name = "featureSupportData"><dd>  <p>A structure indicating information about how or if the feature is supported.</p> </dd></param>
        /// <param name = "featureSupportDataSize"><dd>  <p>The size of the <em>featureSupportData</em> parameter.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh871455</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext::CheckFeatureSupport([In] D2D1_FEATURE feature,[Out, Buffer] void* featureSupportData,[In] unsigned int featureSupportDataSize)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::CheckFeatureSupport</unmanaged-short>
        internal unsafe SharpDX.Result CheckFeatureSupport(SharpDX.Direct2D1.Feature feature, System.IntPtr featureSupportData, System.Int32 featureSupportDataSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)feature), (void *)featureSupportData, featureSupportDataSize, (*(void ***)this._nativePointer)[22]);
            return __result__;
        }

        /// <summary>
        /// <p> Indicates whether the buffer precision is supported by the underlying Direct2D <strong>device.</strong> </p>
        /// </summary>
        /// <param name = "bufferPrecision">No documentation.</param>
        /// <returns><p>Returns TRUE if the buffer precision is supported.  Returns <see cref = "SharpDX.Result.False"/> if the buffer precision is not supported.</p></returns>
        /// <doc-id>hh847981</doc-id>
        /// <unmanaged>BOOL ID2D1EffectContext::IsBufferPrecisionSupported([In] D2D1_BUFFER_PRECISION bufferPrecision)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext::IsBufferPrecisionSupported</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool IsBufferPrecisionSupported(SharpDX.Direct2D1.BufferPrecision bufferPrecision)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, unchecked ((System.Int32)bufferPrecision), (*(void ***)this._nativePointer)[23]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("84ab595a-fc81-4546-bacd-e8ef4d8abe7a")]
    public partial class EffectContext1 : SharpDX.Direct2D1.EffectContext
    {
        public EffectContext1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator EffectContext1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new EffectContext1(nativePtr);
        /// <summary>
        /// <p>Creates a 3D lookup table for mapping a 3-channel input to a 3-channel output. The table data must be provided in 4-channel format.</p>
        /// </summary>
        /// <param name = "precision"><dd>  <p>Precision of the input lookup table data.</p> </dd></param>
        /// <param name = "extents"><dd>  <p>Number of lookup table elements per dimension (X, Y, Z).</p> </dd></param>
        /// <param name = "data"><dd>  <p>Buffer holding the lookup table data.</p> </dd></param>
        /// <param name = "dataCount"><dd>  <p>Size of the lookup table data buffer.</p> </dd></param>
        /// <param name = "strides"><dd>  <p>An array containing two values. The first value is the size in bytes from one row (X dimension) of LUT data to the next.  The second value is the size in bytes from one LUT data plane (X and Y dimensions) to the next.</p> </dd></param>
        /// <param name = "lookupTable"><dd>  <p>Receives the new lookup table instance.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn949339</doc-id>
        /// <unmanaged>HRESULT ID2D1EffectContext1::CreateLookupTable3D([In] D2D1_BUFFER_PRECISION precision,[In, Buffer] const unsigned int* extents,[In, Buffer] const unsigned char* data,[In] unsigned int dataCount,[In, Buffer] const unsigned int* strides,[Out] ID2D1LookupTable3D** lookupTable)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext1::CreateLookupTable3D</unmanaged-short>
        public unsafe void CreateLookupTable3D(SharpDX.Direct2D1.BufferPrecision precision, System.Int32[] extents, System.Byte[] data, System.Int32 dataCount, System.Int32[] strides, out SharpDX.Direct2D1.LookupTable3D lookupTable)
        {
            System.IntPtr lookupTable_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *strides_ = strides)
                fixed (void *data_ = data)
                    fixed (void *extents_ = extents)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)precision), extents_, data_, dataCount, strides_, &lookupTable_, (*(void ***)this._nativePointer)[24]);
            if (lookupTable_ != System.IntPtr.Zero)
                lookupTable = new SharpDX.Direct2D1.LookupTable3D(lookupTable_);
            else
                lookupTable = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("577ad2a0-9fc7-4dda-8b18-dab810140052")]
    public partial class EffectContext2 : SharpDX.Direct2D1.EffectContext1
    {
        public EffectContext2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator EffectContext2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new EffectContext2(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "colorSpace">No documentation.</param>
        /// <param name = "colorContext">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1EffectContext2::CreateColorContextFromDxgiColorSpace([In] DXGI_COLOR_SPACE_TYPE colorSpace,[Out, Fast] ID2D1ColorContext1** colorContext)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext2::CreateColorContextFromDxgiColorSpace</unmanaged-short>
        public unsafe void CreateColorContextFromDxgiColorSpace(SharpDX.DXGI.ColorSpaceType colorSpace, SharpDX.Direct2D1.ColorContext1 colorContext)
        {
            System.IntPtr colorContext_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)colorSpace), &colorContext_, (*(void ***)this._nativePointer)[25]);
            (colorContext).NativePointer = colorContext_;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "simpleProfile">No documentation.</param>
        /// <param name = "colorContext">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1EffectContext2::CreateColorContextFromSimpleColorProfile([In] const D2D1_SIMPLE_COLOR_PROFILE* simpleProfile,[Out, Fast] ID2D1ColorContext1** colorContext)</unmanaged>
        /// <unmanaged-short>ID2D1EffectContext2::CreateColorContextFromSimpleColorProfile</unmanaged-short>
        public unsafe void CreateColorContextFromSimpleColorProfile(ref SharpDX.Direct2D1.SimpleColorProfile simpleProfile, SharpDX.Direct2D1.ColorContext1 colorContext)
        {
            System.IntPtr colorContext_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *simpleProfile_ = &simpleProfile)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, simpleProfile_, &colorContext_, (*(void ***)this._nativePointer)[26]);
            (colorContext).NativePointer = colorContext_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd906a4-12e2-11dc-9fed-001143a055f9")]
    public partial class EllipseGeometry : SharpDX.Direct2D1.Geometry
    {
        public EllipseGeometry(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator EllipseGeometry(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new EllipseGeometry(nativePtr);
        /// <summary>
        /// <p>Gets the <strong><see cref = "SharpDX.Direct2D1.Ellipse"/></strong> structure that describes this ellipse geometry. </p>
        /// </summary>
        /// <doc-id>dd371243</doc-id>
        /// <unmanaged>GetEllipse</unmanaged>
        /// <unmanaged-short>GetEllipse</unmanaged-short>
        public SharpDX.Direct2D1.Ellipse Ellipse
        {
            get
            {
                GetEllipse(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the <strong><see cref = "SharpDX.Direct2D1.Ellipse"/></strong> structure that describes this ellipse geometry. </p>
        /// </summary>
        /// <param name = "ellipse">No documentation.</param>
        /// <doc-id>dd371243</doc-id>
        /// <unmanaged>void ID2D1EllipseGeometry::GetEllipse([Out] D2D1_ELLIPSE* ellipse)</unmanaged>
        /// <unmanaged-short>ID2D1EllipseGeometry::GetEllipse</unmanaged-short>
        internal unsafe void GetEllipse(out SharpDX.Direct2D1.Ellipse ellipse)
        {
            ellipse = default (SharpDX.Direct2D1.Ellipse);
            fixed (void *ellipse_ = &ellipse)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, ellipse_, (*(void ***)this._nativePointer)[17]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("06152247-6f50-465a-9245-118bfd3b6007")]
    public partial class Factory : SharpDX.ComObject
    {
        public Factory(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory(nativePtr);
        /// <summary>
        /// <p>Forces the factory to refresh any system defaults that it might have changed since factory creation.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>You should call this method before calling the <strong>GetDesktopDpi</strong> method, to ensure that the system DPI is current.</p>
        /// </remarks>
        /// <doc-id>dd371319</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory::ReloadSystemMetrics()</unmanaged>
        /// <unmanaged-short>ID2D1Factory::ReloadSystemMetrics</unmanaged-short>
        public unsafe void ReloadSystemMetrics()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the current desktop dots per inch (DPI). To refresh this value, call <strong>ReloadSystemMetrics</strong>.</p>
        /// </summary>
        /// <param name = "dpiX">No documentation.</param>
        /// <param name = "dpiY">No documentation.</param>
        /// <remarks>
        /// <p>Use this method to obtain the system DPI when setting physical pixel values, such as when you specify the size of a window.</p>
        /// </remarks>
        /// <doc-id>dd371316</doc-id>
        /// <unmanaged>void ID2D1Factory::GetDesktopDpi([Out] float* dpiX,[Out] float* dpiY)</unmanaged>
        /// <unmanaged-short>ID2D1Factory::GetDesktopDpi</unmanaged-short>
        internal unsafe void GetDesktopDpi(out System.Single dpiX, out System.Single dpiY)
        {
            fixed (void *dpiY_ = &dpiY)
                fixed (void *dpiX_ = &dpiX)
                    SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, dpiX_, dpiY_, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p> Creates an <strong><see cref = "SharpDX.Direct2D1.RectangleGeometry"/></strong>. </p>
        /// </summary>
        /// <param name = "rectangle">No documentation.</param>
        /// <param name = "rectangleGeometry">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371289</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory::CreateRectangleGeometry([In] const D2D_RECT_F* rectangle,[Out, Fast] ID2D1RectangleGeometry** rectangleGeometry)</unmanaged>
        /// <unmanaged-short>ID2D1Factory::CreateRectangleGeometry</unmanaged-short>
        internal unsafe void CreateRectangleGeometry(SharpDX.Mathematics.Interop.RawRectangleF rectangle, SharpDX.Direct2D1.RectangleGeometry rectangleGeometry)
        {
            System.IntPtr rectangleGeometry_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &rectangle, &rectangleGeometry_, (*(void ***)this._nativePointer)[5]);
            (rectangleGeometry).NativePointer = rectangleGeometry_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an <strong><see cref = "SharpDX.Direct2D1.RoundedRectangleGeometry"/></strong>. </p>
        /// </summary>
        /// <param name = "roundedRectangle">No documentation.</param>
        /// <param name = "roundedRectangleGeometry">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371293</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory::CreateRoundedRectangleGeometry([In] const D2D1_ROUNDED_RECT* roundedRectangle,[Out, Fast] ID2D1RoundedRectangleGeometry** roundedRectangleGeometry)</unmanaged>
        /// <unmanaged-short>ID2D1Factory::CreateRoundedRectangleGeometry</unmanaged-short>
        internal unsafe void CreateRoundedRectangleGeometry(ref SharpDX.Direct2D1.RoundedRectangle roundedRectangle, SharpDX.Direct2D1.RoundedRectangleGeometry roundedRectangleGeometry)
        {
            System.IntPtr roundedRectangleGeometry_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *roundedRectangle_ = &roundedRectangle)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, roundedRectangle_, &roundedRectangleGeometry_, (*(void ***)this._nativePointer)[6]);
            (roundedRectangleGeometry).NativePointer = roundedRectangleGeometry_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.Direct2D1.EllipseGeometry"/></strong>. </p>
        /// </summary>
        /// <param name = "ellipse">No documentation.</param>
        /// <param name = "ellipseGeometry">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371270</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory::CreateEllipseGeometry([In] const D2D1_ELLIPSE* ellipse,[Out, Fast] ID2D1EllipseGeometry** ellipseGeometry)</unmanaged>
        /// <unmanaged-short>ID2D1Factory::CreateEllipseGeometry</unmanaged-short>
        internal unsafe void CreateEllipseGeometry(SharpDX.Direct2D1.Ellipse ellipse, SharpDX.Direct2D1.EllipseGeometry ellipseGeometry)
        {
            System.IntPtr ellipseGeometry_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &ellipse, &ellipseGeometry_, (*(void ***)this._nativePointer)[7]);
            (ellipseGeometry).NativePointer = ellipseGeometry_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.Direct2D1.GeometryGroup"/></strong>, which is an object that holds other geometries.</p>
        /// </summary>
        /// <param name = "fillMode">No documentation.</param>
        /// <param name = "geometries">No documentation.</param>
        /// <param name = "geometriesCount">No documentation.</param>
        /// <param name = "geometryGroup">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Geometry groups are a convenient way to group several geometries simultaneously so all figures of several distinct geometries are concatenated into one. To create a  <strong><see cref = "SharpDX.Direct2D1.GeometryGroup"/></strong> object, call  the <strong>CreateGeometryGroup</strong> method on the <strong><see cref = "SharpDX.Direct2D1.Factory"/></strong> object, passing in the <em>fillMode</em> with possible values of   <strong>D2D1_FILL_MODE_ALTERNATE</strong> (alternate) and <strong>D2D1_FILL_MODE_WINDING</strong>, an array of geometry objects to add to the geometry group, and the number of elements in this array. </p>
        /// </remarks>
        /// <doc-id>dd371273</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory::CreateGeometryGroup([In] D2D1_FILL_MODE fillMode,[In, Buffer] ID2D1Geometry** geometries,[In] unsigned int geometriesCount,[Out, Fast] ID2D1GeometryGroup** geometryGroup)</unmanaged>
        /// <unmanaged-short>ID2D1Factory::CreateGeometryGroup</unmanaged-short>
        internal unsafe void CreateGeometryGroup(SharpDX.Direct2D1.FillMode fillMode, SharpDX.Direct2D1.Geometry[] geometries, System.Int32 geometriesCount, SharpDX.Direct2D1.GeometryGroup geometryGroup)
        {
            System.IntPtr*geometries_;
            geometries_ = (System.IntPtr*)0;
            if (geometries != null)
            {
                System.IntPtr*_geometries = stackalloc System.IntPtr[geometries.Length];
                geometries_ = _geometries;
            }

            System.IntPtr geometryGroup_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (geometries != null)
                for (int i = 0; i < geometries.Length; ++i)
                    (geometries_)[i] = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Geometry>(geometries[i]);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)fillMode), (void *)geometries_, geometriesCount, &geometryGroup_, (*(void ***)this._nativePointer)[8]);
            (geometryGroup).NativePointer = geometryGroup_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Transforms the specified geometry and stores the result as an <strong><see cref = "SharpDX.Direct2D1.TransformedGeometry"/></strong> object.  </p>
        /// </summary>
        /// <param name = "sourceGeometry">No documentation.</param>
        /// <param name = "transform">No documentation.</param>
        /// <param name = "transformedGeometry">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Like other resources, a transformed geometry inherits the resource space and threading policy of the factory that created it. This object is immutable.</p><p>When stroking a transformed geometry with the <strong>DrawGeometry</strong> method, the stroke width is not affected by the transform applied to the geometry.  The stroke width is only affected by the world transform.</p>
        /// </remarks>
        /// <doc-id>dd371307</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory::CreateTransformedGeometry([In] ID2D1Geometry* sourceGeometry,[In] const D2D_MATRIX_3X2_F* transform,[Out, Fast] ID2D1TransformedGeometry** transformedGeometry)</unmanaged>
        /// <unmanaged-short>ID2D1Factory::CreateTransformedGeometry</unmanaged-short>
        internal unsafe void CreateTransformedGeometry(SharpDX.Direct2D1.Geometry sourceGeometry, ref SharpDX.Mathematics.Interop.RawMatrix3x2 transform, SharpDX.Direct2D1.TransformedGeometry transformedGeometry)
        {
            System.IntPtr sourceGeometry_ = System.IntPtr.Zero;
            System.IntPtr transformedGeometry_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            sourceGeometry_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Geometry>(sourceGeometry);
            fixed (void *transform_ = &transform)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)sourceGeometry_, transform_, &transformedGeometry_, (*(void ***)this._nativePointer)[9]);
            (transformedGeometry).NativePointer = transformedGeometry_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an empty <strong><see cref = "SharpDX.Direct2D1.PathGeometry"/></strong>.</p>
        /// </summary>
        /// <param name = "athGeometryRef">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371282</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory::CreatePathGeometry([Out, Fast] ID2D1PathGeometry** pathGeometry)</unmanaged>
        /// <unmanaged-short>ID2D1Factory::CreatePathGeometry</unmanaged-short>
        internal unsafe void CreatePathGeometry(SharpDX.Direct2D1.PathGeometry athGeometryRef)
        {
            System.IntPtr athGeometryRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &athGeometryRef_, (*(void ***)this._nativePointer)[10]);
            (athGeometryRef).NativePointer = athGeometryRef_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an <strong><see cref = "SharpDX.Direct2D1.StrokeStyle"/></strong> that describes start cap, dash pattern, and other features of a stroke.</p>
        /// </summary>
        /// <param name = "strokeStyleProperties">No documentation.</param>
        /// <param name = "dashes">No documentation.</param>
        /// <param name = "dashesCount">No documentation.</param>
        /// <param name = "strokeStyle">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371301</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory::CreateStrokeStyle([In] const D2D1_STROKE_STYLE_PROPERTIES* strokeStyleProperties,[In, Buffer, Optional] const float* dashes,[In] unsigned int dashesCount,[Out, Fast] ID2D1StrokeStyle** strokeStyle)</unmanaged>
        /// <unmanaged-short>ID2D1Factory::CreateStrokeStyle</unmanaged-short>
        internal unsafe void CreateStrokeStyle(ref SharpDX.Direct2D1.StrokeStyleProperties strokeStyleProperties, System.Single[] dashes, System.Int32 dashesCount, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            System.IntPtr strokeStyle_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *dashes_ = dashes)
                fixed (void *strokeStyleProperties_ = &strokeStyleProperties)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, strokeStyleProperties_, dashes_, dashesCount, &strokeStyle_, (*(void ***)this._nativePointer)[11]);
            (strokeStyle).NativePointer = strokeStyle_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.Direct2D1.DrawingStateBlock"/></strong> that can be used with the <strong>SaveDrawingState</strong> and <strong>RestoreDrawingState</strong> methods of a render target.</p>
        /// </summary>
        /// <param name = "drawingStateDescription">No documentation.</param>
        /// <param name = "textRenderingParams">No documentation.</param>
        /// <param name = "drawingStateBlock">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371253</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory::CreateDrawingStateBlock([In, Optional] const D2D1_DRAWING_STATE_DESCRIPTION* drawingStateDescription,[In, Optional] IDWriteRenderingParams* textRenderingParams,[Out, Fast] ID2D1DrawingStateBlock** drawingStateBlock)</unmanaged>
        /// <unmanaged-short>ID2D1Factory::CreateDrawingStateBlock</unmanaged-short>
        internal unsafe void CreateDrawingStateBlock(SharpDX.Direct2D1.DrawingStateDescription? drawingStateDescription, SharpDX.DirectWrite.RenderingParams textRenderingParams, SharpDX.Direct2D1.DrawingStateBlock drawingStateBlock)
        {
            SharpDX.Direct2D1.DrawingStateDescription drawingStateDescription_;
            System.IntPtr textRenderingParams_ = System.IntPtr.Zero;
            System.IntPtr drawingStateBlock_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (drawingStateDescription != null)
                drawingStateDescription_ = drawingStateDescription.Value;
            textRenderingParams_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.RenderingParams>(textRenderingParams);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, drawingStateDescription == null ? (void *)0 : &drawingStateDescription_, (void *)textRenderingParams_, &drawingStateBlock_, (*(void ***)this._nativePointer)[12]);
            (drawingStateBlock).NativePointer = drawingStateBlock_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a render target that renders to a Microsoft Windows Imaging Component (WIC)  bitmap.</p>
        /// </summary>
        /// <param name = "target"><dd>  <p>The bitmap that receives the rendering output of the render target.</p> </dd></param>
        /// <param name = "renderTargetProperties"><dd>  <p>The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering. For information about supported pixel formats, see  Supported Pixel  Formats and Alpha Modes.</p> </dd></param>
        /// <param name = "renderTarget"><dd>  <p>When this method returns, contains the address of the reference to the <strong><see cref = "SharpDX.Direct2D1.RenderTarget"/></strong> object created by this method. </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>You must use <strong>D2D1_FEATURE_LEVEL_DEFAULT</strong> for the <strong>minLevel</strong> member of the  <em>renderTargetProperties</em> parameter with this method.</p><p>Your application should create render targets once and hold onto them for the life of the application or until the <strong><see cref = "RecreateTarget"/></strong> error is received. When you receive this error, you need to recreate the render target (and any resources it created).</p><ul> <li></li> </ul>  <p><strong>Note</strong>??  This method isn't supported on Windows Phone and will fail when called on a device with error code 0x8899000b  (?There is no hardware rendering device available for this operation?). Because the Windows Phone Emulator supports WARP rendering,  this method will fail when called on the emulator with a different error code, 0x88982f80  (wincodec_err_unsupportedpixelformat).</p>
        /// </remarks>
        /// <doc-id>dd371309</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory::CreateWicBitmapRenderTarget([In] IWICBitmap* target,[In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,[Out, Fast] ID2D1RenderTarget** renderTarget)</unmanaged>
        /// <unmanaged-short>ID2D1Factory::CreateWicBitmapRenderTarget</unmanaged-short>
        internal unsafe void CreateWicBitmapRenderTarget(SharpDX.WIC.Bitmap target, ref SharpDX.Direct2D1.RenderTargetProperties renderTargetProperties, SharpDX.Direct2D1.RenderTarget renderTarget)
        {
            System.IntPtr target_ = System.IntPtr.Zero;
            System.IntPtr renderTarget_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            target_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.Bitmap>(target);
            fixed (void *renderTargetProperties_ = &renderTargetProperties)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)target_, renderTargetProperties_, &renderTarget_, (*(void ***)this._nativePointer)[13]);
            (renderTarget).NativePointer = renderTarget_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.Direct2D1.WindowRenderTarget"/></strong>, a render target that renders to a window.</p>
        /// </summary>
        /// <param name = "renderTargetProperties">No documentation.</param>
        /// <param name = "hwndRenderTargetProperties">No documentation.</param>
        /// <param name = "hwndRenderTarget">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>When you create a render target and hardware acceleration is available, you allocate resources on the computer's GPU. By creating a render target once and retaining it as long as possible, you gain performance benefits. Your application should create render targets once and hold onto them for the life of the application or until the <strong><see cref = "RecreateTarget"/></strong> error is received. When you receive this error, you need to recreate the render target (and any resources it created).</p>
        /// </remarks>
        /// <doc-id>dd371279</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory::CreateHwndRenderTarget([In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,[In] const D2D1_HWND_RENDER_TARGET_PROPERTIES* hwndRenderTargetProperties,[Out, Fast] ID2D1HwndRenderTarget** hwndRenderTarget)</unmanaged>
        /// <unmanaged-short>ID2D1Factory::CreateHwndRenderTarget</unmanaged-short>
        internal unsafe void CreateHwndRenderTarget(ref SharpDX.Direct2D1.RenderTargetProperties renderTargetProperties, ref SharpDX.Direct2D1.HwndRenderTargetProperties hwndRenderTargetProperties, SharpDX.Direct2D1.WindowRenderTarget hwndRenderTarget)
        {
            System.IntPtr hwndRenderTarget_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *hwndRenderTargetProperties_ = &hwndRenderTargetProperties)
                fixed (void *renderTargetProperties_ = &renderTargetProperties)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, renderTargetProperties_, hwndRenderTargetProperties_, &hwndRenderTarget_, (*(void ***)this._nativePointer)[14]);
            (hwndRenderTarget).NativePointer = hwndRenderTarget_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a render target that draws to a DirectX Graphics Infrastructure (DXGI) surface.  </p>
        /// </summary>
        /// <param name = "dxgiSurface"><dd>  <p>The <see cref = "SharpDX.DXGI.Surface"/> to which the render target will draw.</p> </dd></param>
        /// <param name = "renderTargetProperties"><dd>  <p>The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering. For information about supported pixel formats, see  Supported Pixel  Formats and Alpha Modes.</p> </dd></param>
        /// <param name = "renderTarget"><dd>  <p>When this method returns, contains the address of the reference to the <strong><see cref = "SharpDX.Direct2D1.RenderTarget"/></strong> object created by this method.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>To write to a Direct3D surface, you obtain an <see cref = "SharpDX.DXGI.Surface"/> and pass it to the <strong>CreateDxgiSurfaceRenderTarget</strong> method to create a DXGI surface render target; you can then use the DXGI surface render target to draw 2-D content to the DXGI surface.  </p><p>A DXGI surface render target is a type of <strong><see cref = "SharpDX.Direct2D1.RenderTarget"/></strong>. Like other Direct2D render targets, you can use it to create resources and issue drawing commands. </p><p>The DXGI surface render target and the DXGI surface must use the same DXGI format. If you specify the DXGI_FORMAT_UNKOWN format when you create the render target, it will automatically use the surface's format.</p><p>The DXGI surface render target does not perform DXGI surface synchronization. </p><p>For more information about creating and using DXGI surface render targets, see the Direct2D and Direct3D Interoperability Overview.</p><p>To work with Direct2D, the Direct3D device that provides the <see cref = "SharpDX.DXGI.Surface"/> must be created with the <strong>D3D10_CREATE_DEVICE_BGRA_SUPPORT</strong> flag.</p><p>When you create a render target and hardware acceleration is available, you allocate resources on the computer's GPU. By creating a render target once and retaining it as long as possible, you gain performance benefits. Your application should create render targets once and hold onto them for the life of the application or until the render target's <strong>EndDraw</strong> method returns the <strong><see cref = "RecreateTarget"/></strong> error. When you receive this error, you need to recreate the render target (and any resources it created). </p><p></p>
        /// </remarks>
        /// <doc-id>dd371264</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory::CreateDxgiSurfaceRenderTarget([In] IDXGISurface* dxgiSurface,[In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,[Out, Fast] ID2D1RenderTarget** renderTarget)</unmanaged>
        /// <unmanaged-short>ID2D1Factory::CreateDxgiSurfaceRenderTarget</unmanaged-short>
        internal unsafe void CreateDxgiSurfaceRenderTarget(SharpDX.DXGI.Surface dxgiSurface, ref SharpDX.Direct2D1.RenderTargetProperties renderTargetProperties, SharpDX.Direct2D1.RenderTarget renderTarget)
        {
            System.IntPtr dxgiSurface_ = System.IntPtr.Zero;
            System.IntPtr renderTarget_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            dxgiSurface_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Surface>(dxgiSurface);
            fixed (void *renderTargetProperties_ = &renderTargetProperties)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)dxgiSurface_, renderTargetProperties_, &renderTarget_, (*(void ***)this._nativePointer)[15]);
            (renderTarget).NativePointer = renderTarget_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a render target that draws to a Windows Graphics Device Interface (GDI) device context.</p>
        /// </summary>
        /// <param name = "renderTargetProperties"><dd>  <p>The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering.  To enable the device context (DC) render target to work with GDI, set the DXGI format to DXGI_FORMAT_B8G8R8A8_UNORM and the alpha mode to <strong>D2D1_ALPHA_MODE_PREMULTIPLIED</strong> or <strong>D2D1_ALPHA_MODE_IGNORE</strong>. For more information about pixel formats, see  Supported Pixel  Formats and Alpha Modes.</p> </dd></param>
        /// <param name = "dcRenderTarget"><dd>  <p>When this method returns, <em>dcRenderTarget</em> contains the address of the reference to the  <strong><see cref = "SharpDX.Direct2D1.DeviceContextRenderTarget"/></strong> created by the method.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Before you can render with a DC render target, you must use the render target's <strong>BindDC</strong> method to associate it with a GDI DC.  Do this for each different DC and whenever there is a change in the size of the area you want to draw to.</p><p>To enable the DC render target to work with GDI, set the render target's DXGI format to DXGI_FORMAT_B8G8R8A8_UNORM and alpha mode to <strong>D2D1_ALPHA_MODE_PREMULTIPLIED</strong> or <strong>D2D1_ALPHA_MODE_IGNORE</strong>.</p><p>Your application should create render targets once and hold on to them for the life of the application or until the render target's  <strong>EndDraw</strong> method returns the <strong><see cref = "RecreateTarget"/></strong> error. When you receive this error, recreate the render target (and any resources it created).</p>
        /// </remarks>
        /// <doc-id>dd371248</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory::CreateDCRenderTarget([In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties,[Out, Fast] ID2D1DCRenderTarget** dcRenderTarget)</unmanaged>
        /// <unmanaged-short>ID2D1Factory::CreateDCRenderTarget</unmanaged-short>
        internal unsafe void CreateDCRenderTarget(ref SharpDX.Direct2D1.RenderTargetProperties renderTargetProperties, SharpDX.Direct2D1.DeviceContextRenderTarget dcRenderTarget)
        {
            System.IntPtr dcRenderTarget_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *renderTargetProperties_ = &renderTargetProperties)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, renderTargetProperties_, &dcRenderTarget_, (*(void ***)this._nativePointer)[16]);
            (dcRenderTarget).NativePointer = dcRenderTarget_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.Direct2D1.GeometryGroup"/></strong>, which is an object that holds other geometries.</p>
        /// </summary>
        /// <param name = "fillMode">No documentation.</param>
        /// <param name = "geometries">No documentation.</param>
        /// <param name = "geometriesCount">No documentation.</param>
        /// <param name = "geometryGroup">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Geometry groups are a convenient way to group several geometries simultaneously so all figures of several distinct geometries are concatenated into one. To create a  <strong><see cref = "SharpDX.Direct2D1.GeometryGroup"/></strong> object, call  the <strong>CreateGeometryGroup</strong> method on the <strong><see cref = "SharpDX.Direct2D1.Factory"/></strong> object, passing in the <em>fillMode</em> with possible values of   <strong>D2D1_FILL_MODE_ALTERNATE</strong> (alternate) and <strong>D2D1_FILL_MODE_WINDING</strong>, an array of geometry objects to add to the geometry group, and the number of elements in this array. </p>
        /// </remarks>
        /// <doc-id>dd371273</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory::CreateGeometryGroup([In] D2D1_FILL_MODE fillMode,[In, Buffer] ID2D1Geometry** geometries,[In] unsigned int geometriesCount,[Out, Fast] ID2D1GeometryGroup** geometryGroup)</unmanaged>
        /// <unmanaged-short>ID2D1Factory::CreateGeometryGroup</unmanaged-short>
        internal unsafe void CreateGeometryGroup(SharpDX.Direct2D1.FillMode fillMode, SharpDX.ComArray<SharpDX.Direct2D1.Geometry> geometries, System.Int32 geometriesCount, SharpDX.Direct2D1.GeometryGroup geometryGroup)
        {
            System.IntPtr geometryGroup_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)fillMode), (void *)(geometries?.NativePointer ?? System.IntPtr.Zero), geometriesCount, &geometryGroup_, (*(void ***)this._nativePointer)[8]);
            (geometryGroup).NativePointer = geometryGroup_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.Direct2D1.GeometryGroup"/></strong>, which is an object that holds other geometries.</p>
        /// </summary>
        /// <param name = "fillMode">No documentation.</param>
        /// <param name = "geometries">No documentation.</param>
        /// <param name = "geometriesCount">No documentation.</param>
        /// <param name = "geometryGroup">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Geometry groups are a convenient way to group several geometries simultaneously so all figures of several distinct geometries are concatenated into one. To create a  <strong><see cref = "SharpDX.Direct2D1.GeometryGroup"/></strong> object, call  the <strong>CreateGeometryGroup</strong> method on the <strong><see cref = "SharpDX.Direct2D1.Factory"/></strong> object, passing in the <em>fillMode</em> with possible values of   <strong>D2D1_FILL_MODE_ALTERNATE</strong> (alternate) and <strong>D2D1_FILL_MODE_WINDING</strong>, an array of geometry objects to add to the geometry group, and the number of elements in this array. </p>
        /// </remarks>
        /// <doc-id>dd371273</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory::CreateGeometryGroup([In] D2D1_FILL_MODE fillMode,[In, Buffer] ID2D1Geometry** geometries,[In] unsigned int geometriesCount,[Out, Fast] ID2D1GeometryGroup** geometryGroup)</unmanaged>
        /// <unmanaged-short>ID2D1Factory::CreateGeometryGroup</unmanaged-short>
        private unsafe void CreateGeometryGroup(SharpDX.Direct2D1.FillMode fillMode, System.IntPtr geometries, System.Int32 geometriesCount, System.IntPtr geometryGroup)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)fillMode), (void *)geometries, geometriesCount, (void *)geometryGroup, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("bb12d362-daee-4b9a-aa1d-14ba401cfa1f")]
    public partial class Factory1 : SharpDX.Direct2D1.Factory
    {
        public Factory1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory1(nativePtr);
        /// <summary>
        /// <p>Creates a <strong><see cref = "SharpDX.Direct2D1.Device"/></strong> object.</p>
        /// </summary>
        /// <param name = "dxgiDevice">No documentation.</param>
        /// <param name = "d2dDevice">No documentation.</param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The Direct2D device defines a resource domain in which a set of Direct2D objects and Direct2D device contexts can be used together.  Each call to <strong>CreateDevice</strong> returns a unique <strong><see cref = "SharpDX.Direct2D1.Device"/></strong> object, even if you pass the same <strong><see cref = "SharpDX.DXGI.Device"/></strong> multiple times.</p>
        /// </remarks>
        /// <doc-id>hh404599</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory1::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out, Fast] ID2D1Device** d2dDevice)</unmanaged>
        /// <unmanaged-short>ID2D1Factory1::CreateDevice</unmanaged-short>
        internal unsafe void CreateDevice(SharpDX.DXGI.Device dxgiDevice, SharpDX.Direct2D1.Device d2dDevice)
        {
            System.IntPtr dxgiDevice_ = System.IntPtr.Zero;
            System.IntPtr d2dDevice_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            dxgiDevice_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Device>(dxgiDevice);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)dxgiDevice_, &d2dDevice_, (*(void ***)this._nativePointer)[17]);
            (d2dDevice).NativePointer = d2dDevice_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a <strong><see cref = "SharpDX.Direct2D1.StrokeStyle1"/></strong> object.</p>
        /// </summary>
        /// <param name = "strokeStyleProperties">No documentation.</param>
        /// <param name = "dashes">No documentation.</param>
        /// <param name = "dashesCount">No documentation.</param>
        /// <param name = "strokeStyle">No documentation.</param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>It is valid to specify a dash array only if D2D1_DASH_STYLE_CUSTOM is also specified.</p>
        /// </remarks>
        /// <doc-id>hh404605</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory1::CreateStrokeStyle([In] const D2D1_STROKE_STYLE_PROPERTIES1* strokeStyleProperties,[In, Buffer, Optional] const float* dashes,[In] unsigned int dashesCount,[Out, Fast] ID2D1StrokeStyle1** strokeStyle)</unmanaged>
        /// <unmanaged-short>ID2D1Factory1::CreateStrokeStyle</unmanaged-short>
        internal unsafe void CreateStrokeStyle(ref SharpDX.Direct2D1.StrokeStyleProperties1 strokeStyleProperties, System.Single[] dashes, System.Int32 dashesCount, SharpDX.Direct2D1.StrokeStyle1 strokeStyle)
        {
            System.IntPtr strokeStyle_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *dashes_ = dashes)
                fixed (void *strokeStyleProperties_ = &strokeStyleProperties)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, strokeStyleProperties_, dashes_, dashesCount, &strokeStyle_, (*(void ***)this._nativePointer)[18]);
            (strokeStyle).NativePointer = strokeStyle_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.Direct2D1.PathGeometry1"/></strong> object.</p>
        /// </summary>
        /// <param name = "athGeometryRef">No documentation.</param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh404602</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory1::CreatePathGeometry([Out, Fast] ID2D1PathGeometry1** pathGeometry)</unmanaged>
        /// <unmanaged-short>ID2D1Factory1::CreatePathGeometry</unmanaged-short>
        internal unsafe void CreatePathGeometry(SharpDX.Direct2D1.PathGeometry1 athGeometryRef)
        {
            System.IntPtr athGeometryRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &athGeometryRef_, (*(void ***)this._nativePointer)[19]);
            (athGeometryRef).NativePointer = athGeometryRef_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a new drawing state block, this can be used in subsequent SaveDrawingState and RestoreDrawingState operations on the render target. </p>
        /// </summary>
        /// <param name = "drawingStateDescription"><dd>  <p>The drawing state description structure.</p> </dd></param>
        /// <param name = "textRenderingParams"><dd>  <p>The address of the newly created drawing state block.</p> </dd></param>
        /// <param name = "drawingStateBlock"><dd>  <p>The address of the newly created drawing state block.</p> </dd></param>
        /// <returns><p> The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call. </td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <doc-id>jj841162</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory1::CreateDrawingStateBlock([In, Optional] const D2D1_DRAWING_STATE_DESCRIPTION1* drawingStateDescription,[In, Optional] IDWriteRenderingParams* textRenderingParams,[Out, Fast] ID2D1DrawingStateBlock1** drawingStateBlock)</unmanaged>
        /// <unmanaged-short>ID2D1Factory1::CreateDrawingStateBlock</unmanaged-short>
        internal unsafe void CreateDrawingStateBlock(SharpDX.Direct2D1.DrawingStateDescription1? drawingStateDescription, SharpDX.DirectWrite.RenderingParams textRenderingParams, SharpDX.Direct2D1.DrawingStateBlock1 drawingStateBlock)
        {
            SharpDX.Direct2D1.DrawingStateDescription1 drawingStateDescription_;
            System.IntPtr textRenderingParams_ = System.IntPtr.Zero;
            System.IntPtr drawingStateBlock_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (drawingStateDescription != null)
                drawingStateDescription_ = drawingStateDescription.Value;
            textRenderingParams_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.RenderingParams>(textRenderingParams);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, drawingStateDescription == null ? (void *)0 : &drawingStateDescription_, (void *)textRenderingParams_, &drawingStateBlock_, (*(void ***)this._nativePointer)[20]);
            (drawingStateBlock).NativePointer = drawingStateBlock_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new <strong><see cref = "SharpDX.Direct2D1.GdiMetafile"/></strong> object that you can use to replay metafile content. </p>
        /// </summary>
        /// <param name = "metafileStream">No documentation.</param>
        /// <param name = "metafile">No documentation.</param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh847995</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory1::CreateGdiMetafile([In] IStream* metafileStream,[Out] ID2D1GdiMetafile** metafile)</unmanaged>
        /// <unmanaged-short>ID2D1Factory1::CreateGdiMetafile</unmanaged-short>
        internal unsafe void CreateGdiMetafile(SharpDX.Win32.IStream metafileStream, out SharpDX.Direct2D1.GdiMetafile metafile)
        {
            System.IntPtr metafileStream_ = System.IntPtr.Zero;
            System.IntPtr metafile_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            metafileStream_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Win32.IStream>(metafileStream);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)metafileStream_, &metafile_, (*(void ***)this._nativePointer)[21]);
            if (metafile_ != System.IntPtr.Zero)
                metafile = new SharpDX.Direct2D1.GdiMetafile(metafile_);
            else
                metafile = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Registers an effect within the factory instance with the property XML specified as a stream.</p>
        /// </summary>
        /// <param name = "classId"><dd>  <p>The identifier of the effect to be registered.</p> </dd></param>
        /// <param name = "ropertyXmlRef"><dd>  <p>A list of the effect properties, types, and metadata.</p> </dd></param>
        /// <param name = "bindings"><dd>  <p>An array of properties and methods.</p> <p> This binds a property by name to a particular method implemented by the effect author to handle the property.  The name must be found in the corresponding <em>propertyXml</em>. </p> </dd></param>
        /// <param name = "bindingsCount"><dd>  <p>The number of bindings in the binding array.</p> </dd></param>
        /// <param name = "effectFactory"><dd>  <p>The static factory that is used to create the corresponding effect.</p> </dd></param>
        /// <returns><p> The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call. </td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>Direct2D effects must define their properties at registration time via registration XML. An effect declares several required system properties,  and can also declare custom properties. See Custom effects for more information about formatting the <em>propertyXml</em> parameter. </p><p> <strong>RegisterEffect</strong> is both atomic and reference counted. To unregister an effect,  call <strong>UnregisterEffect</strong> with the  <em>classId</em> of the effect. </p><strong>Important</strong>??<strong>RegisterEffect</strong> does not hold a reference to the DLL or executable file in which  the effect is contained. The application must independently  make sure that the lifetime of the DLL or executable file completely contains all instances of each registered and created effect.?<p>Aside from the built-in effects that are globally registered, this API registers effects only for this factory, derived device,  and device context interfaces.</p>
        /// </remarks>
        /// <doc-id>hh847996</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory1::RegisterEffectFromStream([In] const GUID&amp; classId,[In] IStream* propertyXml,[In, Buffer, Optional] const D2D1_PROPERTY_BINDING* bindings,[In] unsigned int bindingsCount,[In] const __function__stdcall* effectFactory)</unmanaged>
        /// <unmanaged-short>ID2D1Factory1::RegisterEffectFromStream</unmanaged-short>
        internal unsafe void RegisterEffectFromStream(System.Guid classId, SharpDX.Win32.IStream ropertyXmlRef, SharpDX.Direct2D1.PropertyBinding[] bindings, System.Int32 bindingsCount, SharpDX.FunctionCallback effectFactory)
        {
            System.IntPtr ropertyXmlRef_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.PropertyBinding.__Native[] bindings_ = bindings == null ? null : new SharpDX.Direct2D1.PropertyBinding.__Native[bindings.Length];
            SharpDX.Result __result__;
            ropertyXmlRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Win32.IStream>(ropertyXmlRef);
            if (bindings != null)
                for (int i = 0; i < bindings.Length; ++i)
                    if (bindings != null)
                        bindings[i].__MarshalTo(ref (bindings_)[i]);
            fixed (void *_bindings = bindings_)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &classId, (void *)ropertyXmlRef_, _bindings, bindingsCount, effectFactory, (*(void ***)this._nativePointer)[22]);
            if (bindings != null)
                for (int i = 0; i < bindings.Length; ++i)
                    if (bindings != null)
                        bindings[i].__MarshalFree(ref (bindings_)[i]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Registers an effect within the factory instance with the property XML specified as a string.</p>
        /// </summary>
        /// <param name = "classId"><dd>  <p>The identifier of the effect to be registered.</p> </dd></param>
        /// <param name = "ropertyXmlRef"><dd>  <p>A list of the effect properties, types, and metadata.</p> </dd></param>
        /// <param name = "bindings"><dd>  <p>An array of properties and methods.</p> <p> This binds a property by name to a particular method implemented by the effect author to handle the property.  The name must be found in the corresponding <em>propertyXml</em>. </p> </dd></param>
        /// <param name = "bindingsCount"><dd>  <p>The number of bindings in the binding array.</p> </dd></param>
        /// <param name = "effectFactory"><dd>  <p>The static factory that is used to create the corresponding effect.</p> </dd></param>
        /// <returns><p> The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table. </p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call. </td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>Direct2D effects must define their properties at registration time via registration XML. An effect declares several required system properties,  and can also declare custom properties. See Custom effects for more information about formatting the <em>propertyXml</em> parameter. </p><p><strong>RegisterEffect</strong> is both atomic and reference counted. To unregister an effect,  call <strong>UnregisterEffect</strong> with the  <em>classId</em> of the effect. </p><strong>Important</strong>??<strong>RegisterEffect</strong> does not hold a reference to the DLL or executable file in which  the effect is contained. The application must independently  make sure that the lifetime of the DLL or executable file completely contains all instances of each registered and created effect.?<p>Aside from the built-in effects that are globally registered, this API registers effects only for  this factory and derived device and device context interfaces.</p>
        /// </remarks>
        /// <doc-id>hh404614</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory1::RegisterEffectFromString([In] const GUID&amp; classId,[In] const wchar_t* propertyXml,[In, Buffer, Optional] const D2D1_PROPERTY_BINDING* bindings,[In] unsigned int bindingsCount,[In] const __function__stdcall* effectFactory)</unmanaged>
        /// <unmanaged-short>ID2D1Factory1::RegisterEffectFromString</unmanaged-short>
        internal unsafe void RegisterEffectFromString(System.Guid classId, System.String ropertyXmlRef, SharpDX.Direct2D1.PropertyBinding[] bindings, System.Int32 bindingsCount, SharpDX.FunctionCallback effectFactory)
        {
            SharpDX.Direct2D1.PropertyBinding.__Native[] bindings_ = bindings == null ? null : new SharpDX.Direct2D1.PropertyBinding.__Native[bindings.Length];
            SharpDX.Result __result__;
            if (bindings != null)
                for (int i = 0; i < bindings.Length; ++i)
                    if (bindings != null)
                        bindings[i].__MarshalTo(ref (bindings_)[i]);
            fixed (void *_bindings = bindings_)
                fixed (char *ropertyXmlRef_ = ropertyXmlRef)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &classId, (void *)ropertyXmlRef_, _bindings, bindingsCount, effectFactory, (*(void ***)this._nativePointer)[23]);
            if (bindings != null)
                for (int i = 0; i < bindings.Length; ++i)
                    if (bindings != null)
                        bindings[i].__MarshalFree(ref (bindings_)[i]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Unregisters an  effect within the factory instance that corresponds to the <em>classId</em> provided. </p>
        /// </summary>
        /// <param name = "classId"><dd>  <p>The identifier of the effect to be unregistered.</p> </dd></param>
        /// <returns><p><see cref = "EffectIsNotRegistered"/> if the effect is not registered, <see cref = "SharpDX.Result.Ok"/> otherwise.</p></returns>
        /// <remarks>
        /// <p>In order for the effect to be fully unloaded, you must call <strong>UnregisterEffect</strong> the same number of times that you have registered the effect.</p><p>The <strong>UnregisterEffect</strong> method unregisters only those effects that are registered on the same factory. It cannot be used to unregister a built-in effect.</p>
        /// </remarks>
        /// <doc-id>hh404617</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory1::UnregisterEffect([In] const GUID&amp; classId)</unmanaged>
        /// <unmanaged-short>ID2D1Factory1::UnregisterEffect</unmanaged-short>
        internal unsafe void UnregisterEffect(System.Guid classId)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &classId, (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns the class IDs of the currently registered effects and global effects on this factory.</p>
        /// </summary>
        /// <param name = "effects"><dd>  <p>When this method returns, contains an array of effects. <strong><c>null</c></strong> if no effects are retrieved.</p> </dd></param>
        /// <param name = "effectsCount"><dd>  <p>The capacity of the <em>effects</em> array.</p> </dd></param>
        /// <param name = "effectsReturned"><dd>  <p>When this method returns, contains the  number of effects copied into <em>effects</em>.</p> </dd></param>
        /// <param name = "effectsRegistered"><dd>  <p>When this method returns, contains the number of effects currently registered in the system.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)</td><td><em>effectsRegistered</em> is larger than <em>effectCount</em>.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The set of class IDs will be atomically returned by the API. The set will not be interrupted by other threads registering or unregistering effects.</p><p>If <em>effectsRegistered</em> is larger than <em>effectCount</em>, the supplied array will still be filled to capacity with the current set of registered effects. This method returns the CLSIDs for all global effects and all effects registered to this factory.</p>
        /// </remarks>
        /// <doc-id>hh404612</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory1::GetRegisteredEffects([Out, Buffer, Optional] GUID* effects,[In] unsigned int effectsCount,[Out, Optional] unsigned int* effectsReturned,[Out, Optional] unsigned int* effectsRegistered)</unmanaged>
        /// <unmanaged-short>ID2D1Factory1::GetRegisteredEffects</unmanaged-short>
        internal unsafe void GetRegisteredEffects(System.Guid[] effects, System.Int32 effectsCount, out System.Int32 effectsReturned, out System.Int32 effectsRegistered)
        {
            SharpDX.Result __result__;
            fixed (void *effectsRegistered_ = &effectsRegistered)
                fixed (void *effectsReturned_ = &effectsReturned)
                    fixed (void *effects_ = effects)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, effects_, effectsCount, effectsReturned_, effectsRegistered_, (*(void ***)this._nativePointer)[25]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the properties of an effect.</p>
        /// </summary>
        /// <param name = "effectId"><dd>  <p>The ID of the effect to retrieve properties from.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains the address of a reference to the property interface that can be used to query the metadata of the effect.</p> </dd></returns>
        /// <remarks>
        /// <p>The returned effect properties will have all the mutable properties for the effect set to a default of <strong><c>null</c></strong>, or an  empty value. </p><ul> <li>Value types will be zero-filled.</li> <li>Blob and string types will be zero-length.</li> <li>Array types will have length 1 and the element of the array will conform to the previous rules.</li> </ul><p>This method cannot be used to return the properties for any effect not visible to <strong>ID2D1DeviceContext::CreateEffect</strong>.</p>
        /// </remarks>
        /// <doc-id>hh404608</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory1::GetEffectProperties([In] const GUID&amp; effectId,[Out] ID2D1Properties** properties)</unmanaged>
        /// <unmanaged-short>ID2D1Factory1::GetEffectProperties</unmanaged-short>
        public unsafe SharpDX.Direct2D1.Properties GetEffectProperties(System.Guid effectId)
        {
            SharpDX.Direct2D1.Properties ropertiesRef;
            System.IntPtr ropertiesRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &effectId, &ropertiesRef_, (*(void ***)this._nativePointer)[26]);
            if (ropertiesRef_ != System.IntPtr.Zero)
                ropertiesRef = new SharpDX.Direct2D1.Properties(ropertiesRef_);
            else
                ropertiesRef = null;
            __result__.CheckError();
            return ropertiesRef;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("94f81a73-9212-4376-9c58-b16a3a0d3992")]
    public partial class Factory2 : SharpDX.Direct2D1.Factory1
    {
        public Factory2(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory2(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory2(nativePtr);
        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.Direct2D1.Device1"/></strong> object.  </p>
        /// </summary>
        /// <param name = "dxgiDevice">No documentation.</param>
        /// <param name = "d2dDevice1">No documentation.</param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> <tr><td>D3DERR_OUTOFVIDEOMEMORY</td><td>Direct3D does not have enough display memory to perform the operation.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The Direct2D device defines a resource domain in which a set of Direct2D objects and Direct2D device contexts can be used together.  Each call to <strong>CreateDevice</strong> returns a unique <strong><see cref = "SharpDX.Direct2D1.Device1"/></strong> object, even if you pass the same <strong><see cref = "SharpDX.DXGI.Device"/></strong> multiple times.</p>
        /// </remarks>
        /// <doc-id>dn280482</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory2::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out, Fast] ID2D1Device1** d2dDevice1)</unmanaged>
        /// <unmanaged-short>ID2D1Factory2::CreateDevice</unmanaged-short>
        internal unsafe void CreateDevice(SharpDX.DXGI.Device dxgiDevice, SharpDX.Direct2D1.Device1 d2dDevice1)
        {
            System.IntPtr dxgiDevice_ = System.IntPtr.Zero;
            System.IntPtr d2dDevice1_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            dxgiDevice_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Device>(dxgiDevice);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)dxgiDevice_, &d2dDevice1_, (*(void ***)this._nativePointer)[27]);
            (d2dDevice1).NativePointer = d2dDevice1_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("0869759f-4f00-413f-b03e-2bda45404d0f")]
    public partial class Factory3 : SharpDX.Direct2D1.Factory2
    {
        public Factory3(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory3(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory3(nativePtr);
        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.Direct2D1.Device2"/></strong> object. </p>
        /// </summary>
        /// <param name = "dxgiDevice">No documentation.</param>
        /// <param name = "d2dDevice2">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn900395</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory3::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out, Fast] ID2D1Device2** d2dDevice2)</unmanaged>
        /// <unmanaged-short>ID2D1Factory3::CreateDevice</unmanaged-short>
        internal unsafe void CreateDevice(SharpDX.DXGI.Device dxgiDevice, SharpDX.Direct2D1.Device2 d2dDevice2)
        {
            System.IntPtr dxgiDevice_ = System.IntPtr.Zero;
            System.IntPtr d2dDevice2_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            dxgiDevice_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Device>(dxgiDevice);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)dxgiDevice_, &d2dDevice2_, (*(void ***)this._nativePointer)[28]);
            (d2dDevice2).NativePointer = d2dDevice2_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("bd4ec2d2-0662-4bee-ba8e-6f29f032e096")]
    public partial class Factory4 : SharpDX.Direct2D1.Factory3
    {
        public Factory4(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory4(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory4(nativePtr);
        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.Direct2D1.Device3"/></strong> object.</p>
        /// </summary>
        /// <param name = "dxgiDevice">No documentation.</param>
        /// <param name = "d2dDevice3">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>mt619832</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory4::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out, Fast] ID2D1Device3** d2dDevice3)</unmanaged>
        /// <unmanaged-short>ID2D1Factory4::CreateDevice</unmanaged-short>
        internal unsafe void CreateDevice(SharpDX.DXGI.Device dxgiDevice, SharpDX.Direct2D1.Device3 d2dDevice3)
        {
            System.IntPtr dxgiDevice_ = System.IntPtr.Zero;
            System.IntPtr d2dDevice3_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            dxgiDevice_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Device>(dxgiDevice);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)dxgiDevice_, &d2dDevice3_, (*(void ***)this._nativePointer)[29]);
            (d2dDevice3).NativePointer = d2dDevice3_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("c4349994-838e-4b0f-8cab-44997d9eeacc")]
    public partial class Factory5 : SharpDX.Direct2D1.Factory4
    {
        public Factory5(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory5(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory5(nativePtr);
        /// <summary>
        /// <p> Creates an <strong><see cref = "SharpDX.Direct2D1.Device4"/></strong> object. </p>
        /// </summary>
        /// <param name = "dxgiDevice">No documentation.</param>
        /// <param name = "d2dDevice4">No documentation.</param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code.</p></returns>
        /// <doc-id>mt750192</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory5::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out, Fast] ID2D1Device4** d2dDevice4)</unmanaged>
        /// <unmanaged-short>ID2D1Factory5::CreateDevice</unmanaged-short>
        internal unsafe void CreateDevice(SharpDX.DXGI.Device dxgiDevice, SharpDX.Direct2D1.Device4 d2dDevice4)
        {
            System.IntPtr dxgiDevice_ = System.IntPtr.Zero;
            System.IntPtr d2dDevice4_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            dxgiDevice_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Device>(dxgiDevice);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)dxgiDevice_, &d2dDevice4_, (*(void ***)this._nativePointer)[30]);
            (d2dDevice4).NativePointer = d2dDevice4_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("f9976f46-f642-44c1-97ca-da32ea2a2635")]
    public partial class Factory6 : SharpDX.Direct2D1.Factory5
    {
        public Factory6(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Factory6(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Factory6(nativePtr);
        /// <summary>
        /// <p>Creates Direct2D resources.</p>
        /// </summary>
        /// <param name = "dxgiDevice">No documentation.</param>
        /// <param name = "d2dDevice5">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <remarks>
        /// <p>The <strong><see cref = "SharpDX.Direct2D1.Factory"/></strong> interface is the starting point for using Direct2D; it's what you use to create other Direct2D resources that you can use to draw or describe shapes.   </p><p>A factory defines a set of Create<em>Resource</em> methods that can produce the following drawing resources:</p><p> </p><ul> <li>Render targets: objects that render drawing commands.</li> <li>Drawing state blocks: objects that store drawing state information, such as the current transformation and antialiasing mode.</li> <li>Geometries: objects that represent simple and potentially complex shapes.</li> </ul><p>To create an <strong><see cref = "SharpDX.Direct2D1.Factory"/></strong>, you use one of the <strong>CreateFactory</strong> methods. You should retain the <strong><see cref = "SharpDX.Direct2D1.Factory"/></strong> instance for as long as you use Direct2D resources; in general, you shouldn't need to recreate it when the application is running. For more information about Direct2D resources, see the Resources Overview.</p>
        /// </remarks>
        /// <doc-id>dd371246</doc-id>
        /// <unmanaged>HRESULT ID2D1Factory6::CreateDevice([In] IDXGIDevice* dxgiDevice,[Out, Fast] ID2D1Device5** d2dDevice5)</unmanaged>
        /// <unmanaged-short>ID2D1Factory6::CreateDevice</unmanaged-short>
        internal unsafe void CreateDevice(SharpDX.DXGI.Device dxgiDevice, SharpDX.Direct2D1.Device5 d2dDevice5)
        {
            System.IntPtr dxgiDevice_ = System.IntPtr.Zero;
            System.IntPtr d2dDevice5_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            dxgiDevice_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DXGI.Device>(dxgiDevice);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)dxgiDevice_, &d2dDevice5_, (*(void ***)this._nativePointer)[31]);
            (d2dDevice5).NativePointer = d2dDevice5_;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("e0db51c3-6f77-4bae-b3d5-e47509b35838")]
    public partial class GdiInteropRenderTarget : SharpDX.ComObject
    {
        public GdiInteropRenderTarget(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GdiInteropRenderTarget(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GdiInteropRenderTarget(nativePtr);
        /// <summary>
        /// <p>Retrieves the device context associated with this render target. </p>
        /// </summary>
        /// <param name = "mode"><dd>  <p>A value that specifies whether the device context should be cleared.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains the device context associated with this render target. You must allocate storage for this parameter.  </p> </dd></returns>
        /// <remarks>
        /// <p>Calling this method flushes the render target.</p><p>This command can be called only after <strong>BeginDraw</strong> and before <strong>EndDraw</strong>. </p><strong>Note</strong>??In Windows?7 and earlier, you should not call <strong>GetDC</strong> between <strong>PushAxisAlignedClip</strong>/<strong>PopAxisAlignedClip</strong> commands or between <strong>PushLayer</strong>/<strong>PopLayer</strong>.  However, this restriction does not apply to Windows?8 and later.?<p> <strong>ReleaseDC</strong> must be called once for each call to <strong>GetDC</strong>.</p>
        /// </remarks>
        /// <doc-id>dd371323</doc-id>
        /// <unmanaged>HRESULT ID2D1GdiInteropRenderTarget::GetDC([In] D2D1_DC_INITIALIZE_MODE mode,[Out] HDC* hdc)</unmanaged>
        /// <unmanaged-short>ID2D1GdiInteropRenderTarget::GetDC</unmanaged-short>
        public unsafe System.IntPtr GetDC(SharpDX.Direct2D1.DeviceContextInitializeMode mode)
        {
            System.IntPtr hdc;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)mode), &hdc, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
            return hdc;
        }

        /// <summary>
        /// <p>Indicates that drawing with the device context retrieved using the <strong>GetDC</strong> method is finished.  </p>
        /// </summary>
        /// <param name = "update">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p><strong>ReleaseDC</strong> must be called once for each call to <strong>GetDC</strong>.</p>
        /// </remarks>
        /// <doc-id>dd371327</doc-id>
        /// <unmanaged>HRESULT ID2D1GdiInteropRenderTarget::ReleaseDC([In, Optional] const RECT* update)</unmanaged>
        /// <unmanaged-short>ID2D1GdiInteropRenderTarget::ReleaseDC</unmanaged-short>
        public unsafe void ReleaseDC(SharpDX.Mathematics.Interop.RawRectangle? update)
        {
            SharpDX.Mathematics.Interop.RawRectangle update_;
            SharpDX.Result __result__;
            if (update != null)
                update_ = update.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, update == null ? (void *)0 : &update_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2f543dc3-cfc1-4211-864f-cfd91c6f3395")]
    public partial class GdiMetafile : SharpDX.Direct2D1.Resource
    {
        public GdiMetafile(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GdiMetafile(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GdiMetafile(nativePtr);
        /// <summary>
        /// <p> Gets the bounds of the metafile, in device-independent pixels (DIPs), as reported in the metafile?s header.</p>
        /// </summary>
        /// <doc-id>hh871463</doc-id>
        /// <unmanaged>GetBounds</unmanaged>
        /// <unmanaged-short>GetBounds</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangleF Bounds
        {
            get
            {
                GetBounds(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>This method streams the contents of the command  to the given metafile  sink. </p>
        /// </summary>
        /// <param name = "sink"><dd>  <p>The sink into which Direct2D  will call back.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh871464</doc-id>
        /// <unmanaged>HRESULT ID2D1GdiMetafile::Stream([In] ID2D1GdiMetafileSink* sink)</unmanaged>
        /// <unmanaged-short>ID2D1GdiMetafile::Stream</unmanaged-short>
        public unsafe void Stream(SharpDX.Direct2D1.GdiMetafileSink sink)
        {
            System.IntPtr sink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            sink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.GdiMetafileSink>(sink);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)sink_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Gets the bounds of the metafile, in device-independent pixels (DIPs), as reported in the metafile?s header.</p>
        /// </summary>
        /// <param name = "bounds"><dd>  <p>The bounds, in DIPs, of the metafile.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid value was passed to the method.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh871463</doc-id>
        /// <unmanaged>HRESULT ID2D1GdiMetafile::GetBounds([Out] D2D_RECT_F* bounds)</unmanaged>
        /// <unmanaged-short>ID2D1GdiMetafile::GetBounds</unmanaged-short>
        internal unsafe void GetBounds(out SharpDX.Mathematics.Interop.RawRectangleF bounds)
        {
            bounds = default (SharpDX.Mathematics.Interop.RawRectangleF);
            SharpDX.Result __result__;
            fixed (void *bounds_ = &bounds)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, bounds_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2e69f9e8-dd3f-4bf9-95ba-c04f49d788df")]
    public partial class GdiMetafile1 : SharpDX.Direct2D1.GdiMetafile
    {
        public GdiMetafile1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GdiMetafile1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GdiMetafile1(nativePtr);
        /// <summary>
        /// <p>Gets the bounds of the metafile in source space in DIPs. This corresponds       to the frame rect in an EMF/EMF+.</p>
        /// </summary>
        /// <doc-id>dn900402</doc-id>
        /// <unmanaged>GetSourceBounds</unmanaged>
        /// <unmanaged-short>GetSourceBounds</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangleF SourceBounds
        {
            get
            {
                GetSourceBounds(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Gets the DPI reported by the metafile.</p>
        /// </summary>
        /// <param name = "dpiX"><dd>  <p>Receives the horizontal DPI reported by the metafile.</p> </dd></param>
        /// <param name = "dpiY"><dd>  <p>Receives the vertical DPI reported by the metafile.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn900401</doc-id>
        /// <unmanaged>HRESULT ID2D1GdiMetafile1::GetDpi([Out] float* dpiX,[Out] float* dpiY)</unmanaged>
        /// <unmanaged-short>ID2D1GdiMetafile1::GetDpi</unmanaged-short>
        public unsafe void GetDpi(out System.Single dpiX, out System.Single dpiY)
        {
            SharpDX.Result __result__;
            fixed (void *dpiY_ = &dpiY)
                fixed (void *dpiX_ = &dpiX)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, dpiX_, dpiY_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the bounds of the metafile in source space in DIPs. This corresponds       to the frame rect in an EMF/EMF+.</p>
        /// </summary>
        /// <param name = "bounds"><dd>  <p>The bounds, in DIPs, of the metafile.</p> </dd></param>
        /// <returns><p><see cref = "SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "SharpDX.Result"/>.</p></returns>
        /// <doc-id>dn900402</doc-id>
        /// <unmanaged>HRESULT ID2D1GdiMetafile1::GetSourceBounds([Out] D2D_RECT_F* bounds)</unmanaged>
        /// <unmanaged-short>ID2D1GdiMetafile1::GetSourceBounds</unmanaged-short>
        internal unsafe void GetSourceBounds(out SharpDX.Mathematics.Interop.RawRectangleF bounds)
        {
            bounds = default (SharpDX.Mathematics.Interop.RawRectangleF);
            SharpDX.Result __result__;
            fixed (void *bounds_ = &bounds)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, bounds_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("82237326-8111-4f7c-bcf4-b5c1175564fe")]
    public partial interface GdiMetafileSink : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("fd0ecb6b-91e6-411e-8655-395e760f91b4")]
    public partial interface GdiMetafileSink1 : SharpDX.Direct2D1.GdiMetafileSink
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("fd0ecb6b-91e6-411e-8655-395e760f91b4")]
    internal partial class GdiMetafileSink1Native : SharpDX.Direct2D1.GdiMetafileSinkNative, SharpDX.Direct2D1.GdiMetafileSink1
    {
        public GdiMetafileSink1Native(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GdiMetafileSink1Native(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GdiMetafileSink1Native(nativePtr);
        /// <summary>
        /// <p>Provides access to metafile records, including their type, data, and flags.</p>
        /// </summary>
        /// <param name = "recordType"><dd>  <p>The type of metafile record being processed. Please see MS-EMF and MS-EMFPLUS for a list of record types.</p> </dd></param>
        /// <param name = "recordData"><dd>  <p>The data contained in this record. Please see MS-EMF and MS-EMFPLUS for information on record data layouts.</p> </dd></param>
        /// <param name = "recordDataSize"><dd>  <p>TThe size of the data pointed to by recordData. </p> </dd></param>
        /// <param name = "flags"><dd>  <p>The set of flags set for this record. Please see MS-EMF and MS-EMFPLUS for information on record flags.</p> </dd></param>
        /// <returns><p><see cref = "SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "SharpDX.Result"/>.</p></returns>
        /// <remarks>
        /// <p>For details on the EMF and EMF+ formats, please see Microsoft technical documents  MS-EMF and MS-EMFPLUS.</p>
        /// </remarks>
        /// <doc-id>dn900404</doc-id>
        /// <unmanaged>HRESULT ID2D1GdiMetafileSink1::ProcessRecord([In] DWORD recordType,[In, Optional] const void* recordData,[In] DWORD recordDataSize,[In] unsigned int flags)</unmanaged>
        /// <unmanaged-short>ID2D1GdiMetafileSink1::ProcessRecord</unmanaged-short>
        internal unsafe void ProcessRecord_(System.Int32 recordType, System.IntPtr recordData, System.Int32 recordDataSize, System.Int32 flags)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, recordType, (void *)recordData, recordDataSize, flags, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("82237326-8111-4f7c-bcf4-b5c1175564fe")]
    internal partial class GdiMetafileSinkNative : SharpDX.ComObject, SharpDX.Direct2D1.GdiMetafileSink
    {
        public GdiMetafileSinkNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GdiMetafileSinkNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GdiMetafileSinkNative(nativePtr);
        /// <summary>
        /// <p> This method is called once for each record stored in a metafile.</p>
        /// </summary>
        /// <param name = "recordType"><dd>  <p>The type of the record.</p> </dd></param>
        /// <param name = "recordData"><dd>  <p>The data for the record.</p> </dd></param>
        /// <param name = "recordDataSize"><dd>  <p>The byte size of the record data.</p> </dd></param>
        /// <returns><p>Return true if the record is successfully.</p></returns>
        /// <doc-id>hh871462</doc-id>
        /// <unmanaged>HRESULT ID2D1GdiMetafileSink::ProcessRecord([In] DWORD recordType,[In, Optional] const void* recordData,[In] DWORD recordDataSize)</unmanaged>
        /// <unmanaged-short>ID2D1GdiMetafileSink::ProcessRecord</unmanaged-short>
        internal unsafe void ProcessRecord_(System.Int32 recordType, System.IntPtr recordData, System.Int32 recordDataSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, recordType, (void *)recordData, recordDataSize, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd906a1-12e2-11dc-9fed-001143a055f9")]
    public partial class Geometry : SharpDX.Direct2D1.Resource
    {
        public Geometry(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Geometry(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Geometry(nativePtr);
        /// <summary>
        /// Retrieves the bounds of the geometry.
        /// </summary>
        /// <param name = "worldTransform">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>dd742751</doc-id>
        /// <unmanaged>HRESULT ID2D1Geometry::GetBounds([In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[Out] D2D_RECT_F* bounds)</unmanaged>
        /// <unmanaged-short>ID2D1Geometry::GetBounds</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawRectangleF GetBounds(SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
            SharpDX.Mathematics.Interop.RawRectangleF bounds;
            SharpDX.Result __result__;
            if (worldTransform != null)
                worldTransform_ = worldTransform.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, worldTransform == null ? (void *)0 : &worldTransform_, &bounds, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
            return bounds;
        }

        /// <summary>
        /// <p>Gets the bounds of the geometry after it has been widened by the specified stroke width and style and transformed by the specified matrix.</p>
        /// </summary>
        /// <param name = "strokeWidth"><dd>  <p>The amount by which to widen the geometry by stroking its outline.</p> </dd></param>
        /// <param name = "strokeStyle"><dd>  <p>The style of the stroke that widens the geometry.</p> </dd></param>
        /// <param name = "worldTransform"><dd>  <p>A transform to apply to the geometry after the geometry is transformed and after the geometry has been stroked.</p> </dd></param>
        /// <param name = "flatteningTolerance"><dd>  <p>When this method returns, contains the bounds of the widened geometry. You must allocate storage for this parameter.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains the bounds of the widened geometry. You must allocate storage for this parameter.</p> </dd></returns>
        /// <doc-id>dd316714</doc-id>
        /// <unmanaged>HRESULT ID2D1Geometry::GetWidenedBounds([In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] D2D_RECT_F* bounds)</unmanaged>
        /// <unmanaged-short>ID2D1Geometry::GetWidenedBounds</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawRectangleF GetWidenedBounds(System.Single strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, System.Single flatteningTolerance)
        {
            System.IntPtr strokeStyle_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
            SharpDX.Mathematics.Interop.RawRectangleF bounds;
            SharpDX.Result __result__;
            strokeStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.StrokeStyle>(strokeStyle);
            if (worldTransform != null)
                worldTransform_ = worldTransform.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, strokeWidth, (void *)strokeStyle_, worldTransform == null ? (void *)0 : &worldTransform_, flatteningTolerance, &bounds, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
            return bounds;
        }

        /// <summary>
        /// <p>Determines whether the geometry's stroke contains the specified point given the specified stroke thickness, style, and transform. </p>
        /// </summary>
        /// <param name = "point"><dd>  <p>The point to test for containment.</p> </dd></param>
        /// <param name = "strokeWidth"><dd>  <p>The thickness of the stroke to apply.</p> </dd></param>
        /// <param name = "strokeStyle"><dd>  <p>The style of stroke to apply.</p> </dd></param>
        /// <param name = "worldTransform"><dd>  <p>The transform to apply to the stroked geometry. </p> </dd></param>
        /// <param name = "flatteningTolerance"><dd>  <p>The numeric accuracy with which the precise geometric path and path intersection is calculated. Points missing the stroke by less than the tolerance are still considered inside.  Smaller values produce more accurate results but cause slower execution.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains a boolean value set to true if the geometry's stroke contains the specified point; otherwise, false. You must allocate storage for this parameter.</p> </dd></returns>
        /// <doc-id>dd316744</doc-id>
        /// <unmanaged>HRESULT ID2D1Geometry::StrokeContainsPoint([In] D2D_POINT_2F point,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>
        /// <unmanaged-short>ID2D1Geometry::StrokeContainsPoint</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool StrokeContainsPoint(SharpDX.Mathematics.Interop.RawVector2 point, System.Single strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, System.Single flatteningTolerance)
        {
            System.IntPtr strokeStyle_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
            SharpDX.Mathematics.Interop.RawBool contains;
            SharpDX.Result __result__;
            strokeStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.StrokeStyle>(strokeStyle);
            if (worldTransform != null)
                worldTransform_ = worldTransform.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, point, strokeWidth, (void *)strokeStyle_, worldTransform == null ? (void *)0 : &worldTransform_, flatteningTolerance, &contains, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
            return contains;
        }

        /// <summary>
        /// <p>Indicates whether the area filled by the geometry would contain the specified point given the specified flattening tolerance. </p>
        /// </summary>
        /// <param name = "point"><dd>  <p>The point to test.</p> </dd></param>
        /// <param name = "worldTransform"><dd>  <p>The transform to apply to the geometry prior to testing for containment, or <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "flatteningTolerance"><dd>  <p>The numeric accuracy with which the precise geometric path and path intersection is calculated. Points missing the fill by less than the tolerance are still considered inside.  Smaller values produce more accurate results but cause slower execution. </p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains a <strong><see cref = "SharpDX.Mathematics.Interop.RawBool"/></strong> value that is <strong>TRUE</strong> if the area filled by the geometry contains <em>point</em>; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.You must allocate storage for this parameter.</p> </dd></returns>
        /// <doc-id>dd316687</doc-id>
        /// <unmanaged>HRESULT ID2D1Geometry::FillContainsPoint([In] D2D_POINT_2F point,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] BOOL* contains)</unmanaged>
        /// <unmanaged-short>ID2D1Geometry::FillContainsPoint</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool FillContainsPoint(SharpDX.Mathematics.Interop.RawVector2 point, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, System.Single flatteningTolerance)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
            SharpDX.Mathematics.Interop.RawBool contains;
            SharpDX.Result __result__;
            if (worldTransform != null)
                worldTransform_ = worldTransform.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, point, worldTransform == null ? (void *)0 : &worldTransform_, flatteningTolerance, &contains, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
            return contains;
        }

        /// <summary>
        /// <p>Describes the intersection between this geometry and the specified geometry. The comparison is performed by using the specified flattening tolerance.</p>
        /// </summary>
        /// <param name = "inputGeometry"><dd>  <p>The geometry to test. </p> </dd></param>
        /// <param name = "inputGeometryTransform"><dd>  <p>The transform to apply to <em>inputGeometry</em>, or <strong><c>null</c></strong>.</p> </dd></param>
        /// <param name = "flatteningTolerance"><dd>  <p>The maximum error allowed when constructing a polygonal approximation of the geometry. No point in the polygonal representation will diverge from the original geometry by more than the flattening tolerance. Smaller values produce more accurate results but cause slower execution.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains a reference to a value that describes how this geometry is related to <em>inputGeometry</em>. You must allocate storage for this parameter.  </p> </dd></returns>
        /// <remarks>
        /// <p>When interpreting the returned <em>relation</em> value, it is important to remember that the member <strong>D2D1_GEOMETRY_RELATION_IS_CONTAINED</strong> of the  <strong><see cref = "SharpDX.Direct2D1.GeometryRelation"/></strong> enumeration type means that this geometry is contained  inside <em>inputGeometry</em>, not that this geometry contains <em>inputGeometry</em>. </p><p>For  more information about how to interpret other possible return values, see <strong><see cref = "SharpDX.Direct2D1.GeometryRelation"/></strong>.</p>
        /// </remarks>
        /// <doc-id>dd316630</doc-id>
        /// <unmanaged>HRESULT ID2D1Geometry::CompareWithGeometry([In] ID2D1Geometry* inputGeometry,[In, Optional] const D2D_MATRIX_3X2_F* inputGeometryTransform,[In] float flatteningTolerance,[Out] D2D1_GEOMETRY_RELATION* relation)</unmanaged>
        /// <unmanaged-short>ID2D1Geometry::CompareWithGeometry</unmanaged-short>
        public unsafe SharpDX.Direct2D1.GeometryRelation Compare(SharpDX.Direct2D1.Geometry inputGeometry, SharpDX.Mathematics.Interop.RawMatrix3x2? inputGeometryTransform, System.Single flatteningTolerance)
        {
            System.IntPtr inputGeometry_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawMatrix3x2 inputGeometryTransform_;
            SharpDX.Direct2D1.GeometryRelation relation;
            SharpDX.Result __result__;
            inputGeometry_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Geometry>(inputGeometry);
            if (inputGeometryTransform != null)
                inputGeometryTransform_ = inputGeometryTransform.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)inputGeometry_, inputGeometryTransform == null ? (void *)0 : &inputGeometryTransform_, flatteningTolerance, &relation, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
            return relation;
        }

        /// <summary>
        /// <p>Creates a simplified version of the geometry that contains only lines and (optionally) cubic Bezier curves and writes the result to an <strong><see cref = "SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong>.</p>
        /// </summary>
        /// <param name = "simplificationOption">No documentation.</param>
        /// <param name = "worldTransform">No documentation.</param>
        /// <param name = "flatteningTolerance">No documentation.</param>
        /// <param name = "geometrySink">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316730</doc-id>
        /// <unmanaged>HRESULT ID2D1Geometry::Simplify([In] D2D1_GEOMETRY_SIMPLIFICATION_OPTION simplificationOption,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        /// <unmanaged-short>ID2D1Geometry::Simplify</unmanaged-short>
        public unsafe void Simplify(SharpDX.Direct2D1.GeometrySimplificationOption simplificationOption, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, System.Single flatteningTolerance, SharpDX.Direct2D1.SimplifiedGeometrySink geometrySink)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
            System.IntPtr geometrySink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (worldTransform != null)
                worldTransform_ = worldTransform.Value;
            geometrySink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SimplifiedGeometrySink>(geometrySink);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)simplificationOption), worldTransform == null ? (void *)0 : &worldTransform_, flatteningTolerance, (void *)geometrySink_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a set of clockwise-wound triangles that cover the geometry after it has been transformed using the specified matrix and flattened using the default tolerance.</p>
        /// </summary>
        /// <param name = "worldTransform"><dd>  <p>The transform to apply to this geometry.</p> </dd></param>
        /// <param name = "flatteningTolerance"><dd>  <p>The <strong><see cref = "SharpDX.Direct2D1.TessellationSink"/></strong> to which the tessellated is appended.</p> </dd></param>
        /// <param name = "tessellationSink"><dd>  <p>The <strong><see cref = "SharpDX.Direct2D1.TessellationSink"/></strong> to which the tessellated is appended.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316762</doc-id>
        /// <unmanaged>HRESULT ID2D1Geometry::Tessellate([In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[In] ID2D1TessellationSink* tessellationSink)</unmanaged>
        /// <unmanaged-short>ID2D1Geometry::Tessellate</unmanaged-short>
        public unsafe void Tessellate(SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, System.Single flatteningTolerance, SharpDX.Direct2D1.TessellationSink tessellationSink)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
            System.IntPtr tessellationSink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (worldTransform != null)
                worldTransform_ = worldTransform.Value;
            tessellationSink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.TessellationSink>(tessellationSink);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, worldTransform == null ? (void *)0 : &worldTransform_, flatteningTolerance, (void *)tessellationSink_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Combines this geometry with the specified geometry and stores the result in an <strong><see cref = "SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong>.  </p>
        /// </summary>
        /// <param name = "inputGeometry">No documentation.</param>
        /// <param name = "combineMode">No documentation.</param>
        /// <param name = "inputGeometryTransform">No documentation.</param>
        /// <param name = "flatteningTolerance">No documentation.</param>
        /// <param name = "geometrySink">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316617</doc-id>
        /// <unmanaged>HRESULT ID2D1Geometry::CombineWithGeometry([In] ID2D1Geometry* inputGeometry,[In] D2D1_COMBINE_MODE combineMode,[In, Optional] const D2D_MATRIX_3X2_F* inputGeometryTransform,[In] float flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        /// <unmanaged-short>ID2D1Geometry::CombineWithGeometry</unmanaged-short>
        public unsafe void Combine(SharpDX.Direct2D1.Geometry inputGeometry, SharpDX.Direct2D1.CombineMode combineMode, SharpDX.Mathematics.Interop.RawMatrix3x2? inputGeometryTransform, System.Single flatteningTolerance, SharpDX.Direct2D1.SimplifiedGeometrySink geometrySink)
        {
            System.IntPtr inputGeometry_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawMatrix3x2 inputGeometryTransform_;
            System.IntPtr geometrySink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            inputGeometry_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Geometry>(inputGeometry);
            if (inputGeometryTransform != null)
                inputGeometryTransform_ = inputGeometryTransform.Value;
            geometrySink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SimplifiedGeometrySink>(geometrySink);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)inputGeometry_, unchecked ((System.Int32)combineMode), inputGeometryTransform == null ? (void *)0 : &inputGeometryTransform_, flatteningTolerance, (void *)geometrySink_, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Computes the outline of the geometry and writes the result to an <strong><see cref = "SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong>.</p>
        /// </summary>
        /// <param name = "worldTransform">No documentation.</param>
        /// <param name = "flatteningTolerance">No documentation.</param>
        /// <param name = "geometrySink">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316722</doc-id>
        /// <unmanaged>HRESULT ID2D1Geometry::Outline([In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        /// <unmanaged-short>ID2D1Geometry::Outline</unmanaged-short>
        public unsafe void Outline(SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, System.Single flatteningTolerance, SharpDX.Direct2D1.SimplifiedGeometrySink geometrySink)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
            System.IntPtr geometrySink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (worldTransform != null)
                worldTransform_ = worldTransform.Value;
            geometrySink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SimplifiedGeometrySink>(geometrySink);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, worldTransform == null ? (void *)0 : &worldTransform_, flatteningTolerance, (void *)geometrySink_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Computes the area of the geometry after it has been transformed by the specified matrix and flattened using the specified tolerance.</p>
        /// </summary>
        /// <param name = "worldTransform"><dd>  <p>The transform to apply to this geometry before computing its area.</p> </dd></param>
        /// <param name = "flatteningTolerance"><dd>  <p>The maximum error allowed when constructing a polygonal approximation of the geometry. No point in the polygonal representation will diverge from the original geometry by more than the flattening tolerance. Smaller values produce more accurate results but cause slower execution. </p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains a reference to the area of the transformed, flattened version of this geometry. You must allocate storage for this parameter.</p> </dd></returns>
        /// <doc-id>dd316648</doc-id>
        /// <unmanaged>HRESULT ID2D1Geometry::ComputeArea([In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] float* area)</unmanaged>
        /// <unmanaged-short>ID2D1Geometry::ComputeArea</unmanaged-short>
        public unsafe System.Single ComputeArea(SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, System.Single flatteningTolerance)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
            System.Single area;
            SharpDX.Result __result__;
            if (worldTransform != null)
                worldTransform_ = worldTransform.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, worldTransform == null ? (void *)0 : &worldTransform_, flatteningTolerance, &area, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
            return area;
        }

        /// <summary>
        /// Calculates the length of the geometry as though each segment were unrolled into a line.
        /// </summary>
        /// <param name = "worldTransform">No documentation.</param>
        /// <param name = "flatteningTolerance">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>dd742744</doc-id>
        /// <unmanaged>HRESULT ID2D1Geometry::ComputeLength([In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] float* length)</unmanaged>
        /// <unmanaged-short>ID2D1Geometry::ComputeLength</unmanaged-short>
        public unsafe System.Single ComputeLength(SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, System.Single flatteningTolerance)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
            System.Single length;
            SharpDX.Result __result__;
            if (worldTransform != null)
                worldTransform_ = worldTransform.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, worldTransform == null ? (void *)0 : &worldTransform_, flatteningTolerance, &length, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
            return length;
        }

        /// <summary>
        /// <p>Calculates the point and tangent vector at the specified distance along the geometry after it has been transformed by the specified matrix and flattened using the default tolerance.</p>
        /// </summary>
        /// <param name = "length"><dd>  <p>The distance along the geometry of the point and tangent to find. If this distance is less then 0, this method calculates the first point in the geometry. If this distance is greater than the length of the geometry, this method calculates the last point in the geometry.</p> </dd></param>
        /// <param name = "worldTransform"><dd>  <p>The transform to apply to the geometry before calculating the specified point and tangent.</p> </dd></param>
        /// <param name = "flatteningTolerance"><dd>  <p>The location at the specified distance along the geometry. If the geometry is empty,  this point contains NaN as its x and y values.</p> </dd></param>
        /// <param name = "unitTangentVector"><dd>  <p>When this method returns, contains a reference to the tangent vector at the specified distance along the geometry. If the geometry is empty,  this vector contains NaN as its x and y values. You must allocate storage for this parameter.</p> </dd></param>
        /// <returns><dd>  <p>The location at the specified distance along the geometry. If the geometry is empty,  this point contains NaN as its x and y values.</p> </dd></returns>
        /// <doc-id>dd316686</doc-id>
        /// <unmanaged>HRESULT ID2D1Geometry::ComputePointAtLength([In] float length,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out, Optional] D2D_POINT_2F* point,[Out, Optional] D2D_POINT_2F* unitTangentVector)</unmanaged>
        /// <unmanaged-short>ID2D1Geometry::ComputePointAtLength</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawVector2 ComputePointAtLength(System.Single length, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, System.Single flatteningTolerance, out SharpDX.Mathematics.Interop.RawVector2 unitTangentVector)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
            SharpDX.Mathematics.Interop.RawVector2 ointRef;
            unitTangentVector = default (SharpDX.Mathematics.Interop.RawVector2);
            SharpDX.Result __result__;
            if (worldTransform != null)
                worldTransform_ = worldTransform.Value;
            fixed (void *unitTangentVector_ = &unitTangentVector)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, length, worldTransform == null ? (void *)0 : &worldTransform_, flatteningTolerance, &ointRef, unitTangentVector_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
            return ointRef;
        }

        /// <summary>
        /// <p>Widens the geometry by the specified stroke and writes the result to an <strong><see cref = "SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong> after it has been transformed by the specified matrix and flattened using the specified tolerance.</p>
        /// </summary>
        /// <param name = "strokeWidth">No documentation.</param>
        /// <param name = "strokeStyle">No documentation.</param>
        /// <param name = "worldTransform">No documentation.</param>
        /// <param name = "flatteningTolerance">No documentation.</param>
        /// <param name = "geometrySink">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd316766</doc-id>
        /// <unmanaged>HRESULT ID2D1Geometry::Widen([In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        /// <unmanaged-short>ID2D1Geometry::Widen</unmanaged-short>
        public unsafe void Widen(System.Single strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, System.Single flatteningTolerance, SharpDX.Direct2D1.SimplifiedGeometrySink geometrySink)
        {
            System.IntPtr strokeStyle_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
            System.IntPtr geometrySink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            strokeStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.StrokeStyle>(strokeStyle);
            if (worldTransform != null)
                worldTransform_ = worldTransform.Value;
            geometrySink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SimplifiedGeometrySink>(geometrySink);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, strokeWidth, (void *)strokeStyle_, worldTransform == null ? (void *)0 : &worldTransform_, flatteningTolerance, (void *)geometrySink_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd906a6-12e2-11dc-9fed-001143a055f9")]
    public partial class GeometryGroup : SharpDX.Direct2D1.Geometry
    {
        public GeometryGroup(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GeometryGroup(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GeometryGroup(nativePtr);
        /// <summary>
        /// <p>Indicates how the intersecting areas of the geometries contained in this geometry group are combined.</p>
        /// </summary>
        /// <doc-id>dd316583</doc-id>
        /// <unmanaged>GetFillMode</unmanaged>
        /// <unmanaged-short>GetFillMode</unmanaged-short>
        public SharpDX.Direct2D1.FillMode FillMode
        {
            get => GetFillMode();
        }

        /// <summary>
        /// <p>Indicates the number of geometry objects in the geometry group. </p>
        /// </summary>
        /// <doc-id>dd316589</doc-id>
        /// <unmanaged>GetSourceGeometryCount</unmanaged>
        /// <unmanaged-short>GetSourceGeometryCount</unmanaged-short>
        public System.Int32 SourceGeometryCount
        {
            get => GetSourceGeometryCount();
        }

        /// <summary>
        /// <p>Indicates how the intersecting areas of the geometries contained in this geometry group are combined.</p>
        /// </summary>
        /// <returns><p> A value that indicates how the intersecting areas of the geometries contained in this geometry group are combined.  </p></returns>
        /// <doc-id>dd316583</doc-id>
        /// <unmanaged>D2D1_FILL_MODE ID2D1GeometryGroup::GetFillMode()</unmanaged>
        /// <unmanaged-short>ID2D1GeometryGroup::GetFillMode</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.FillMode GetFillMode()
        {
            SharpDX.Direct2D1.FillMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1FillMode(this._nativePointer, (*(void ***)this._nativePointer)[17]);
            return __result__;
        }

        /// <summary>
        /// <p>Indicates the number of geometry objects in the geometry group. </p>
        /// </summary>
        /// <returns><p>The number of geometries in the <strong><see cref = "SharpDX.Direct2D1.GeometryGroup"/></strong>.</p></returns>
        /// <doc-id>dd316589</doc-id>
        /// <unmanaged>unsigned int ID2D1GeometryGroup::GetSourceGeometryCount()</unmanaged>
        /// <unmanaged-short>ID2D1GeometryGroup::GetSourceGeometryCount</unmanaged-short>
        internal unsafe System.Int32 GetSourceGeometryCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[18]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves the geometries in the geometry group. </p>
        /// </summary>
        /// <param name = "geometries"><dd>  <p>When this method returns, contains the address of a reference to an array of geometries to be filled by this method. The length of the array is specified by the <em>geometryCount</em> parameter. If the array is <strong><c>null</c></strong>, then this method performs no operation. You must allocate the memory for this array.</p> </dd></param>
        /// <param name = "geometriesCount"><dd>  <p>A value indicating the number of geometries to return in the <em>geometries</em> array. If this value is less than the number of geometries in the geometry group, the remaining geometries are omitted. If this value is larger than the number of geometries in the geometry group, the extra geometries are set to <strong><c>null</c></strong>. To obtain the number of geometries currently in the geometry group, use the <strong>GetSourceGeometryCount</strong> method.</p> </dd></param>
        /// <remarks>
        /// <p>The returned geometries are referenced and  counted, and the caller must release them.</p>
        /// </remarks>
        /// <doc-id>dd316586</doc-id>
        /// <unmanaged>void ID2D1GeometryGroup::GetSourceGeometries([Out, Buffer] ID2D1Geometry** geometries,[In] unsigned int geometriesCount)</unmanaged>
        /// <unmanaged-short>ID2D1GeometryGroup::GetSourceGeometries</unmanaged-short>
        internal unsafe void GetSourceGeometries(SharpDX.Direct2D1.Geometry[] geometries, System.Int32 geometriesCount)
        {
            System.IntPtr*geometries_;
            geometries_ = (System.IntPtr*)0;
            {
                System.IntPtr*_geometries = stackalloc System.IntPtr[geometries.Length];
                geometries_ = _geometries;
            }

            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)geometries_, geometriesCount, (*(void ***)this._nativePointer)[19]);
            for (int i = 0; i < geometries.Length; ++i)
                if ((geometries_)[i] != System.IntPtr.Zero)
                    geometries[i] = new SharpDX.Direct2D1.Geometry((geometries_)[i]);
                else
                    geometries[i] = null;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("a16907d7-bc02-4801-99e8-8cf7f485f774")]
    public partial class GeometryRealization : SharpDX.Direct2D1.Resource
    {
        public GeometryRealization(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GeometryRealization(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GeometryRealization(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd9069f-12e2-11dc-9fed-001143a055f9")]
    public partial interface GeometrySink : SharpDX.Direct2D1.SimplifiedGeometrySink
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd9069f-12e2-11dc-9fed-001143a055f9")]
    internal partial class GeometrySinkNative : SharpDX.Direct2D1.SimplifiedGeometrySinkNative, SharpDX.Direct2D1.GeometrySink
    {
        public GeometrySinkNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GeometrySinkNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GeometrySinkNative(nativePtr);
        /// <summary>
        /// <p>Creates a line segment between the current point and the specified end point and adds it to the geometry sink. </p>
        /// </summary>
        /// <param name = "point"><dd>  <p>The end point of the line to draw.</p> </dd></param>
        /// <doc-id>dd316604</doc-id>
        /// <unmanaged>void ID2D1GeometrySink::AddLine([In] D2D_POINT_2F point)</unmanaged>
        /// <unmanaged-short>ID2D1GeometrySink::AddLine</unmanaged-short>
        internal unsafe void AddLine_(SharpDX.Mathematics.Interop.RawVector2 point)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, point, (*(void ***)this._nativePointer)[10]);
        }

        /// <summary>
        /// Creates  a cubic Bezier curve between the current point and the specified end point and adds it to the geometry sink.
        /// </summary>
        /// <param name = "bezier">No documentation.</param>
        /// <doc-id>dd742735</doc-id>
        /// <unmanaged>void ID2D1GeometrySink::AddBezier([In] const D2D1_BEZIER_SEGMENT* bezier)</unmanaged>
        /// <unmanaged-short>ID2D1GeometrySink::AddBezier</unmanaged-short>
        internal unsafe void AddBezier_(ref SharpDX.Direct2D1.BezierSegment bezier)
        {
            fixed (void *bezier_ = &bezier)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, bezier_, (*(void ***)this._nativePointer)[11]);
        }

        /// <summary>
        /// <p>Creates  a quadratic Bezier curve between the current point and the specified end point.</p>
        /// </summary>
        /// <param name = "bezier"><dd>  <p>A structure that describes the control point and the end point of the quadratic Bezier curve to add.</p> </dd></param>
        /// <doc-id>dd316614</doc-id>
        /// <unmanaged>void ID2D1GeometrySink::AddQuadraticBezier([In] const D2D1_QUADRATIC_BEZIER_SEGMENT* bezier)</unmanaged>
        /// <unmanaged-short>ID2D1GeometrySink::AddQuadraticBezier</unmanaged-short>
        internal unsafe void AddQuadraticBezier_(SharpDX.Direct2D1.QuadraticBezierSegment bezier)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &bezier, (*(void ***)this._nativePointer)[12]);
        }

        /// <summary>
        /// <p>Adds a sequence of quadratic Bezier segments as an array in a single call.</p>
        /// </summary>
        /// <param name = "beziers"><dd>  <p>An array of a sequence of quadratic Bezier segments.</p> </dd></param>
        /// <param name = "beziersCount"><dd>  <p>A value indicating the number of quadratic Bezier segments in <em>beziers</em>. </p> </dd></param>
        /// <doc-id>dd316608</doc-id>
        /// <unmanaged>void ID2D1GeometrySink::AddQuadraticBeziers([In, Buffer] const D2D1_QUADRATIC_BEZIER_SEGMENT* beziers,[In] unsigned int beziersCount)</unmanaged>
        /// <unmanaged-short>ID2D1GeometrySink::AddQuadraticBeziers</unmanaged-short>
        internal unsafe void AddQuadraticBeziers_(SharpDX.Direct2D1.QuadraticBezierSegment[] beziers, System.Int32 beziersCount)
        {
            fixed (void *beziers_ = beziers)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, beziers_, beziersCount, (*(void ***)this._nativePointer)[13]);
        }

        /// <summary>
        /// <p>Describes a geometric path that can contain lines, arcs, cubic Bezier curves, and quadratic Bezier curves. </p>
        /// </summary>
        /// <param name = "arc">No documentation.</param>
        /// <remarks>
        /// <p>The <strong><see cref = "SharpDX.Direct2D1.GeometrySink"/></strong> interface extends the <strong><see cref = "SharpDX.Direct2D1.SimplifiedGeometrySink"/></strong> interface to add support for arcs and quadratic beziers, as well as functions for adding single lines and cubic beziers.</p><p>A geometry sink consists of one or more figures. Each figure is made up of one or more line, curve, or arc segments. To create a figure, call the <strong>BeginFigure</strong> method, specify the figure's start point, and then use its Add methods (such as AddLine and AddBezier) to add segments. When you are finished adding segments, call the <strong>EndFigure</strong> method. You can repeat this sequence to create additional figures. When you are finished creating figures, call the <strong>Close</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd316592</doc-id>
        /// <unmanaged>void ID2D1GeometrySink::AddArc([In] const D2D1_ARC_SEGMENT* arc)</unmanaged>
        /// <unmanaged-short>ID2D1GeometrySink::AddArc</unmanaged-short>
        internal unsafe void AddArc_(ref SharpDX.Direct2D1.ArcSegment arc)
        {
            fixed (void *arc_ = &arc)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, arc_, (*(void ***)this._nativePointer)[14]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("f292e401-c050-4cde-83d7-04962d3b23c2")]
    public partial class GradientMesh : SharpDX.Direct2D1.Resource
    {
        public GradientMesh(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GradientMesh(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GradientMesh(nativePtr);
        /// <summary>
        /// <p>Returns the number of patches that make up this gradient mesh.</p>
        /// </summary>
        /// <doc-id>dn900411</doc-id>
        /// <unmanaged>GetPatchCount</unmanaged>
        /// <unmanaged-short>GetPatchCount</unmanaged-short>
        public System.Int32 PatchCount
        {
            get => GetPatchCount();
        }

        /// <summary>
        /// <p>Returns the number of patches that make up this gradient mesh.</p>
        /// </summary>
        /// <returns><p>Returns the number of patches that make up this gradient mesh.</p></returns>
        /// <doc-id>dn900411</doc-id>
        /// <unmanaged>unsigned int ID2D1GradientMesh::GetPatchCount()</unmanaged>
        /// <unmanaged-short>ID2D1GradientMesh::GetPatchCount</unmanaged-short>
        internal unsafe System.Int32 GetPatchCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }

        /// <summary>
        /// <p>Returns a subset of the patches that make up this gradient mesh.</p>
        /// </summary>
        /// <param name = "startIndex"><dd>  <p>Index of the first patch to return.</p> </dd></param>
        /// <param name = "atchesRef"><dd>  <p>A reference to the array to be filled with the patch data.</p> </dd></param>
        /// <param name = "patchesCount"><dd>  <p>The number of patches to be returned.</p> </dd></param>
        /// <returns><p><see cref = "SharpDX.Result.Ok"/> if successful, otherwise a failure <see cref = "SharpDX.Result"/>.</p></returns>
        /// <doc-id>dn900412</doc-id>
        /// <unmanaged>HRESULT ID2D1GradientMesh::GetPatches([In] unsigned int startIndex,[Out, Buffer] D2D1_GRADIENT_MESH_PATCH* patches,[In] unsigned int patchesCount)</unmanaged>
        /// <unmanaged-short>ID2D1GradientMesh::GetPatches</unmanaged-short>
        public unsafe void GetPatches(System.Int32 startIndex, SharpDX.Direct2D1.GradientMeshPatch[] atchesRef, System.Int32 patchesCount)
        {
            SharpDX.Result __result__;
            fixed (void *atchesRef_ = atchesRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, startIndex, atchesRef_, patchesCount, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd906a7-12e2-11dc-9fed-001143a055f9")]
    public partial class GradientStopCollection : SharpDX.Direct2D1.Resource
    {
        public GradientStopCollection(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GradientStopCollection(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GradientStopCollection(nativePtr);
        /// <summary>
        /// <p>Retrieves the number of gradient stops in the collection.</p>
        /// </summary>
        /// <doc-id>dd371454</doc-id>
        /// <unmanaged>GetGradientStopCount</unmanaged>
        /// <unmanaged-short>GetGradientStopCount</unmanaged-short>
        public System.Int32 GradientStopCount
        {
            get => GetGradientStopCount();
        }

        /// <summary>
        /// <p>Indicates the gamma space in which the gradient stops are interpolated. </p>
        /// </summary>
        /// <doc-id>dd316786</doc-id>
        /// <unmanaged>GetColorInterpolationGamma</unmanaged>
        /// <unmanaged-short>GetColorInterpolationGamma</unmanaged-short>
        public SharpDX.Direct2D1.Gamma ColorInterpolationGamma
        {
            get => GetColorInterpolationGamma();
        }

        /// <summary>
        /// <p>Indicates the behavior of the gradient outside the normalized gradient range. </p>
        /// </summary>
        /// <doc-id>dd316789</doc-id>
        /// <unmanaged>GetExtendMode</unmanaged>
        /// <unmanaged-short>GetExtendMode</unmanaged-short>
        public SharpDX.Direct2D1.ExtendMode ExtendMode
        {
            get => GetExtendMode();
        }

        /// <summary>
        /// <p>Retrieves the number of gradient stops in the collection.</p>
        /// </summary>
        /// <returns><p>The number of gradient stops in the collection.</p></returns>
        /// <doc-id>dd371454</doc-id>
        /// <unmanaged>unsigned int ID2D1GradientStopCollection::GetGradientStopCount()</unmanaged>
        /// <unmanaged-short>ID2D1GradientStopCollection::GetGradientStopCount</unmanaged-short>
        internal unsafe System.Int32 GetGradientStopCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }

        /// <summary>
        /// <p>Copies the gradient stops from the collection into an array of <strong><see cref = "SharpDX.Direct2D1.GradientStop"/></strong> structures.</p>
        /// </summary>
        /// <param name = "gradientStops">No documentation.</param>
        /// <param name = "gradientStopsCount">No documentation.</param>
        /// <remarks>
        /// <p>Gradient stops are copied in order of position, starting with the gradient stop with the smallest position value and progressing to the gradient stop with the largest position value.</p>
        /// </remarks>
        /// <doc-id>dd371457</doc-id>
        /// <unmanaged>void ID2D1GradientStopCollection::GetGradientStops([Out, Buffer] D2D1_GRADIENT_STOP* gradientStops,[In] unsigned int gradientStopsCount)</unmanaged>
        /// <unmanaged-short>ID2D1GradientStopCollection::GetGradientStops</unmanaged-short>
        public unsafe void GetGradientStops(SharpDX.Direct2D1.GradientStop[] gradientStops, System.Int32 gradientStopsCount)
        {
            fixed (void *gradientStops_ = gradientStops)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, gradientStops_, gradientStopsCount, (*(void ***)this._nativePointer)[5]);
        }

        /// <summary>
        /// <p>Indicates the gamma space in which the gradient stops are interpolated. </p>
        /// </summary>
        /// <returns><p>The gamma space in which the gradient stops are interpolated. </p></returns>
        /// <doc-id>dd316786</doc-id>
        /// <unmanaged>D2D1_GAMMA ID2D1GradientStopCollection::GetColorInterpolationGamma()</unmanaged>
        /// <unmanaged-short>ID2D1GradientStopCollection::GetColorInterpolationGamma</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.Gamma GetColorInterpolationGamma()
        {
            SharpDX.Direct2D1.Gamma __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1Gamma(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }

        /// <summary>
        /// <p>Indicates the behavior of the gradient outside the normalized gradient range. </p>
        /// </summary>
        /// <returns><p>The behavior of the gradient outside the [0,1] normalized gradient range.</p></returns>
        /// <doc-id>dd316789</doc-id>
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1GradientStopCollection::GetExtendMode()</unmanaged>
        /// <unmanaged-short>ID2D1GradientStopCollection::GetExtendMode</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.ExtendMode GetExtendMode()
        {
            SharpDX.Direct2D1.ExtendMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1ExtendMode(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("ae1572f4-5dd0-4777-998b-9279472ae63b")]
    public partial class GradientStopCollection1 : SharpDX.Direct2D1.GradientStopCollection
    {
        public GradientStopCollection1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator GradientStopCollection1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new GradientStopCollection1(nativePtr);
        /// <summary>
        /// <p>Gets the color space of the input colors as well as the space in which gradient stops are interpolated.</p>
        /// </summary>
        /// <remarks>
        /// <p>If this object was created using <strong>ID2D1RenderTarget::CreateGradientStopCollection</strong>, this method  returns the color space related to the color interpolation gamma. </p>
        /// </remarks>
        /// <doc-id>hh446802</doc-id>
        /// <unmanaged>GetPreInterpolationSpace</unmanaged>
        /// <unmanaged-short>GetPreInterpolationSpace</unmanaged-short>
        public SharpDX.Direct2D1.ColorSpace PreInterpolationSpace
        {
            get => GetPreInterpolationSpace();
        }

        /// <summary>
        /// <p>Gets the color space after interpolation has occurred.</p>
        /// </summary>
        /// <remarks>
        /// <p>If you create using <strong>ID2D1RenderTarget::CreateGradientStopCollection</strong>, this method returns <strong>D2D1_COLOR_SPACE_SRGB</strong>. </p>
        /// </remarks>
        /// <doc-id>hh446800</doc-id>
        /// <unmanaged>GetPostInterpolationSpace</unmanaged>
        /// <unmanaged-short>GetPostInterpolationSpace</unmanaged-short>
        public SharpDX.Direct2D1.ColorSpace PostInterpolationSpace
        {
            get => GetPostInterpolationSpace();
        }

        /// <summary>
        /// <p>Gets the precision of the gradient buffer.</p>
        /// </summary>
        /// <remarks>
        /// <p>If this object was created using <strong>ID2D1RenderTarget::CreateGradientStopCollection</strong>, this method returns D2D1_BUFFER_PRECISION_8BPC_UNORM. </p>
        /// </remarks>
        /// <doc-id>hh446796</doc-id>
        /// <unmanaged>GetBufferPrecision</unmanaged>
        /// <unmanaged-short>GetBufferPrecision</unmanaged-short>
        public SharpDX.Direct2D1.BufferPrecision BufferPrecision
        {
            get => GetBufferPrecision();
        }

        /// <summary>
        /// <p>Retrieves the color interpolation mode that the gradient stop collection uses.</p>
        /// </summary>
        /// <doc-id>hh871465</doc-id>
        /// <unmanaged>GetColorInterpolationMode</unmanaged>
        /// <unmanaged-short>GetColorInterpolationMode</unmanaged-short>
        public SharpDX.Direct2D1.ColorInterpolationMode ColorInterpolationMode
        {
            get => GetColorInterpolationMode();
        }

        /// <summary>
        /// <p>Copies the gradient stops from the collection into memory.</p>
        /// </summary>
        /// <param name = "gradientStops"><dd>  <p>When this method returns, contains a reference to a one-dimensional array of <strong><see cref = "SharpDX.Direct2D1.GradientStop"/></strong> structures.</p> </dd></param>
        /// <param name = "gradientStopsCount"><dd>  <p>The number of gradient stops to copy. </p> </dd></param>
        /// <remarks>
        /// <p>If the <strong><see cref = "SharpDX.Direct2D1.GradientStopCollection1"/></strong> object was created using <strong>ID2D1DeviceContext::CreateGradientStopCollection</strong>, this method returns the same values specified in the creation method. If the <strong><see cref = "SharpDX.Direct2D1.GradientStopCollection1"/></strong> object was created using <strong>ID2D1RenderTarget::CreateGradientStopCollection</strong>, the stops returned here will first be transformed into the gamma space specified by the <em>colorInterpolationGamma</em> parameter. See the <strong>ID2D1DeviceContext::CreateGradientStopCollection</strong> method for more info about color space and gamma space.</p><p>If <em>gradientStopsCount</em> is less than the number of gradient stops in the collection, the remaining gradient stops are omitted. If <em>gradientStopsCount</em> is larger than the number of gradient stops in the collection, the extra gradient stops are set to <strong><c>null</c></strong>. To obtain the number of gradient stops in the collection, use the <strong>GetGradientStopCount</strong> method.</p>
        /// </remarks>
        /// <doc-id>hh446798</doc-id>
        /// <unmanaged>void ID2D1GradientStopCollection1::GetGradientStops1([Out, Buffer] D2D1_GRADIENT_STOP* gradientStops,[In] unsigned int gradientStopsCount)</unmanaged>
        /// <unmanaged-short>ID2D1GradientStopCollection1::GetGradientStops1</unmanaged-short>
        public unsafe void GetGradientStops1(SharpDX.Direct2D1.GradientStop[] gradientStops, System.Int32 gradientStopsCount)
        {
            fixed (void *gradientStops_ = gradientStops)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, gradientStops_, gradientStopsCount, (*(void ***)this._nativePointer)[8]);
        }

        /// <summary>
        /// <p>Gets the color space of the input colors as well as the space in which gradient stops are interpolated.</p>
        /// </summary>
        /// <returns><p>This method returns the color space.</p></returns>
        /// <remarks>
        /// <p>If this object was created using <strong>ID2D1RenderTarget::CreateGradientStopCollection</strong>, this method  returns the color space related to the color interpolation gamma. </p>
        /// </remarks>
        /// <doc-id>hh446802</doc-id>
        /// <unmanaged>D2D1_COLOR_SPACE ID2D1GradientStopCollection1::GetPreInterpolationSpace()</unmanaged>
        /// <unmanaged-short>ID2D1GradientStopCollection1::GetPreInterpolationSpace</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.ColorSpace GetPreInterpolationSpace()
        {
            SharpDX.Direct2D1.ColorSpace __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1ColorSpace(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the color space after interpolation has occurred.</p>
        /// </summary>
        /// <returns><p>This method returns the color space.</p></returns>
        /// <remarks>
        /// <p>If you create using <strong>ID2D1RenderTarget::CreateGradientStopCollection</strong>, this method returns <strong>D2D1_COLOR_SPACE_SRGB</strong>. </p>
        /// </remarks>
        /// <doc-id>hh446800</doc-id>
        /// <unmanaged>D2D1_COLOR_SPACE ID2D1GradientStopCollection1::GetPostInterpolationSpace()</unmanaged>
        /// <unmanaged-short>ID2D1GradientStopCollection1::GetPostInterpolationSpace</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.ColorSpace GetPostInterpolationSpace()
        {
            SharpDX.Direct2D1.ColorSpace __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1ColorSpace(this._nativePointer, (*(void ***)this._nativePointer)[10]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the precision of the gradient buffer.</p>
        /// </summary>
        /// <returns><p>The buffer precision of the gradient buffer.</p></returns>
        /// <remarks>
        /// <p>If this object was created using <strong>ID2D1RenderTarget::CreateGradientStopCollection</strong>, this method returns D2D1_BUFFER_PRECISION_8BPC_UNORM. </p>
        /// </remarks>
        /// <doc-id>hh446796</doc-id>
        /// <unmanaged>D2D1_BUFFER_PRECISION ID2D1GradientStopCollection1::GetBufferPrecision()</unmanaged>
        /// <unmanaged-short>ID2D1GradientStopCollection1::GetBufferPrecision</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.BufferPrecision GetBufferPrecision()
        {
            SharpDX.Direct2D1.BufferPrecision __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1BufferPrecision(this._nativePointer, (*(void ***)this._nativePointer)[11]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves the color interpolation mode that the gradient stop collection uses.</p>
        /// </summary>
        /// <returns><p>The color interpolation mode.</p></returns>
        /// <doc-id>hh871465</doc-id>
        /// <unmanaged>D2D1_COLOR_INTERPOLATION_MODE ID2D1GradientStopCollection1::GetColorInterpolationMode()</unmanaged>
        /// <unmanaged-short>ID2D1GradientStopCollection1::GetColorInterpolationMode</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.ColorInterpolationMode GetColorInterpolationMode()
        {
            SharpDX.Direct2D1.ColorInterpolationMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1ColorInterpolationMode(this._nativePointer, (*(void ***)this._nativePointer)[12]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("65019f75-8da2-497c-b32c-dfa34e48ede6")]
    public partial class Image : SharpDX.Direct2D1.Resource
    {
        public Image(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Image(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Image(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("fe9e984d-3f95-407c-b5db-cb94d4e8f87c")]
    public partial class ImageBrush : SharpDX.Direct2D1.Brush
    {
        public ImageBrush(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ImageBrush(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ImageBrush(nativePtr);
        /// <summary>
        /// <p>Gets or sets the image associated with the image brush.</p>
        /// </summary>
        /// <doc-id>hh446807</doc-id>
        /// <unmanaged>GetImage / SetImage</unmanaged>
        /// <unmanaged-short>GetImage</unmanaged-short>
        public SharpDX.Direct2D1.Image Image
        {
            get
            {
                GetImage(out var __output__);
                return __output__;
            }

            set => SetImage(value);
        }

        /// <summary>
        /// <p>Gets or sets the extend mode of the image brush on the x-axis.</p>
        /// </summary>
        /// <doc-id>hh446805</doc-id>
        /// <unmanaged>GetExtendModeX / SetExtendModeX</unmanaged>
        /// <unmanaged-short>GetExtendModeX</unmanaged-short>
        public SharpDX.Direct2D1.ExtendMode ExtendModeX
        {
            get => GetExtendModeX();
            set => SetExtendModeX(value);
        }

        /// <summary>
        /// <p>Gets or sets the extend mode of the image brush on the y-axis of the image.</p>
        /// </summary>
        /// <doc-id>hh446806</doc-id>
        /// <unmanaged>GetExtendModeY / SetExtendModeY</unmanaged>
        /// <unmanaged-short>GetExtendModeY</unmanaged-short>
        public SharpDX.Direct2D1.ExtendMode ExtendModeY
        {
            get => GetExtendModeY();
            set => SetExtendModeY(value);
        }

        /// <summary>
        /// <p>Gets or sets the interpolation mode of the image brush.</p>
        /// </summary>
        /// <doc-id>hh446808</doc-id>
        /// <unmanaged>GetInterpolationMode / SetInterpolationMode</unmanaged>
        /// <unmanaged-short>GetInterpolationMode</unmanaged-short>
        public SharpDX.Direct2D1.InterpolationMode InterpolationMode
        {
            get => GetInterpolationMode();
            set => SetInterpolationMode(value);
        }

        /// <summary>
        /// <p>Gets or sets the rectangle that will be used as the bounds of the image when drawn as an image brush.</p>
        /// </summary>
        /// <doc-id>hh446809</doc-id>
        /// <unmanaged>GetSourceRectangle / SetSourceRectangle</unmanaged>
        /// <unmanaged-short>GetSourceRectangle</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangleF SourceRectangle
        {
            get
            {
                GetSourceRectangle(out var __output__);
                return __output__;
            }

            set => SetSourceRectangle(value);
        }

        /// <summary>
        /// <p>Sets the image associated with the provided image brush.</p>
        /// </summary>
        /// <param name = "image"><dd>  <p>The image to be associated with the image brush.</p> </dd></param>
        /// <doc-id>hh446812</doc-id>
        /// <unmanaged>void ID2D1ImageBrush::SetImage([In, Optional] ID2D1Image* image)</unmanaged>
        /// <unmanaged-short>ID2D1ImageBrush::SetImage</unmanaged-short>
        internal unsafe void SetImage(SharpDX.Direct2D1.Image image)
        {
            System.IntPtr image_ = System.IntPtr.Zero;
            image_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Image>(image);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)image_, (*(void ***)this._nativePointer)[8]);
        }

        /// <summary>
        /// <p>Sets how the content inside the source rectangle in the image brush will be extended on the x-axis.</p>
        /// </summary>
        /// <param name = "extendModeX"><dd>  <p>The extend mode on the x-axis of the image.</p> </dd></param>
        /// <doc-id>hh446810</doc-id>
        /// <unmanaged>void ID2D1ImageBrush::SetExtendModeX([In] D2D1_EXTEND_MODE extendModeX)</unmanaged>
        /// <unmanaged-short>ID2D1ImageBrush::SetExtendModeX</unmanaged-short>
        internal unsafe void SetExtendModeX(SharpDX.Direct2D1.ExtendMode extendModeX)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)extendModeX), (*(void ***)this._nativePointer)[9]);
        }

        /// <summary>
        /// <p>Sets the extend mode on the y-axis.</p>
        /// </summary>
        /// <param name = "extendModeY"><dd>  <p>The extend mode on the y-axis of the image.</p> </dd></param>
        /// <doc-id>hh446811</doc-id>
        /// <unmanaged>void ID2D1ImageBrush::SetExtendModeY([In] D2D1_EXTEND_MODE extendModeY)</unmanaged>
        /// <unmanaged-short>ID2D1ImageBrush::SetExtendModeY</unmanaged-short>
        internal unsafe void SetExtendModeY(SharpDX.Direct2D1.ExtendMode extendModeY)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)extendModeY), (*(void ***)this._nativePointer)[10]);
        }

        /// <summary>
        /// <p>Sets the interpolation mode for the image brush.</p>
        /// </summary>
        /// <param name = "interpolationMode"><dd>  <p>How the contents of the image will be interpolated to handle the brush transform.</p> </dd></param>
        /// <doc-id>hh446813</doc-id>
        /// <unmanaged>void ID2D1ImageBrush::SetInterpolationMode([In] D2D1_INTERPOLATION_MODE interpolationMode)</unmanaged>
        /// <unmanaged-short>ID2D1ImageBrush::SetInterpolationMode</unmanaged-short>
        internal unsafe void SetInterpolationMode(SharpDX.Direct2D1.InterpolationMode interpolationMode)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)interpolationMode), (*(void ***)this._nativePointer)[11]);
        }

        /// <summary>
        /// <p>Sets the source rectangle in the image brush.</p>
        /// </summary>
        /// <param name = "sourceRectangle"><dd>  <p>The source rectangle that defines the portion of the image to tile.</p> </dd></param>
        /// <remarks>
        /// <p>The top left corner of the <em>sourceRectangle</em> parameter maps to the brush space origin. That is, if the  brush and world transforms are both identity, the portion of the image in the top left corner of the source rectangle will be rendered at (0,0) in the render target.</p><p>The source rectangle will be expanded differently depending on whether the input image is based on   pixels (a bitmap or effect) or by a command list. </p><ul> <li>If the input image is a bitmap or an effect, the rectangle will be expanded to encapsulate a full input pixel before being additionally down-scaled to ensure that the projected rectangle will be correct in the final scene-space.</li> <li>If the input image is a command list, the command list will be slightly expanded to encapsulate a full input pixel.
        /// </li> </ul>
        /// </remarks>
        /// <doc-id>hh446815</doc-id>
        /// <unmanaged>void ID2D1ImageBrush::SetSourceRectangle([In] const D2D_RECT_F* sourceRectangle)</unmanaged>
        /// <unmanaged-short>ID2D1ImageBrush::SetSourceRectangle</unmanaged-short>
        internal unsafe void SetSourceRectangle(SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &sourceRectangle, (*(void ***)this._nativePointer)[12]);
        }

        /// <summary>
        /// <p>Gets the image associated with the image brush.</p>
        /// </summary>
        /// <param name = "image"><dd>  <p> When this method returns, contains the address of a reference to the image associated with  this brush. </p> </dd></param>
        /// <doc-id>hh446807</doc-id>
        /// <unmanaged>void ID2D1ImageBrush::GetImage([Out, Optional] ID2D1Image** image)</unmanaged>
        /// <unmanaged-short>ID2D1ImageBrush::GetImage</unmanaged-short>
        internal unsafe void GetImage(out SharpDX.Direct2D1.Image image)
        {
            System.IntPtr image_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &image_, (*(void ***)this._nativePointer)[13]);
            if (image_ != System.IntPtr.Zero)
                image = new SharpDX.Direct2D1.Image(image_);
            else
                image = null;
        }

        /// <summary>
        /// <p>Gets the extend mode of the image brush on the x-axis.</p>
        /// </summary>
        /// <returns><p>This method returns the x-extend mode.</p></returns>
        /// <doc-id>hh446805</doc-id>
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1ImageBrush::GetExtendModeX()</unmanaged>
        /// <unmanaged-short>ID2D1ImageBrush::GetExtendModeX</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.ExtendMode GetExtendModeX()
        {
            SharpDX.Direct2D1.ExtendMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1ExtendMode(this._nativePointer, (*(void ***)this._nativePointer)[14]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the extend mode of the image brush on the y-axis of the image.</p>
        /// </summary>
        /// <returns><p>This method returns the  y-extend mode.</p></returns>
        /// <doc-id>hh446806</doc-id>
        /// <unmanaged>D2D1_EXTEND_MODE ID2D1ImageBrush::GetExtendModeY()</unmanaged>
        /// <unmanaged-short>ID2D1ImageBrush::GetExtendModeY</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.ExtendMode GetExtendModeY()
        {
            SharpDX.Direct2D1.ExtendMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1ExtendMode(this._nativePointer, (*(void ***)this._nativePointer)[15]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the interpolation mode of the image brush.</p>
        /// </summary>
        /// <returns><p>This method returns the  interpolation mode.</p></returns>
        /// <doc-id>hh446808</doc-id>
        /// <unmanaged>D2D1_INTERPOLATION_MODE ID2D1ImageBrush::GetInterpolationMode()</unmanaged>
        /// <unmanaged-short>ID2D1ImageBrush::GetInterpolationMode</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.InterpolationMode GetInterpolationMode()
        {
            SharpDX.Direct2D1.InterpolationMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1InterpolationMode(this._nativePointer, (*(void ***)this._nativePointer)[16]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the rectangle that will be used as the bounds of the image when drawn as an image brush.</p>
        /// </summary>
        /// <param name = "sourceRectangle"><dd>  <p>When this method returns, contains the address of the output source rectangle.</p> </dd></param>
        /// <doc-id>hh446809</doc-id>
        /// <unmanaged>void ID2D1ImageBrush::GetSourceRectangle([Out] D2D_RECT_F* sourceRectangle)</unmanaged>
        /// <unmanaged-short>ID2D1ImageBrush::GetSourceRectangle</unmanaged-short>
        internal unsafe void GetSourceRectangle(out SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle)
        {
            sourceRectangle = default (SharpDX.Mathematics.Interop.RawRectangleF);
            fixed (void *sourceRectangle_ = &sourceRectangle)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, sourceRectangle_, (*(void ***)this._nativePointer)[17]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("c9b664e5-74a1-4378-9ac2-eefc37a3f4d8")]
    public partial class ImageSource : SharpDX.Direct2D1.Image
    {
        public ImageSource(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ImageSource(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ImageSource(nativePtr);
        /// <summary>
        /// <p>Allows the operating system to free the video memory of resources by discarding their content.</p>
        /// </summary>
        /// <returns><p><strong>OfferResources</strong> returns: </p><ul> <li><strong><see cref = "SharpDX.Result.Ok"/></strong> if resources were successfully offered </li> <li><strong>E_INVALIDARG</strong> if a resource in the array or the priority is invalid </li> </ul></returns>
        /// <doc-id>mt591933</doc-id>
        /// <unmanaged>HRESULT ID2D1ImageSource::OfferResources()</unmanaged>
        /// <unmanaged-short>ID2D1ImageSource::OfferResources</unmanaged-short>
        public unsafe void OfferResources()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Restores access to resources that were previously offered by calling <strong>OfferResources</strong>. </p>
        /// </summary>
        /// <param name = "resourcesDiscarded">No documentation.</param>
        /// <returns><p><strong>ReclaimResources</strong> returns: </p><ul> <li><strong><see cref = "SharpDX.Result.Ok"/></strong> if resources were successfully reclaimed </li> <li><strong>E_INVALIDARG</strong> if the resources are invalid </li> </ul></returns>
        /// <remarks>
        /// <p> After you call <strong>OfferResources</strong> to offer one or more resources, 
        /// you must call <strong>TryReclaimResources</strong> before you can use those resources again. 
        /// You must check the value in the <strong>resourcesDiscarded</strong> to determine whether the resource?s content was discarded. 
        /// If a resource?s content was discarded while it was offered, its current content is undefined. Therefore, you must overwrite the resource?s content before you use the resource. </p>
        /// </remarks>
        /// <doc-id>dn952190</doc-id>
        /// <unmanaged>HRESULT ID2D1ImageSource::TryReclaimResources([Out] BOOL* resourcesDiscarded)</unmanaged>
        /// <unmanaged-short>ID2D1ImageSource::TryReclaimResources</unmanaged-short>
        public unsafe void TryReclaimResources(out SharpDX.Mathematics.Interop.RawBool resourcesDiscarded)
        {
            resourcesDiscarded = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *resourcesDiscarded_ = &resourcesDiscarded)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, resourcesDiscarded_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("77395441-1c8f-4555-8683-f50dab0fe792")]
    public partial class ImageSourceFromWic : SharpDX.Direct2D1.ImageSource
    {
        public ImageSourceFromWic(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ImageSourceFromWic(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ImageSourceFromWic(nativePtr);
        /// <summary>
        /// <p>Retrieves the underlying bitmap image source from the Windows Imaging Component (WIC).</p>
        /// </summary>
        /// <doc-id>dn900422</doc-id>
        /// <unmanaged>GetSource</unmanaged>
        /// <unmanaged-short>GetSource</unmanaged-short>
        public SharpDX.WIC.BitmapSource Source
        {
            get
            {
                GetSource(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Ensures that a specified region of the image source cache is populated. This method can be used to minimize glitches by performing expensive work to populate caches outside of a rendering loop. This method can also be used to speculatively load image data before it is needed by drawing routines. </p>
        /// </summary>
        /// <param name = "rectangleToFill"><dd>  <p>Specifies the region of the image, in pixels, that should be populated in the cache. By default, this is the entire extent of the image.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>This API loads image data into caches of image sources, if that data was not already cached.  It does not trim pre-existing caches, if any.   More areas within the cache can be populated than actually requested.</p><p> ? </p><p>The provided region must be constructed to include the scale with which the image source will subsequently be drawn.   These coordinates must be provided in local coordinates.   This means that they must be adjusted prior to calling the API according to the DPI and other relevant transforms, which can include the world transform and brush transforms.</p><p>This operation is only supported when the image source has been initialized using the D2D1_IMAGE_SOURCE_LOADING_OPTIONS_CACHE_ON_DEMAND option.</p>
        /// </remarks>
        /// <doc-id>dn900420</doc-id>
        /// <unmanaged>HRESULT ID2D1ImageSourceFromWic::EnsureCached([In, Optional] const D2D_RECT_U* rectangleToFill)</unmanaged>
        /// <unmanaged-short>ID2D1ImageSourceFromWic::EnsureCached</unmanaged-short>
        public unsafe void EnsureCached(SharpDX.Mathematics.Interop.RawRectangle? rectangleToFill)
        {
            SharpDX.Mathematics.Interop.RawRectangle rectangleToFill_;
            SharpDX.Result __result__;
            if (rectangleToFill != null)
                rectangleToFill_ = rectangleToFill.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, rectangleToFill == null ? (void *)0 : &rectangleToFill_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>This method trims the populated regions of the image source cache to just the specified rectangle.</p>
        /// </summary>
        /// <param name = "rectangleToPreserve"><dd>  <p>Specifies the region of the image, in pixels, which should be preserved in the image source cache.  Regions which are outside of the rectangle are evicted from the cache. By default, this is an empty rectangle,  meaning that the entire image is evicted from the cache.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The provided region must be constructed to include the scale at which the image source will be drawn at.  These coordinates must be provided in local coordinates.   This means that they must be adjusted prior to calling the API according to the DPI and other relevant transforms, which can include the world transform and brush transforms.</p><p> ? </p><p>This method will fail if on-demand caching was not requested when the image source was created.</p><p> ? </p><p>As with <strong>ID2D1Device::ClearResources</strong>, the caller can need to subsequently issue a D3D flush before memory usage is reduced.</p><p>This operation is only supported when the image source has been initialized using the D2D1_IMAGE_SOURCE_LOADING_OPTIONS_CACHE_ON_DEMAND option.</p>
        /// </remarks>
        /// <doc-id>dn900424</doc-id>
        /// <unmanaged>HRESULT ID2D1ImageSourceFromWic::TrimCache([In, Optional] const D2D_RECT_U* rectangleToPreserve)</unmanaged>
        /// <unmanaged-short>ID2D1ImageSourceFromWic::TrimCache</unmanaged-short>
        public unsafe void TrimCache(SharpDX.Mathematics.Interop.RawRectangle? rectangleToPreserve)
        {
            SharpDX.Mathematics.Interop.RawRectangle rectangleToPreserve_;
            SharpDX.Result __result__;
            if (rectangleToPreserve != null)
                rectangleToPreserve_ = rectangleToPreserve.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, rectangleToPreserve == null ? (void *)0 : &rectangleToPreserve_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the underlying bitmap image source from the Windows Imaging Component (WIC).</p>
        /// </summary>
        /// <param name = "wicBitmapSource"><dd>  <p>On return contains the bitmap image source.</p> </dd></param>
        /// <doc-id>dn900422</doc-id>
        /// <unmanaged>void ID2D1ImageSourceFromWic::GetSource([Out, Optional] IWICBitmapSource** wicBitmapSource)</unmanaged>
        /// <unmanaged-short>ID2D1ImageSourceFromWic::GetSource</unmanaged-short>
        internal unsafe void GetSource(out SharpDX.WIC.BitmapSource wicBitmapSource)
        {
            System.IntPtr wicBitmapSource_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &wicBitmapSource_, (*(void ***)this._nativePointer)[8]);
            if (wicBitmapSource_ != System.IntPtr.Zero)
                wicBitmapSource = new SharpDX.WIC.BitmapSource(wicBitmapSource_);
            else
                wicBitmapSource = null;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("b499923b-7029-478f-a8b3-432c7c5f5312")]
    public partial class Ink : SharpDX.Direct2D1.Resource
    {
        public Ink(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Ink(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Ink(nativePtr);
        /// <summary>
        /// <p>Retrieves or sets the starting point for this ink object.</p>
        /// </summary>
        /// <doc-id>dn900438</doc-id>
        /// <unmanaged>GetStartPoint / SetStartPoint</unmanaged>
        /// <unmanaged-short>GetStartPoint</unmanaged-short>
        public SharpDX.Direct2D1.InkPoint StartPoint
        {
            get => GetStartPoint();
            set => SetStartPoint(value);
        }

        /// <summary>
        /// <p>Updates the last segment in this ink object with new control points.</p>
        /// </summary>
        /// <doc-id>dn900440</doc-id>
        /// <unmanaged>SetSegmentAtEnd</unmanaged>
        /// <unmanaged-short>SetSegmentAtEnd</unmanaged-short>
        public SharpDX.Direct2D1.InkBezierSegment SegmentAtEnd
        {
            set => SetSegmentAtEnd(ref value);
        }

        /// <summary>
        /// <p>Returns the number of segments in this ink object.</p>
        /// </summary>
        /// <doc-id>dn900436</doc-id>
        /// <unmanaged>GetSegmentCount</unmanaged>
        /// <unmanaged-short>GetSegmentCount</unmanaged-short>
        public System.Int32 SegmentCount
        {
            get => GetSegmentCount();
        }

        /// <summary>
        /// <p>Sets the starting point for this ink object. This determines where this ink object will start rendering.</p>
        /// </summary>
        /// <param name = "startPoint"><dd>  <p>The new starting point for this ink object.</p> </dd></param>
        /// <doc-id>dn900445</doc-id>
        /// <unmanaged>void ID2D1Ink::SetStartPoint([In] const D2D1_INK_POINT* startPoint)</unmanaged>
        /// <unmanaged-short>ID2D1Ink::SetStartPoint</unmanaged-short>
        internal unsafe void SetStartPoint(SharpDX.Direct2D1.InkPoint startPoint)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &startPoint, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p>Retrieves the starting point for this ink object.</p>
        /// </summary>
        /// <returns><p>The starting point for this ink object.</p></returns>
        /// <doc-id>dn900438</doc-id>
        /// <unmanaged>D2D1_INK_POINT ID2D1Ink::GetStartPoint()</unmanaged>
        /// <unmanaged-short>ID2D1Ink::GetStartPoint</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.InkPoint GetStartPoint()
        {
            SharpDX.Direct2D1.InkPoint __result__;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// <p>Adds the given segments to the end of this ink object.</p>
        /// </summary>
        /// <param name = "segments"><dd>  <p>A reference to an array of segments to be added to this ink object.</p> </dd></param>
        /// <param name = "segmentsCount"><dd>  <p>The number of segments to be added to this ink object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn900434</doc-id>
        /// <unmanaged>HRESULT ID2D1Ink::AddSegments([In, Buffer] const D2D1_INK_BEZIER_SEGMENT* segments,[In] unsigned int segmentsCount)</unmanaged>
        /// <unmanaged-short>ID2D1Ink::AddSegments</unmanaged-short>
        public unsafe void AddSegments(SharpDX.Direct2D1.InkBezierSegment[] segments, System.Int32 segmentsCount)
        {
            SharpDX.Result __result__;
            fixed (void *segments_ = segments)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, segments_, segmentsCount, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes the given number of segments from the end of this ink object.</p>
        /// </summary>
        /// <param name = "segmentsCount"><dd>  <p>The number of segments to be removed from the end of this ink object. Note that segmentsCount must be less or equal to the number of segments in the ink object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn900439</doc-id>
        /// <unmanaged>HRESULT ID2D1Ink::RemoveSegmentsAtEnd([In] unsigned int segmentsCount)</unmanaged>
        /// <unmanaged-short>ID2D1Ink::RemoveSegmentsAtEnd</unmanaged-short>
        public unsafe void RemoveSegmentsAtEnd(System.Int32 segmentsCount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, segmentsCount, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Updates the specified segments in this ink object with new control points.</p>
        /// </summary>
        /// <param name = "startSegment"><dd>  <p>The index of the first segment in this ink object to update.</p> </dd></param>
        /// <param name = "segments"><dd>  <p>A reference to the array of segment data to be used in the update.</p> </dd></param>
        /// <param name = "segmentsCount"><dd>  <p>The number of segments in this ink object that will be updated with new data. Note that segmentsCount must be less than or equal to the number of segments in the ink object minus startSegment.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn900443</doc-id>
        /// <unmanaged>HRESULT ID2D1Ink::SetSegments([In] unsigned int startSegment,[In, Buffer] const D2D1_INK_BEZIER_SEGMENT* segments,[In] unsigned int segmentsCount)</unmanaged>
        /// <unmanaged-short>ID2D1Ink::SetSegments</unmanaged-short>
        public unsafe void SetSegments(System.Int32 startSegment, SharpDX.Direct2D1.InkBezierSegment[] segments, System.Int32 segmentsCount)
        {
            SharpDX.Result __result__;
            fixed (void *segments_ = segments)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, startSegment, segments_, segmentsCount, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Updates the last segment in this ink object with new control points.</p>
        /// </summary>
        /// <param name = "segment"><dd>  <p>A reference to the segment data with which to overwrite this ink object's last segment. Note that if there are currently no segments in the ink object, SetSegmentsAtEnd will return an error.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn900440</doc-id>
        /// <unmanaged>HRESULT ID2D1Ink::SetSegmentAtEnd([In] const D2D1_INK_BEZIER_SEGMENT* segment)</unmanaged>
        /// <unmanaged-short>ID2D1Ink::SetSegmentAtEnd</unmanaged-short>
        internal unsafe void SetSegmentAtEnd(ref SharpDX.Direct2D1.InkBezierSegment segment)
        {
            SharpDX.Result __result__;
            fixed (void *segment_ = &segment)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, segment_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns the number of segments in this ink object.</p>
        /// </summary>
        /// <returns><p>Returns the number of segments in this ink object.</p></returns>
        /// <doc-id>dn900436</doc-id>
        /// <unmanaged>unsigned int ID2D1Ink::GetSegmentCount()</unmanaged>
        /// <unmanaged-short>ID2D1Ink::GetSegmentCount</unmanaged-short>
        internal unsafe System.Int32 GetSegmentCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[10]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves the specified subset of segments stored in this ink object.</p>
        /// </summary>
        /// <param name = "startSegment"><dd>  <p>The index of the first segment in this ink object to retrieve.</p> </dd></param>
        /// <param name = "segments"><dd>  <p>When this method returns, contains a reference to an array of retrieved segments.</p> </dd></param>
        /// <param name = "segmentsCount"><dd>  <p>The number of segments to retrieve. Note that segmentsCount must be less than or equal to the number of segments in the ink object minus startSegment.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn900437</doc-id>
        /// <unmanaged>HRESULT ID2D1Ink::GetSegments([In] unsigned int startSegment,[Out, Buffer] D2D1_INK_BEZIER_SEGMENT* segments,[In] unsigned int segmentsCount)</unmanaged>
        /// <unmanaged-short>ID2D1Ink::GetSegments</unmanaged-short>
        public unsafe void GetSegments(System.Int32 startSegment, SharpDX.Direct2D1.InkBezierSegment[] segments, System.Int32 segmentsCount)
        {
            SharpDX.Result __result__;
            fixed (void *segments_ = segments)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, startSegment, segments_, segmentsCount, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves a geometric representation of this ink object.</p>
        /// </summary>
        /// <param name = "inkStyle"><dd>  <p>The ink style to be used in determining the geometric representation.</p> </dd></param>
        /// <param name = "worldTransform"><dd>  <p>The world transform to be used in determining the geometric representation.</p> </dd></param>
        /// <param name = "flatteningTolerance"><dd>  <p>The flattening tolerance to be used in determining the geometric representation.</p> </dd></param>
        /// <param name = "geometrySink"><dd>  <p>The geometry sink to which the geometry representation will be streamed.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn900449</doc-id>
        /// <unmanaged>HRESULT ID2D1Ink::StreamAsGeometry([In, Optional] ID2D1InkStyle* inkStyle,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[In] ID2D1SimplifiedGeometrySink* geometrySink)</unmanaged>
        /// <unmanaged-short>ID2D1Ink::StreamAsGeometry</unmanaged-short>
        public unsafe void StreamAsGeometry(SharpDX.Direct2D1.InkStyle inkStyle, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, System.Single flatteningTolerance, SharpDX.Direct2D1.SimplifiedGeometrySink geometrySink)
        {
            System.IntPtr inkStyle_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
            System.IntPtr geometrySink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            inkStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.InkStyle>(inkStyle);
            if (worldTransform != null)
                worldTransform_ = worldTransform.Value;
            geometrySink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SimplifiedGeometrySink>(geometrySink);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)inkStyle_, worldTransform == null ? (void *)0 : &worldTransform_, flatteningTolerance, (void *)geometrySink_, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieve the bounds of the geometry, with an optional applied transform.</p>
        /// </summary>
        /// <param name = "inkStyle"><dd>  <p>The ink style to be used in determining the bounds of this ink object.</p> </dd></param>
        /// <param name = "worldTransform"><dd>  <p>The world transform to be used in determining the bounds of this ink object.</p> </dd></param>
        /// <param name = "bounds"><dd>  <p>When this method returns, contains the bounds of this ink object.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dn900435</doc-id>
        /// <unmanaged>HRESULT ID2D1Ink::GetBounds([In, Optional] ID2D1InkStyle* inkStyle,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[Out] D2D_RECT_F* bounds)</unmanaged>
        /// <unmanaged-short>ID2D1Ink::GetBounds</unmanaged-short>
        public unsafe void GetBounds(SharpDX.Direct2D1.InkStyle inkStyle, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, out SharpDX.Mathematics.Interop.RawRectangleF bounds)
        {
            System.IntPtr inkStyle_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
            bounds = default (SharpDX.Mathematics.Interop.RawRectangleF);
            SharpDX.Result __result__;
            inkStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.InkStyle>(inkStyle);
            if (worldTransform != null)
                worldTransform_ = worldTransform.Value;
            fixed (void *bounds_ = &bounds)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)inkStyle_, worldTransform == null ? (void *)0 : &worldTransform_, bounds_, (*(void ***)this._nativePointer)[13]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("bae8b344-23fc-4071-8cb5-d05d6f073848")]
    public partial class InkStyle : SharpDX.Direct2D1.Resource
    {
        public InkStyle(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator InkStyle(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new InkStyle(nativePtr);
        /// <summary>
        /// <p>Retrieves or sets the transform to be applied to this style's nib shape.</p>
        /// </summary>
        /// <doc-id>dn900429</doc-id>
        /// <unmanaged>GetNibTransform / SetNibTransform</unmanaged>
        /// <unmanaged-short>GetNibTransform</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 NibTransform
        {
            get
            {
                GetNibTransform(out var __output__);
                return __output__;
            }

            set => SetNibTransform(ref value);
        }

        /// <summary>
        /// <p>Retrieves or sets the pre-transform nib shape for this style.</p>
        /// </summary>
        /// <doc-id>dn900428</doc-id>
        /// <unmanaged>GetNibShape / SetNibShape</unmanaged>
        /// <unmanaged-short>GetNibShape</unmanaged-short>
        public SharpDX.Direct2D1.InkNibShape NibShape
        {
            get => GetNibShape();
            set => SetNibShape(value);
        }

        /// <summary>
        /// <p>Sets the transform to apply to this style's nib shape.</p>
        /// </summary>
        /// <param name = "transform"><dd>  <p>The transform to apply to this style?s nib shape. Note that the translation components of the transform matrix are ignored for the purposes of rendering.</p> </dd></param>
        /// <doc-id>dn900431</doc-id>
        /// <unmanaged>void ID2D1InkStyle::SetNibTransform([In] const D2D_MATRIX_3X2_F* transform)</unmanaged>
        /// <unmanaged-short>ID2D1InkStyle::SetNibTransform</unmanaged-short>
        internal unsafe void SetNibTransform(ref SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            fixed (void *transform_ = &transform)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, transform_, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p>Retrieves the transform to be applied to this style's nib shape.</p>
        /// </summary>
        /// <param name = "transform"><dd>  <p>When this method returns, contains a reference to the transform to be applied to this style's nib shape.</p> </dd></param>
        /// <doc-id>dn900429</doc-id>
        /// <unmanaged>void ID2D1InkStyle::GetNibTransform([Out] D2D_MATRIX_3X2_F* transform)</unmanaged>
        /// <unmanaged-short>ID2D1InkStyle::GetNibTransform</unmanaged-short>
        internal unsafe void GetNibTransform(out SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            transform = default (SharpDX.Mathematics.Interop.RawMatrix3x2);
            fixed (void *transform_ = &transform)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, transform_, (*(void ***)this._nativePointer)[5]);
        }

        /// <summary>
        /// <p>Sets the pre-transform nib shape for this style.</p>
        /// </summary>
        /// <param name = "nibShape"><dd>  <p>The pre-transform nib shape to use in this style.</p> </dd></param>
        /// <doc-id>dn900430</doc-id>
        /// <unmanaged>void ID2D1InkStyle::SetNibShape([In] D2D1_INK_NIB_SHAPE nibShape)</unmanaged>
        /// <unmanaged-short>ID2D1InkStyle::SetNibShape</unmanaged-short>
        internal unsafe void SetNibShape(SharpDX.Direct2D1.InkNibShape nibShape)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)nibShape), (*(void ***)this._nativePointer)[6]);
        }

        /// <summary>
        /// <p>Retrieves the pre-transform nib shape for this style.</p>
        /// </summary>
        /// <returns><p>Returns the pre-transform nib shape for this style.</p></returns>
        /// <doc-id>dn900428</doc-id>
        /// <unmanaged>D2D1_INK_NIB_SHAPE ID2D1InkStyle::GetNibShape()</unmanaged>
        /// <unmanaged-short>ID2D1InkStyle::GetNibShape</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.InkNibShape GetNibShape()
        {
            SharpDX.Direct2D1.InkNibShape __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1InkNibShape(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd9069b-12e2-11dc-9fed-001143a055f9")]
    public partial class Layer : SharpDX.Direct2D1.Resource
    {
        public Layer(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Layer(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Layer(nativePtr);
        /// <summary>
        /// <p>Gets the size of the layer in device-independent pixels. </p>
        /// </summary>
        /// <doc-id>dd371485</doc-id>
        /// <unmanaged>GetSize</unmanaged>
        /// <unmanaged-short>GetSize</unmanaged-short>
        public SharpDX.Size2F Size
        {
            get => GetSize();
        }

        /// <summary>
        /// <p>Gets the size of the layer in device-independent pixels. </p>
        /// </summary>
        /// <returns><p>The size of the layer in device-independent pixels.</p></returns>
        /// <doc-id>dd371485</doc-id>
        /// <unmanaged>D2D_SIZE_F ID2D1Layer::GetSize()</unmanaged>
        /// <unmanaged-short>ID2D1Layer::GetSize</unmanaged-short>
        internal unsafe SharpDX.Size2F GetSize()
        {
            SharpDX.Size2F __result__;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd906ab-12e2-11dc-9fed-001143a055f9")]
    public partial class LinearGradientBrush : SharpDX.Direct2D1.Brush
    {
        public LinearGradientBrush(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator LinearGradientBrush(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new LinearGradientBrush(nativePtr);
        /// <summary>
        /// <p>Retrieves or sets the starting coordinates of the linear gradient. </p>
        /// </summary>
        /// <remarks>
        /// <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>
        /// </remarks>
        /// <doc-id>dd371497</doc-id>
        /// <unmanaged>GetStartPoint / SetStartPoint</unmanaged>
        /// <unmanaged-short>GetStartPoint</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 StartPoint
        {
            get => GetStartPoint();
            set => SetStartPoint(value);
        }

        /// <summary>
        /// <p>Retrieves or sets the ending coordinates of the linear gradient. </p>
        /// </summary>
        /// <remarks>
        /// <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>
        /// </remarks>
        /// <doc-id>dd371492</doc-id>
        /// <unmanaged>GetEndPoint / SetEndPoint</unmanaged>
        /// <unmanaged-short>GetEndPoint</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 EndPoint
        {
            get => GetEndPoint();
            set => SetEndPoint(value);
        }

        /// <summary>
        /// <p> Retrieves the <strong><see cref = "SharpDX.Direct2D1.GradientStopCollection"/></strong> associated with this linear gradient brush.</p>
        /// </summary>
        /// <remarks>
        /// <p> <strong><see cref = "SharpDX.Direct2D1.GradientStopCollection"/></strong> contains an array of <strong><see cref = "SharpDX.Direct2D1.GradientStop"/></strong> structures and information, such as the extend mode and the color interpolation mode.</p>
        /// </remarks>
        /// <doc-id>dd371496</doc-id>
        /// <unmanaged>GetGradientStopCollection</unmanaged>
        /// <unmanaged-short>GetGradientStopCollection</unmanaged-short>
        public SharpDX.Direct2D1.GradientStopCollection GradientStopCollection
        {
            get
            {
                GetGradientStopCollection(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Sets the starting coordinates of the linear gradient in the brush's coordinate space.  </p>
        /// </summary>
        /// <param name = "startPoint"><dd>  <p>The starting two-dimensional coordinates of the linear gradient, in the brush's coordinate space.</p> </dd></param>
        /// <remarks>
        /// <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>
        /// </remarks>
        /// <doc-id>dd371505</doc-id>
        /// <unmanaged>void ID2D1LinearGradientBrush::SetStartPoint([In] D2D_POINT_2F startPoint)</unmanaged>
        /// <unmanaged-short>ID2D1LinearGradientBrush::SetStartPoint</unmanaged-short>
        internal unsafe void SetStartPoint(SharpDX.Mathematics.Interop.RawVector2 startPoint)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, startPoint, (*(void ***)this._nativePointer)[8]);
        }

        /// <summary>
        /// <p>Sets the ending coordinates of the linear gradient in the brush's coordinate space.</p>
        /// </summary>
        /// <param name = "endPoint"><dd>  <p>The ending two-dimensional coordinates of the linear gradient, in the brush's coordinate space.</p> </dd></param>
        /// <remarks>
        /// <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>
        /// </remarks>
        /// <doc-id>dd371501</doc-id>
        /// <unmanaged>void ID2D1LinearGradientBrush::SetEndPoint([In] D2D_POINT_2F endPoint)</unmanaged>
        /// <unmanaged-short>ID2D1LinearGradientBrush::SetEndPoint</unmanaged-short>
        internal unsafe void SetEndPoint(SharpDX.Mathematics.Interop.RawVector2 endPoint)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, endPoint, (*(void ***)this._nativePointer)[9]);
        }

        /// <summary>
        /// <p>Retrieves the starting coordinates of the linear gradient. </p>
        /// </summary>
        /// <returns><p>The starting two-dimensional coordinates of the linear gradient, in the brush's coordinate space.</p></returns>
        /// <remarks>
        /// <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>
        /// </remarks>
        /// <doc-id>dd371497</doc-id>
        /// <unmanaged>D2D_POINT_2F ID2D1LinearGradientBrush::GetStartPoint()</unmanaged>
        /// <unmanaged-short>ID2D1LinearGradientBrush::GetStartPoint</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawVector2 GetStartPoint()
        {
            SharpDX.Mathematics.Interop.RawVector2 __result__;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[10]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves the ending coordinates of the linear gradient. </p>
        /// </summary>
        /// <returns><p>The ending two-dimensional coordinates of the linear gradient, in the brush's coordinate space.</p></returns>
        /// <remarks>
        /// <p>The start point and end point are described in the brush's space and are mapped to the render target when the brush is used.  If there is a non-identity brush transform or render target transform, the brush's start point and end point are also transformed.</p>
        /// </remarks>
        /// <doc-id>dd371492</doc-id>
        /// <unmanaged>D2D_POINT_2F ID2D1LinearGradientBrush::GetEndPoint()</unmanaged>
        /// <unmanaged-short>ID2D1LinearGradientBrush::GetEndPoint</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawVector2 GetEndPoint()
        {
            SharpDX.Mathematics.Interop.RawVector2 __result__;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[11]);
            return __result__;
        }

        /// <summary>
        /// <p> Retrieves the <strong><see cref = "SharpDX.Direct2D1.GradientStopCollection"/></strong> associated with this linear gradient brush.</p>
        /// </summary>
        /// <param name = "gradientStopCollection">No documentation.</param>
        /// <remarks>
        /// <p> <strong><see cref = "SharpDX.Direct2D1.GradientStopCollection"/></strong> contains an array of <strong><see cref = "SharpDX.Direct2D1.GradientStop"/></strong> structures and information, such as the extend mode and the color interpolation mode.</p>
        /// </remarks>
        /// <doc-id>dd371496</doc-id>
        /// <unmanaged>void ID2D1LinearGradientBrush::GetGradientStopCollection([Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
        /// <unmanaged-short>ID2D1LinearGradientBrush::GetGradientStopCollection</unmanaged-short>
        internal unsafe void GetGradientStopCollection(out SharpDX.Direct2D1.GradientStopCollection gradientStopCollection)
        {
            System.IntPtr gradientStopCollection_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &gradientStopCollection_, (*(void ***)this._nativePointer)[12]);
            if (gradientStopCollection_ != System.IntPtr.Zero)
                gradientStopCollection = new SharpDX.Direct2D1.GradientStopCollection(gradientStopCollection_);
            else
                gradientStopCollection = null;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("53dd9855-a3b0-4d5b-82e1-26e25c5e5797")]
    public partial class LookupTable3D : SharpDX.Direct2D1.Resource
    {
        public LookupTable3D(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator LookupTable3D(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new LookupTable3D(nativePtr);
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd906c2-12e2-11dc-9fed-001143a055f9")]
    public partial class Mesh : SharpDX.Direct2D1.Resource
    {
        public Mesh(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Mesh(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Mesh(nativePtr);
        /// <summary>
        /// <p>Opens the mesh for population.</p>
        /// </summary>
        /// <param name = "tessellationSink"><dd>  <p>When this method returns, contains a reference to a reference to an <strong><see cref = "SharpDX.Direct2D1.TessellationSink"/></strong> that is used to populate the mesh. This parameter is passed uninitialized.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371510</doc-id>
        /// <unmanaged>HRESULT ID2D1Mesh::Open([Out] ID2D1TessellationSink** tessellationSink)</unmanaged>
        /// <unmanaged-short>ID2D1Mesh::Open</unmanaged-short>
        internal unsafe void Open_(out SharpDX.Direct2D1.TessellationSink tessellationSink)
        {
            System.IntPtr tessellationSink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &tessellationSink_, (*(void ***)this._nativePointer)[4]);
            if (tessellationSink_ != System.IntPtr.Zero)
                tessellationSink = new SharpDX.Direct2D1.TessellationSinkNative(tessellationSink_);
            else
                tessellationSink = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("31e6e7bc-e0ff-4d46-8c64-a0a8c41c15d3")]
    public partial class Multithread : SharpDX.ComObject
    {
        public Multithread(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Multithread(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Multithread(nativePtr);
        /// <summary>
        /// <p> Returns whether the Direct2D factory was created with the <strong>D2D1_FACTORY_TYPE_MULTI_THREADED</strong> flag. </p>
        /// </summary>
        /// <doc-id>hh997715</doc-id>
        /// <unmanaged>GetMultithreadProtected</unmanaged>
        /// <unmanaged-short>GetMultithreadProtected</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool MultithreadProtected
        {
            get => GetMultithreadProtected();
        }

        /// <summary>
        /// <p> Returns whether the Direct2D factory was created with the <strong>D2D1_FACTORY_TYPE_MULTI_THREADED</strong> flag. </p>
        /// </summary>
        /// <returns><p>Returns true if the Direct2D factory was created as multi-threaded, or false if it was created as single-threaded.</p></returns>
        /// <doc-id>hh997715</doc-id>
        /// <unmanaged>BOOL ID2D1Multithread::GetMultithreadProtected()</unmanaged>
        /// <unmanaged-short>ID2D1Multithread::GetMultithreadProtected</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool GetMultithreadProtected()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// <p>Enters the Direct2D API critical section, if it exists. </p>
        /// </summary>
        /// <doc-id>hh997714</doc-id>
        /// <unmanaged>void ID2D1Multithread::Enter()</unmanaged>
        /// <unmanaged-short>ID2D1Multithread::Enter</unmanaged-short>
        public unsafe void Enter()
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p>Leaves the Direct2D API critical section, if it exists.</p>
        /// </summary>
        /// <doc-id>hh997716</doc-id>
        /// <unmanaged>void ID2D1Multithread::Leave()</unmanaged>
        /// <unmanaged-short>ID2D1Multithread::Leave</unmanaged-short>
        public unsafe void Leave()
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[5]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("3fe6adea-7643-4f53-bd14-a0ce63f24042")]
    public partial class OffsetTransform : SharpDX.Direct2D1.TransformNodeNative
    {
        public OffsetTransform(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator OffsetTransform(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new OffsetTransform(nativePtr);
        /// <summary>
        /// <p>Gets or sets the offset currently in the offset transform.</p>
        /// </summary>
        /// <doc-id>hh446822</doc-id>
        /// <unmanaged>GetOffset / SetOffset</unmanaged>
        /// <unmanaged-short>GetOffset</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawPoint Offset
        {
            get => GetOffset();
            set => SetOffset(value);
        }

        /// <summary>
        /// <p>Sets the offset in the current offset transform.</p>
        /// </summary>
        /// <param name = "offset"><dd>  <p>The new offset to apply to the offset transform.</p> </dd></param>
        /// <doc-id>hh446824</doc-id>
        /// <unmanaged>void ID2D1OffsetTransform::SetOffset([In] POINT offset)</unmanaged>
        /// <unmanaged-short>ID2D1OffsetTransform::SetOffset</unmanaged-short>
        internal unsafe void SetOffset(SharpDX.Mathematics.Interop.RawPoint offset)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, offset, (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p>Gets the offset currently in the offset transform.</p>
        /// </summary>
        /// <returns><p>The current transform offset.</p></returns>
        /// <doc-id>hh446822</doc-id>
        /// <unmanaged>POINT ID2D1OffsetTransform::GetOffset()</unmanaged>
        /// <unmanaged-short>ID2D1OffsetTransform::GetOffset</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawPoint GetOffset()
        {
            SharpDX.Mathematics.Interop.RawPoint __result__;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd906a5-12e2-11dc-9fed-001143a055f9")]
    public partial class PathGeometry : SharpDX.Direct2D1.Geometry
    {
        public PathGeometry(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator PathGeometry(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new PathGeometry(nativePtr);
        /// <summary>
        /// <p>Retrieves the number of segments in the path geometry. </p>
        /// </summary>
        /// <doc-id>dd371520</doc-id>
        /// <unmanaged>GetSegmentCount</unmanaged>
        /// <unmanaged-short>GetSegmentCount</unmanaged-short>
        public System.Int32 SegmentCount
        {
            get
            {
                GetSegmentCount(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves the number of figures in the path geometry. </p>
        /// </summary>
        /// <doc-id>dd371515</doc-id>
        /// <unmanaged>GetFigureCount</unmanaged>
        /// <unmanaged-short>GetFigureCount</unmanaged-short>
        public System.Int32 FigureCount
        {
            get
            {
                GetFigureCount(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves the geometry sink that is used to populate the path geometry with figures and segments. </p>
        /// </summary>
        /// <returns><dd>  <p>When this method returns, <em>geometrySink</em> contains the address of a reference to the geometry sink that is used to populate the path geometry with figures and segments. This parameter is passed uninitialized.</p> </dd></returns>
        /// <remarks>
        /// <p>Because path geometries are immutable and can only be populated once, it is an error to call <strong>Open</strong> on a path geometry more than once.</p><p>Note that the fill mode defaults to <strong>D2D1_FILL_MODE_ALTERNATE</strong>. To set the fill mode, call <strong>SetFillMode</strong> before the first call to <strong>BeginFigure</strong>. Failure to do so will put the geometry sink in an error state. </p>
        /// </remarks>
        /// <doc-id>dd371522</doc-id>
        /// <unmanaged>HRESULT ID2D1PathGeometry::Open([Out] ID2D1GeometrySink** geometrySink)</unmanaged>
        /// <unmanaged-short>ID2D1PathGeometry::Open</unmanaged-short>
        public unsafe SharpDX.Direct2D1.GeometrySink Open()
        {
            SharpDX.Direct2D1.GeometrySink geometrySink;
            System.IntPtr geometrySink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &geometrySink_, (*(void ***)this._nativePointer)[17]);
            if (geometrySink_ != System.IntPtr.Zero)
                geometrySink = new SharpDX.Direct2D1.GeometrySinkNative(geometrySink_);
            else
                geometrySink = null;
            __result__.CheckError();
            return geometrySink;
        }

        /// <summary>
        /// <p>Copies the contents of the path geometry to the specified <strong><see cref = "SharpDX.Direct2D1.GeometrySink"/></strong>.</p>
        /// </summary>
        /// <param name = "geometrySink">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371525</doc-id>
        /// <unmanaged>HRESULT ID2D1PathGeometry::Stream([In] ID2D1GeometrySink* geometrySink)</unmanaged>
        /// <unmanaged-short>ID2D1PathGeometry::Stream</unmanaged-short>
        public unsafe void Stream(SharpDX.Direct2D1.GeometrySink geometrySink)
        {
            System.IntPtr geometrySink_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            geometrySink_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.GeometrySink>(geometrySink);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)geometrySink_, (*(void ***)this._nativePointer)[18]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the number of segments in the path geometry. </p>
        /// </summary>
        /// <param name = "count"><dd>  <p>A reference that receives the number of segments in the path geometry when this method returns. You must allocate storage for this parameter.   </p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371520</doc-id>
        /// <unmanaged>HRESULT ID2D1PathGeometry::GetSegmentCount([Out] unsigned int* count)</unmanaged>
        /// <unmanaged-short>ID2D1PathGeometry::GetSegmentCount</unmanaged-short>
        internal unsafe void GetSegmentCount(out System.Int32 count)
        {
            SharpDX.Result __result__;
            fixed (void *count_ = &count)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, count_, (*(void ***)this._nativePointer)[19]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the number of figures in the path geometry. </p>
        /// </summary>
        /// <param name = "count"><dd>  <p>A reference that receives the number of figures in the path geometry when this method returns. You must allocate storage for this parameter.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371515</doc-id>
        /// <unmanaged>HRESULT ID2D1PathGeometry::GetFigureCount([Out] unsigned int* count)</unmanaged>
        /// <unmanaged-short>ID2D1PathGeometry::GetFigureCount</unmanaged-short>
        internal unsafe void GetFigureCount(out System.Int32 count)
        {
            SharpDX.Result __result__;
            fixed (void *count_ = &count)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, count_, (*(void ***)this._nativePointer)[20]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("62baa2d2-ab54-41b7-b872-787e0106a421")]
    public partial class PathGeometry1 : SharpDX.Direct2D1.PathGeometry
    {
        public PathGeometry1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator PathGeometry1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new PathGeometry1(nativePtr);
        /// <summary>
        /// <p> Computes the point that exists at a given distance along the path geometry along with the index of the segment the point is on and the directional vector at that point. </p>
        /// </summary>
        /// <param name = "length"><dd>  <p>The distance to walk along the path.</p> </dd></param>
        /// <param name = "startSegment"><dd>  <p>The index of the segment at which to begin walking. Note: This index is global to the entire path, not just a particular figure.</p> </dd></param>
        /// <param name = "worldTransform"><dd>  <p>The transform to apply to the path prior to walking.</p> </dd></param>
        /// <param name = "flatteningTolerance"><dd>  <p>The flattening tolerance to use when walking along an arc or Bezier segment. The flattening tolerance is the maximum  error allowed when constructing a polygonal approximation of the geometry. No point in the polygonal representation will diverge  from the original geometry by more than the flattening tolerance. Smaller values produce more accurate results but cause slower execution.</p> </dd></param>
        /// <param name = "ointDescriptionRef"><dd>  <p>When this method returns, contains a description of the point that can be found at the given location.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>One of the inputs was in an invalid range.</td></tr> </table><p>?</p></returns>
        /// <doc-id>dn900454</doc-id>
        /// <unmanaged>HRESULT ID2D1PathGeometry1::ComputePointAndSegmentAtLength([In] float length,[In] unsigned int startSegment,[In, Optional] const D2D_MATRIX_3X2_F* worldTransform,[In] float flatteningTolerance,[Out] D2D1_POINT_DESCRIPTION* pointDescription)</unmanaged>
        /// <unmanaged-short>ID2D1PathGeometry1::ComputePointAndSegmentAtLength</unmanaged-short>
        public unsafe void ComputePointAndSegmentAtLength(System.Single length, System.Int32 startSegment, SharpDX.Mathematics.Interop.RawMatrix3x2? worldTransform, System.Single flatteningTolerance, out SharpDX.Direct2D1.PointDescription ointDescriptionRef)
        {
            SharpDX.Mathematics.Interop.RawMatrix3x2 worldTransform_;
            ointDescriptionRef = default (SharpDX.Direct2D1.PointDescription);
            SharpDX.Result __result__;
            if (worldTransform != null)
                worldTransform_ = worldTransform.Value;
            fixed (void *ointDescriptionRef_ = &ointDescriptionRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, length, startSegment, worldTransform == null ? (void *)0 : &worldTransform_, flatteningTolerance, ointDescriptionRef_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2c1d867d-c290-41c8-ae7e-34a98702e9a5")]
    public partial class PrintControl : SharpDX.ComObject
    {
        public PrintControl(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator PrintControl(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new PrintControl(nativePtr);
        /// <summary>
        /// <p>Converts Direct2D primitives in the passed-in command list into a fixed page representation for use  by the print subsystem. </p>
        /// </summary>
        /// <param name = "commandList"><dd>  <p>The command list that contains the rendering operations.</p> </dd></param>
        /// <param name = "pageSize"><dd>  <p>The size of the page to add.</p> </dd></param>
        /// <param name = "agePrintTicketStreamRef"><dd>  <p>The print ticket stream.</p> </dd></param>
        /// <param name = "tag1"><dd>  <p>Contains the first label for subsequent drawing operations. This parameter is passed uninitialized. If <c>null</c> is specified, no value is retrieved for this parameter.</p> </dd></param>
        /// <param name = "tag2"><dd>  <p>Contains the second label for subsequent drawing operations. This parameter is passed uninitialized. If <c>null</c> is specified, no value is retrieved for this parameter.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> <tr><td><see cref = "PrintJobClosed"/></td><td>The print job is already finished.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh847998</doc-id>
        /// <unmanaged>HRESULT ID2D1PrintControl::AddPage([In] ID2D1CommandList* commandList,[In] D2D_SIZE_F pageSize,[In, Optional] IStream* pagePrintTicketStream,[Out, Optional] unsigned longlong* tag1,[Out, Optional] unsigned longlong* tag2)</unmanaged>
        /// <unmanaged-short>ID2D1PrintControl::AddPage</unmanaged-short>
        public unsafe void AddPage(SharpDX.Direct2D1.CommandList commandList, SharpDX.Size2F pageSize, SharpDX.Win32.IStream agePrintTicketStreamRef, out System.Int64 tag1, out System.Int64 tag2)
        {
            System.IntPtr commandList_ = System.IntPtr.Zero;
            System.IntPtr agePrintTicketStreamRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            commandList_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.CommandList>(commandList);
            agePrintTicketStreamRef_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Win32.IStream>(agePrintTicketStreamRef);
            fixed (void *tag2_ = &tag2)
                fixed (void *tag1_ = &tag1)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)commandList_, pageSize, (void *)agePrintTicketStreamRef_, tag1_, tag2_, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Passes all remaining resources to the print sub-system, then clean up and close the current print job. </p>
        /// </summary>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> <tr><td><see cref = "PrintJobClosed"/></td><td>The print job is already finished.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh848001</doc-id>
        /// <unmanaged>HRESULT ID2D1PrintControl::Close()</unmanaged>
        /// <unmanaged-short>ID2D1PrintControl::Close</unmanaged-short>
        public unsafe void Close()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("483473d7-cd46-4f9d-9d3a-3112aa80159d")]
    public partial class Properties : SharpDX.ComObject
    {
        public Properties(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Properties(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Properties(nativePtr);
        /// <summary>
        /// <p>Gets the number of top-level properties. </p>
        /// </summary>
        /// <remarks>
        /// <p>This method returns the number of custom properties on the <strong><see cref = "SharpDX.Direct2D1.Properties"/></strong> interface. System properties and sub-properties are part of a closed set, and are enumerable by iterating over this closed set.</p>
        /// </remarks>
        /// <doc-id>hh446857</doc-id>
        /// <unmanaged>GetPropertyCount</unmanaged>
        /// <unmanaged-short>GetPropertyCount</unmanaged-short>
        public System.Int32 PropertyCount
        {
            get => GetPropertyCount();
        }

        /// <summary>
        /// <p>Gets the number of top-level properties. </p>
        /// </summary>
        /// <returns><p>This method returns the number of custom (non-system) properties that can be accessed by the object.</p></returns>
        /// <remarks>
        /// <p>This method returns the number of custom properties on the <strong><see cref = "SharpDX.Direct2D1.Properties"/></strong> interface. System properties and sub-properties are part of a closed set, and are enumerable by iterating over this closed set.</p>
        /// </remarks>
        /// <doc-id>hh446857</doc-id>
        /// <unmanaged>unsigned int ID2D1Properties::GetPropertyCount()</unmanaged>
        /// <unmanaged-short>ID2D1Properties::GetPropertyCount</unmanaged-short>
        internal unsafe System.Int32 GetPropertyCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// Gets the property name that corresponds to the given index.
        /// </summary>
        /// <param name = "index">No documentation.</param>
        /// <param name = "name">No documentation.</param>
        /// <param name = "nameCount">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>jj151735</doc-id>
        /// <unmanaged>HRESULT ID2D1Properties::GetPropertyName([In] unsigned int index,[Out, Buffer] wchar_t* name,[In] unsigned int nameCount)</unmanaged>
        /// <unmanaged-short>ID2D1Properties::GetPropertyName</unmanaged-short>
        internal unsafe void GetPropertyName(System.Int32 index, System.IntPtr name, System.Int32 nameCount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, index, (void *)name, nameCount, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets  the number of characters for the given property name.  This is a template overload. See Remarks.</p>
        /// </summary>
        /// <param name = "index"><dd>  <p>The index of the property name to retrieve.</p> </dd></param>
        /// <returns><p>This method returns the size in characters of the name corresponding to the given property index, or zero if the property index does not exist. </p></returns>
        /// <remarks>
        /// <p>The value returned by this method can be used to ensure that the buffer size for <strong>GetPropertyName</strong> is appropriate. </p><p> </p>template&lt;typename U&gt; UINT32 GetPropertyNameLength( U index ) CONST;
        /// </remarks>
        /// <doc-id>jj151733</doc-id>
        /// <unmanaged>unsigned int ID2D1Properties::GetPropertyNameLength([In] unsigned int index)</unmanaged>
        /// <unmanaged-short>ID2D1Properties::GetPropertyNameLength</unmanaged-short>
        internal unsafe System.Int32 GetPropertyNameLength(System.Int32 index)
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, index, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the <strong><see cref = "SharpDX.Direct2D1.PropertyType"/></strong> of the selected property. </p>
        /// </summary>
        /// <param name = "index">No documentation.</param>
        /// <returns><p>This method returns a <strong><see cref = "SharpDX.Direct2D1.PropertyType"/></strong>-typed value for the type of the selected property.</p></returns>
        /// <remarks>
        /// <p>If the property does not exist, the method returns <strong>D2D1_PROPERTY_TYPE_UNKNOWN</strong>.</p>
        /// </remarks>
        /// <doc-id>hh446873</doc-id>
        /// <unmanaged>D2D1_PROPERTY_TYPE ID2D1Properties::GetType([In] unsigned int index)</unmanaged>
        /// <unmanaged-short>ID2D1Properties::GetType</unmanaged-short>
        public unsafe SharpDX.Direct2D1.PropertyType GetTypeInfo(System.Int32 index)
        {
            SharpDX.Direct2D1.PropertyType __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1PropertyType(this._nativePointer, index, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the index corresponding to the given property name. </p>
        /// </summary>
        /// <param name = "name"><dd>  <p>The name of the property to retrieve.</p> </dd></param>
        /// <returns><p>The index of the corresponding property name.</p></returns>
        /// <remarks>
        /// <p> If the property does not exist, this method returns <strong>D2D1_INVALID_PROPERTY_INDEX</strong>. This reserved value will never map to a valid index and will cause <strong><c>null</c></strong> or sentinel values to be returned from other parts of the property interface.</p>
        /// </remarks>
        /// <doc-id>hh446861</doc-id>
        /// <unmanaged>unsigned int ID2D1Properties::GetPropertyIndex([In] const wchar_t* name)</unmanaged>
        /// <unmanaged-short>ID2D1Properties::GetPropertyIndex</unmanaged-short>
        public unsafe System.Int32 GetPropertyIndex(System.String name)
        {
            System.Int32 __result__;
            fixed (char *name_ = name)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }

        /// <summary>
        /// Sets the named property to the given value.
        /// </summary>
        /// <param name = "name">No documentation.</param>
        /// <param name = "type">No documentation.</param>
        /// <param name = "data">No documentation.</param>
        /// <param name = "dataSize">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <doc-id>hh997717</doc-id>
        /// <unmanaged>HRESULT ID2D1Properties::SetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const unsigned char* data,[In] unsigned int dataSize)</unmanaged>
        /// <unmanaged-short>ID2D1Properties::SetValueByName</unmanaged-short>
        public unsafe void SetValueByName(System.String name, SharpDX.Direct2D1.PropertyType type, System.IntPtr data, System.Int32 dataSize)
        {
            SharpDX.Result __result__;
            fixed (char *name_ = name)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, unchecked ((System.Int32)type), (void *)data, dataSize, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the corresponding  property by index. This is a template overload. See Remarks.</p>
        /// </summary>
        /// <param name = "index"><dd> <p>The index of the property to set.</p> </dd></param>
        /// <param name = "type"><dd> <p>The data to set.</p> </dd></param>
        /// <param name = "data">No documentation.</param>
        /// <param name = "dataSize">No documentation.</param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref = "InvalidProperty"/></td><td>The specified property does not exist.</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Failed to allocate necessary memory.</td></tr> <tr><td>D3DERR_OUT_OF_VIDEO_MEMORY</td><td>Failed to allocate required video memory.</td></tr> <tr><td>E_INVALIDARG</td><td>One or more arguments are invalid.</td></tr> <tr><td>E_FAIL</td><td>Unspecified failure.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p> </p>template&lt;typename T, typename U&gt; <see cref = "SharpDX.Result"/> SetValue( U index, _In_ const T &amp;value );
        /// </remarks>
        /// <doc-id>jj151751</doc-id>
        /// <unmanaged>HRESULT ID2D1Properties::SetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[In, Buffer] const unsigned char* data,[In] unsigned int dataSize)</unmanaged>
        /// <unmanaged-short>ID2D1Properties::SetValue</unmanaged-short>
        public unsafe void SetValue(System.Int32 index, SharpDX.Direct2D1.PropertyType type, System.IntPtr data, System.Int32 dataSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, index, unchecked ((System.Int32)type), (void *)data, dataSize, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the property value by name. This is a template overload. See Remarks.</p>
        /// </summary>
        /// <param name = "name"><dd>  <p>The property name to get.</p> </dd></param>
        /// <param name = "type">No documentation.</param>
        /// <param name = "data">No documentation.</param>
        /// <param name = "dataSize">No documentation.</param>
        /// <returns><p>Returns the value requested.</p></returns>
        /// <remarks>
        /// <p>If <em>propertyName</em> does not exist, no information is retrieved.</p><p>Any error not in the standard set returned by a property implementation will be mapped into the standard error range.</p><p> </p>template&lt;typename T&gt; T GetValueByName( _In_ PCWSTR propertyName ) const;
        /// </remarks>
        /// <doc-id>jj151746</doc-id>
        /// <unmanaged>HRESULT ID2D1Properties::GetValueByName([In] const wchar_t* name,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] unsigned char* data,[In] unsigned int dataSize)</unmanaged>
        /// <unmanaged-short>ID2D1Properties::GetValueByName</unmanaged-short>
        public unsafe void GetValueByName(System.String name, SharpDX.Direct2D1.PropertyType type, System.IntPtr data, System.Int32 dataSize)
        {
            SharpDX.Result __result__;
            fixed (char *name_ = name)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, unchecked ((System.Int32)type), (void *)data, dataSize, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets  the value of the property by index. This is a template overload. See Remarks.</p>
        /// </summary>
        /// <param name = "index"><dd>  <p>The index of the property from which the value is to be obtained.</p> </dd></param>
        /// <param name = "type">No documentation.</param>
        /// <param name = "data">No documentation.</param>
        /// <param name = "dataSize">No documentation.</param>
        /// <returns><p>Returns the value requested.</p></returns>
        /// <remarks>
        /// <p> </p>template&lt;typename T, typename U&gt; T GetValue( U index ) const;
        /// </remarks>
        /// <doc-id>jj151743</doc-id>
        /// <unmanaged>HRESULT ID2D1Properties::GetValue([In] unsigned int index,[In] D2D1_PROPERTY_TYPE type,[Out, Buffer] unsigned char* data,[In] unsigned int dataSize)</unmanaged>
        /// <unmanaged-short>ID2D1Properties::GetValue</unmanaged-short>
        public unsafe void GetValue(System.Int32 index, SharpDX.Direct2D1.PropertyType type, System.IntPtr data, System.Int32 dataSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, index, unchecked ((System.Int32)type), (void *)data, dataSize, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Gets the size of the property value in bytes, using the property index. This is a template overload. See Remarks.</p>
        /// </summary>
        /// <param name = "index"><dd>  <p>The index of the property.</p> </dd></param>
        /// <returns><p>This method returns size of the value in bytes, using the property index </p></returns>
        /// <remarks>
        /// <p>This method returns zero if <em>index</em> does not exist. </p><p> </p>template&lt;typename U&gt; UINT32 GetValueSize( U index ) CONST;
        /// </remarks>
        /// <doc-id>jj151748</doc-id>
        /// <unmanaged>unsigned int ID2D1Properties::GetValueSize([In] unsigned int index)</unmanaged>
        /// <unmanaged-short>ID2D1Properties::GetValueSize</unmanaged-short>
        public unsafe System.Int32 GetValueSize(System.Int32 index)
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, index, (*(void ***)this._nativePointer)[12]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the sub-properties of the provided property by index. This is a template overload.  See Remarks. </p>
        /// </summary>
        /// <param name = "index"><dd>  <p>The index of the  sub-properties to be retrieved.</p> </dd></param>
        /// <returns><dd>  <p>When this method returns, contains the address of a reference to the sub-properties.</p> </dd></returns>
        /// <remarks>
        /// <p> If there are no sub-properties, <em>subProperties</em> will be <strong><c>null</c></strong>, and <strong><see cref = "NoSubProperties"/></strong> will be returned. </p><p> </p>template&lt;typename U&gt; <see cref = "SharpDX.Result"/> GetSubProperties( U index, _Outptr_opt_ <see cref = "SharpDX.Direct2D1.Properties"/> **subProperties ) CONST;
        /// </remarks>
        /// <doc-id>jj151736</doc-id>
        /// <unmanaged>HRESULT ID2D1Properties::GetSubProperties([In] unsigned int index,[Out, Optional] ID2D1Properties** subProperties)</unmanaged>
        /// <unmanaged-short>ID2D1Properties::GetSubProperties</unmanaged-short>
        public unsafe SharpDX.Direct2D1.Properties GetSubProperties(System.Int32 index)
        {
            SharpDX.Direct2D1.Properties subProperties;
            System.IntPtr subProperties_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, index, &subProperties_, (*(void ***)this._nativePointer)[13]);
            if (subProperties_ != System.IntPtr.Zero)
                subProperties = new SharpDX.Direct2D1.Properties(subProperties_);
            else
                subProperties = null;
            __result__.CheckError();
            return subProperties;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd906ac-12e2-11dc-9fed-001143a055f9")]
    public partial class RadialGradientBrush : SharpDX.Direct2D1.Brush
    {
        public RadialGradientBrush(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RadialGradientBrush(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RadialGradientBrush(nativePtr);
        /// <summary>
        /// <p>Retrieves or sets the center of the gradient ellipse.  </p>
        /// </summary>
        /// <doc-id>dd371532</doc-id>
        /// <unmanaged>GetCenter / SetCenter</unmanaged>
        /// <unmanaged-short>GetCenter</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 Center
        {
            get => GetCenter();
            set => SetCenter(value);
        }

        /// <summary>
        /// <p>Retrieves or sets the offset of the gradient origin relative to the gradient ellipse's center. </p>
        /// </summary>
        /// <doc-id>dd371535</doc-id>
        /// <unmanaged>GetGradientOriginOffset / SetGradientOriginOffset</unmanaged>
        /// <unmanaged-short>GetGradientOriginOffset</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawVector2 GradientOriginOffset
        {
            get => GetGradientOriginOffset();
            set => SetGradientOriginOffset(value);
        }

        /// <summary>
        /// <p>Retrieves or sets the x-radius of the gradient ellipse. </p>
        /// </summary>
        /// <doc-id>dd371542</doc-id>
        /// <unmanaged>GetRadiusX / SetRadiusX</unmanaged>
        /// <unmanaged-short>GetRadiusX</unmanaged-short>
        public System.Single RadiusX
        {
            get => GetRadiusX();
            set => SetRadiusX(value);
        }

        /// <summary>
        /// <p>Retrieves or sets the y-radius of the gradient ellipse. </p>
        /// </summary>
        /// <doc-id>dd371544</doc-id>
        /// <unmanaged>GetRadiusY / SetRadiusY</unmanaged>
        /// <unmanaged-short>GetRadiusY</unmanaged-short>
        public System.Single RadiusY
        {
            get => GetRadiusY();
            set => SetRadiusY(value);
        }

        /// <summary>
        /// <p>Retrieves the <strong><see cref = "SharpDX.Direct2D1.GradientStopCollection"/></strong> associated with this radial gradient brush object.</p>
        /// </summary>
        /// <remarks>
        /// <p> <strong><see cref = "SharpDX.Direct2D1.GradientStopCollection"/></strong> contains an array of <strong><see cref = "SharpDX.Direct2D1.GradientStop"/></strong> structures and additional information, such as the extend mode and the color interpolation mode.</p>
        /// </remarks>
        /// <doc-id>dd371539</doc-id>
        /// <unmanaged>GetGradientStopCollection</unmanaged>
        /// <unmanaged-short>GetGradientStopCollection</unmanaged-short>
        public SharpDX.Direct2D1.GradientStopCollection GradientStopCollection
        {
            get
            {
                GetGradientStopCollection(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Specifies the center of the gradient ellipse in the brush's coordinate space. </p>
        /// </summary>
        /// <param name = "center"><dd>  <p>The center of the gradient ellipse, in the brush's coordinate space.</p> </dd></param>
        /// <doc-id>dd371547</doc-id>
        /// <unmanaged>void ID2D1RadialGradientBrush::SetCenter([In] D2D_POINT_2F center)</unmanaged>
        /// <unmanaged-short>ID2D1RadialGradientBrush::SetCenter</unmanaged-short>
        internal unsafe void SetCenter(SharpDX.Mathematics.Interop.RawVector2 center)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, center, (*(void ***)this._nativePointer)[8]);
        }

        /// <summary>
        /// <p>Specifies the offset of the gradient origin relative to the gradient ellipse's center.</p>
        /// </summary>
        /// <param name = "gradientOriginOffset"><dd>  <p>The offset of the gradient origin from the center of the gradient ellipse.</p> </dd></param>
        /// <doc-id>dd371550</doc-id>
        /// <unmanaged>void ID2D1RadialGradientBrush::SetGradientOriginOffset([In] D2D_POINT_2F gradientOriginOffset)</unmanaged>
        /// <unmanaged-short>ID2D1RadialGradientBrush::SetGradientOriginOffset</unmanaged-short>
        internal unsafe void SetGradientOriginOffset(SharpDX.Mathematics.Interop.RawVector2 gradientOriginOffset)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, gradientOriginOffset, (*(void ***)this._nativePointer)[9]);
        }

        /// <summary>
        /// <p> Specifies the x-radius of the gradient ellipse, in the brush's coordinate space.</p>
        /// </summary>
        /// <param name = "radiusX"><dd>  <p>The x-radius of the gradient ellipse. This value is in the brush's coordinate space.</p> </dd></param>
        /// <doc-id>dd371553</doc-id>
        /// <unmanaged>void ID2D1RadialGradientBrush::SetRadiusX([In] float radiusX)</unmanaged>
        /// <unmanaged-short>ID2D1RadialGradientBrush::SetRadiusX</unmanaged-short>
        internal unsafe void SetRadiusX(System.Single radiusX)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, radiusX, (*(void ***)this._nativePointer)[10]);
        }

        /// <summary>
        /// <p>Specifies the y-radius of the gradient ellipse, in the brush's coordinate space. </p>
        /// </summary>
        /// <param name = "radiusY"><dd>  <p>The y-radius of the gradient ellipse. This value is in the brush's coordinate space.</p> </dd></param>
        /// <doc-id>dd371557</doc-id>
        /// <unmanaged>void ID2D1RadialGradientBrush::SetRadiusY([In] float radiusY)</unmanaged>
        /// <unmanaged-short>ID2D1RadialGradientBrush::SetRadiusY</unmanaged-short>
        internal unsafe void SetRadiusY(System.Single radiusY)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, radiusY, (*(void ***)this._nativePointer)[11]);
        }

        /// <summary>
        /// <p>Retrieves the center of the gradient ellipse.  </p>
        /// </summary>
        /// <returns><p>The center of the gradient ellipse. This value is expressed in the brush's coordinate space.</p></returns>
        /// <doc-id>dd371532</doc-id>
        /// <unmanaged>D2D_POINT_2F ID2D1RadialGradientBrush::GetCenter()</unmanaged>
        /// <unmanaged-short>ID2D1RadialGradientBrush::GetCenter</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawVector2 GetCenter()
        {
            SharpDX.Mathematics.Interop.RawVector2 __result__;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[12]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves the offset of the gradient origin relative to the gradient ellipse's center. </p>
        /// </summary>
        /// <returns><p>The offset of the gradient origin from the center of the gradient ellipse. This value is expressed in the brush's coordinate space.</p></returns>
        /// <doc-id>dd371535</doc-id>
        /// <unmanaged>D2D_POINT_2F ID2D1RadialGradientBrush::GetGradientOriginOffset()</unmanaged>
        /// <unmanaged-short>ID2D1RadialGradientBrush::GetGradientOriginOffset</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawVector2 GetGradientOriginOffset()
        {
            SharpDX.Mathematics.Interop.RawVector2 __result__;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[13]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves the x-radius of the gradient ellipse. </p>
        /// </summary>
        /// <returns><p>The x-radius of the gradient ellipse. This value is expressed in the brush's coordinate space.</p></returns>
        /// <doc-id>dd371542</doc-id>
        /// <unmanaged>float ID2D1RadialGradientBrush::GetRadiusX()</unmanaged>
        /// <unmanaged-short>ID2D1RadialGradientBrush::GetRadiusX</unmanaged-short>
        internal unsafe System.Single GetRadiusX()
        {
            System.Single __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallfloat(this._nativePointer, (*(void ***)this._nativePointer)[14]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves the y-radius of the gradient ellipse. </p>
        /// </summary>
        /// <returns><p>The y-radius of the gradient ellipse. This value is expressed in the brush's coordinate space.</p></returns>
        /// <doc-id>dd371544</doc-id>
        /// <unmanaged>float ID2D1RadialGradientBrush::GetRadiusY()</unmanaged>
        /// <unmanaged-short>ID2D1RadialGradientBrush::GetRadiusY</unmanaged-short>
        internal unsafe System.Single GetRadiusY()
        {
            System.Single __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallfloat(this._nativePointer, (*(void ***)this._nativePointer)[15]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves the <strong><see cref = "SharpDX.Direct2D1.GradientStopCollection"/></strong> associated with this radial gradient brush object.</p>
        /// </summary>
        /// <param name = "gradientStopCollection">No documentation.</param>
        /// <remarks>
        /// <p> <strong><see cref = "SharpDX.Direct2D1.GradientStopCollection"/></strong> contains an array of <strong><see cref = "SharpDX.Direct2D1.GradientStop"/></strong> structures and additional information, such as the extend mode and the color interpolation mode.</p>
        /// </remarks>
        /// <doc-id>dd371539</doc-id>
        /// <unmanaged>void ID2D1RadialGradientBrush::GetGradientStopCollection([Out] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
        /// <unmanaged-short>ID2D1RadialGradientBrush::GetGradientStopCollection</unmanaged-short>
        internal unsafe void GetGradientStopCollection(out SharpDX.Direct2D1.GradientStopCollection gradientStopCollection)
        {
            System.IntPtr gradientStopCollection_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &gradientStopCollection_, (*(void ***)this._nativePointer)[16]);
            if (gradientStopCollection_ != System.IntPtr.Zero)
                gradientStopCollection = new SharpDX.Direct2D1.GradientStopCollection(gradientStopCollection_);
            else
                gradientStopCollection = null;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd906a2-12e2-11dc-9fed-001143a055f9")]
    public partial class RectangleGeometry : SharpDX.Direct2D1.Geometry
    {
        public RectangleGeometry(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RectangleGeometry(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RectangleGeometry(nativePtr);
        /// <summary>
        /// <p> Retrieves the rectangle that describes the rectangle geometry's dimensions.</p>
        /// </summary>
        /// <doc-id>dd371762</doc-id>
        /// <unmanaged>GetRect</unmanaged>
        /// <unmanaged-short>GetRect</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawRectangleF Rectangle
        {
            get
            {
                GetRectangle(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Retrieves the rectangle that describes the rectangle geometry's dimensions.</p>
        /// </summary>
        /// <param name = "rect"><dd>  <p>Contains a reference to a rectangle that describes the rectangle geometry's dimensions when this method returns. You must allocate storage for this parameter. </p> </dd></param>
        /// <doc-id>dd371762</doc-id>
        /// <unmanaged>void ID2D1RectangleGeometry::GetRect([Out] D2D_RECT_F* rect)</unmanaged>
        /// <unmanaged-short>ID2D1RectangleGeometry::GetRect</unmanaged-short>
        internal unsafe void GetRectangle(out SharpDX.Mathematics.Interop.RawRectangleF rect)
        {
            rect = default (SharpDX.Mathematics.Interop.RawRectangleF);
            fixed (void *rect_ = &rect)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, rect_, (*(void ***)this._nativePointer)[17]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("519ae1bd-d19a-420d-b849-364f594776b7")]
    public partial class RenderInformation : SharpDX.ComObject
    {
        public RenderInformation(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RenderInformation(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RenderInformation(nativePtr);
        /// <summary>
        /// <p>Specifies that the output of the transform in which the render information is encapsulated is or is not cached.</p>
        /// </summary>
        /// <doc-id>hh446891</doc-id>
        /// <unmanaged>SetCached</unmanaged>
        /// <unmanaged-short>SetCached</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool Cached
        {
            set => SetCached(value);
        }

        /// <summary>
        /// <p>Provides an estimated hint of shader execution cost to D2D.</p>
        /// </summary>
        /// <remarks>
        /// <p>The instruction count may be set according to the number of instructions in the shader.  This information is used as a hint when rendering extremely large images.  Calling this API is optional, but it may  improve performance if you provide an accurate number. </p><strong>Note</strong>??Instructions that occur in a loop should be counted according to the number of loop iterations.?
        /// </remarks>
        /// <doc-id>hh871466</doc-id>
        /// <unmanaged>SetInstructionCountHint</unmanaged>
        /// <unmanaged-short>SetInstructionCountHint</unmanaged-short>
        public System.Int32 InstructionCountHint
        {
            set => SetInstructionCountHint(value);
        }

        /// <summary>
        /// <p>Sets how a specific input to the transform should be handled by the renderer in terms of sampling.</p>
        /// </summary>
        /// <param name = "inputIndex"><dd>  <p>The index of the input that will have the input description applied.</p> </dd></param>
        /// <param name = "inputDescription"><dd>  <p>The description of the input to be applied to the transform.</p> </dd></param>
        /// <returns><p>The method returns an <see cref = "SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The input description must be matched correctly by the effect shader code.</p>
        /// </remarks>
        /// <doc-id>hh446892</doc-id>
        /// <unmanaged>HRESULT ID2D1RenderInfo::SetInputDescription([In] unsigned int inputIndex,[In] D2D1_INPUT_DESCRIPTION inputDescription)</unmanaged>
        /// <unmanaged-short>ID2D1RenderInfo::SetInputDescription</unmanaged-short>
        public unsafe void SetInputDescription(System.Int32 inputIndex, SharpDX.Direct2D1.InputDescription inputDescription)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, inputIndex, inputDescription, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Allows a caller to control the output precision and channel-depth of the transform in which the render information is encapsulated.</p>
        /// </summary>
        /// <param name = "bufferPrecision"><dd>  <p>The type of buffer that should be used as an output from this transform.</p> </dd></param>
        /// <param name = "channelDepth"><dd>  <p>The number of channels that will be used on the output buffer. </p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p> If the output precision of the transform is not specified, then it will default to the precision specified on the Direct2D device context. The maximum of 16bpc <strong>UNORM</strong> and 16bpc <strong>FLOAT</strong> is 32bpc <strong>FLOAT</strong>.</p><p>The output channel depth will match the maximum of the input channel depths if the channel depth is <strong>D2D1_CHANNEL_DEPTH_DEFAULT</strong>.</p><p>There is no global output channel depth, this is always left to the control of the transforms. </p>
        /// </remarks>
        /// <doc-id>hh446893</doc-id>
        /// <unmanaged>HRESULT ID2D1RenderInfo::SetOutputBuffer([In] D2D1_BUFFER_PRECISION bufferPrecision,[In] D2D1_CHANNEL_DEPTH channelDepth)</unmanaged>
        /// <unmanaged-short>ID2D1RenderInfo::SetOutputBuffer</unmanaged-short>
        public unsafe void SetOutputBuffer(SharpDX.Direct2D1.BufferPrecision bufferPrecision, SharpDX.Direct2D1.ChannelDepth channelDepth)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)bufferPrecision), unchecked ((System.Int32)channelDepth), (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Specifies that the output of the transform in which the render information is encapsulated is or is not cached.</p>
        /// </summary>
        /// <param name = "isCached"><dd>  <p><strong>TRUE</strong> if the output of the transform is cached; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p> </dd></param>
        /// <doc-id>hh446891</doc-id>
        /// <unmanaged>void ID2D1RenderInfo::SetCached([In] BOOL isCached)</unmanaged>
        /// <unmanaged-short>ID2D1RenderInfo::SetCached</unmanaged-short>
        internal unsafe void SetCached(SharpDX.Mathematics.Interop.RawBool isCached)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, isCached, (*(void ***)this._nativePointer)[5]);
        }

        /// <summary>
        /// <p>Provides an estimated hint of shader execution cost to D2D.</p>
        /// </summary>
        /// <param name = "instructionCount"><dd>  <p>An approximate instruction count of the associated shader.</p> </dd></param>
        /// <remarks>
        /// <p>The instruction count may be set according to the number of instructions in the shader.  This information is used as a hint when rendering extremely large images.  Calling this API is optional, but it may  improve performance if you provide an accurate number. </p><strong>Note</strong>??Instructions that occur in a loop should be counted according to the number of loop iterations.?
        /// </remarks>
        /// <doc-id>hh871466</doc-id>
        /// <unmanaged>void ID2D1RenderInfo::SetInstructionCountHint([In] unsigned int instructionCount)</unmanaged>
        /// <unmanaged-short>ID2D1RenderInfo::SetInstructionCountHint</unmanaged-short>
        internal unsafe void SetInstructionCountHint(System.Int32 instructionCount)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, instructionCount, (*(void ***)this._nativePointer)[6]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd90694-12e2-11dc-9fed-001143a055f9")]
    public partial class RenderTarget : SharpDX.Direct2D1.Resource
    {
        public RenderTarget(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RenderTarget(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RenderTarget(nativePtr);
        /// <summary>
        /// <p>Gets or sets the current transform of the render target. </p>
        /// </summary>
        /// <doc-id>dd316845</doc-id>
        /// <unmanaged>GetTransform / SetTransform</unmanaged>
        /// <unmanaged-short>GetTransform</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 Transform
        {
            get
            {
                GetTransform(out var __output__);
                return __output__;
            }

            set => SetTransform(ref value);
        }

        /// <summary>
        /// <p>Retrieves or sets the current antialiasing mode for nontext drawing operations.</p>
        /// </summary>
        /// <doc-id>dd316805</doc-id>
        /// <unmanaged>GetAntialiasMode / SetAntialiasMode</unmanaged>
        /// <unmanaged-short>GetAntialiasMode</unmanaged-short>
        public SharpDX.Direct2D1.AntialiasMode AntialiasMode
        {
            get => GetAntialiasMode();
            set => SetAntialiasMode(value);
        }

        /// <summary>
        /// <p>Gets or sets the current antialiasing mode for text and glyph drawing operations. </p>
        /// </summary>
        /// <doc-id>dd316835</doc-id>
        /// <unmanaged>GetTextAntialiasMode / SetTextAntialiasMode</unmanaged>
        /// <unmanaged-short>GetTextAntialiasMode</unmanaged-short>
        public SharpDX.Direct2D1.TextAntialiasMode TextAntialiasMode
        {
            get => GetTextAntialiasMode();
            set => SetTextAntialiasMode(value);
        }

        /// <summary>
        /// <p>Retrieves or sets the render target's current text rendering options. </p>
        /// </summary>
        /// <remarks>
        /// <p>If the settings specified by  <em>textRenderingParams</em> are incompatible with the render target's text antialiasing mode (specified by <strong>SetTextAntialiasMode</strong>), subsequent text and glyph drawing operations will fail and put the render target into an error state.</p>
        /// </remarks>
        /// <doc-id>dd316841</doc-id>
        /// <unmanaged>GetTextRenderingParams / SetTextRenderingParams</unmanaged>
        /// <unmanaged-short>GetTextRenderingParams</unmanaged-short>
        public SharpDX.DirectWrite.RenderingParams TextRenderingParams
        {
            get
            {
                GetTextRenderingParams(out var __output__);
                return __output__;
            }

            set => SetTextRenderingParams(value);
        }

        /// <summary>
        /// <p>Retrieves the pixel format and alpha mode of the render target. </p>
        /// </summary>
        /// <doc-id>dd316814</doc-id>
        /// <unmanaged>GetPixelFormat</unmanaged>
        /// <unmanaged-short>GetPixelFormat</unmanaged-short>
        public SharpDX.Direct2D1.PixelFormat PixelFormat
        {
            get => GetPixelFormat();
        }

        /// <summary>
        /// <p>Returns the size of the render target in device-independent pixels.</p>
        /// </summary>
        /// <doc-id>dd316823</doc-id>
        /// <unmanaged>GetSize</unmanaged>
        /// <unmanaged-short>GetSize</unmanaged-short>
        public SharpDX.Size2F Size
        {
            get => GetSize();
        }

        /// <summary>
        /// <p>Returns the size of the render target in device pixels.</p>
        /// </summary>
        /// <doc-id>dd316820</doc-id>
        /// <unmanaged>GetPixelSize</unmanaged>
        /// <unmanaged-short>GetPixelSize</unmanaged-short>
        public SharpDX.Size2 PixelSize
        {
            get => GetPixelSize();
        }

        /// <summary>
        /// <p>Gets the maximum size, in device-dependent units (pixels), of  any one bitmap dimension supported by the render target.</p>
        /// </summary>
        /// <remarks>
        /// <p>This method returns the maximum texture size of the Direct3D device.</p><strong>Note</strong>??The software renderer and WARP devices return the value of 16 megapixels (16*1024*1024).  You can create a Direct2D texture that is this size, but not a Direct3D texture that is this size.?
        /// </remarks>
        /// <doc-id>dd742853</doc-id>
        /// <unmanaged>GetMaximumBitmapSize</unmanaged>
        /// <unmanaged-short>GetMaximumBitmapSize</unmanaged-short>
        public System.Int32 MaximumBitmapSize
        {
            get => GetMaximumBitmapSize();
        }

        /// <summary>
        /// <p>Creates a Direct2D bitmap from a reference to in-memory source data.</p>
        /// </summary>
        /// <param name = "size"><dd>  <p>The dimension of the bitmap to create in pixels.</p> </dd></param>
        /// <param name = "srcData"><dd>  <p>A reference to the memory location of the image data, or <strong><c>null</c></strong> to create an uninitialized bitmap.</p> </dd></param>
        /// <param name = "pitch"><dd>  <p>The byte count of each scanline, which is equal to (the image width in pixels ? the number of bytes per pixel) + memory padding. If <em>srcData</em> is <strong><c>null</c></strong>, this value is ignored. (Note that pitch is also sometimes called <em>stride</em>.)</p> </dd></param>
        /// <param name = "bitmapProperties"><dd>  <p>The pixel format and dots per inch (DPI) of the bitmap to create.</p> </dd></param>
        /// <param name = "bitmap"><dd>  <p>When this method returns, contains a reference to a reference to the new bitmap. This parameter is passed uninitialized.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371800</doc-id>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmap([In] D2D_SIZE_U size,[In, Optional] const void* srcData,[In] unsigned int pitch,[In] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::CreateBitmap</unmanaged-short>
        internal unsafe void CreateBitmap(SharpDX.Size2 size, System.IntPtr srcData, System.Int32 pitch, SharpDX.Direct2D1.BitmapProperties bitmapProperties, SharpDX.Direct2D1.Bitmap bitmap)
        {
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, size, (void *)srcData, pitch, &bitmapProperties, &bitmap_, (*(void ***)this._nativePointer)[4]);
            (bitmap).NativePointer = bitmap_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.Direct2D1.Bitmap"/></strong> by copying the specified Microsoft Windows Imaging Component (WIC)   bitmap.</p>
        /// </summary>
        /// <param name = "wicBitmapSource">No documentation.</param>
        /// <param name = "bitmapProperties">No documentation.</param>
        /// <param name = "bitmap">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Before Direct2D can load a WIC bitmap, that bitmap must be converted to a supported pixel format and alpha mode. For a list of supported pixel formats and alpha modes, see Supported Pixel Formats and Alpha Modes. </p>
        /// </remarks>
        /// <doc-id>dd371797</doc-id>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmapFromWicBitmap([In] IWICBitmapSource* wicBitmapSource,[In, Optional] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out] ID2D1Bitmap** bitmap)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::CreateBitmapFromWicBitmap</unmanaged-short>
        internal unsafe void CreateBitmapFromWicBitmap(SharpDX.WIC.BitmapSource wicBitmapSource, SharpDX.Direct2D1.BitmapProperties? bitmapProperties, out SharpDX.Direct2D1.Bitmap bitmap)
        {
            System.IntPtr wicBitmapSource_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.BitmapProperties bitmapProperties_;
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            wicBitmapSource_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.WIC.BitmapSource>(wicBitmapSource);
            if (bitmapProperties != null)
                bitmapProperties_ = bitmapProperties.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)wicBitmapSource_, bitmapProperties == null ? (void *)0 : &bitmapProperties_, &bitmap_, (*(void ***)this._nativePointer)[5]);
            if (bitmap_ != System.IntPtr.Zero)
                bitmap = new SharpDX.Direct2D1.Bitmap(bitmap_);
            else
                bitmap = null;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.Direct2D1.Bitmap"/></strong> whose data is shared with another resource.</p>
        /// </summary>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "data">No documentation.</param>
        /// <param name = "bitmapProperties">No documentation.</param>
        /// <param name = "bitmap">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The <strong>CreateSharedBitmap</strong> method is useful for efficiently reusing bitmap data and can also be used to provide interoperability with Direct3D. </p>
        /// </remarks>
        /// <doc-id>dd371865</doc-id>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateSharedBitmap([In] const GUID&amp; riid,[In] void* data,[In, Optional] const D2D1_BITMAP_PROPERTIES* bitmapProperties,[Out, Fast] ID2D1Bitmap** bitmap)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::CreateSharedBitmap</unmanaged-short>
        internal unsafe void CreateSharedBitmap(System.Guid riid, System.IntPtr data, SharpDX.Direct2D1.BitmapProperties? bitmapProperties, SharpDX.Direct2D1.Bitmap bitmap)
        {
            SharpDX.Direct2D1.BitmapProperties bitmapProperties_;
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (bitmapProperties != null)
                bitmapProperties_ = bitmapProperties.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &riid, (void *)data, bitmapProperties == null ? (void *)0 : &bitmapProperties_, &bitmap_, (*(void ***)this._nativePointer)[6]);
            (bitmap).NativePointer = bitmap_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.Direct2D1.BitmapBrush"/></strong> from the specified bitmap.</p>
        /// </summary>
        /// <param name = "bitmap">No documentation.</param>
        /// <param name = "bitmapBrushProperties">No documentation.</param>
        /// <param name = "brushProperties">No documentation.</param>
        /// <param name = "bitmapBrush">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371788</doc-id>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateBitmapBrush([In, Optional] ID2D1Bitmap* bitmap,[In, Optional] const D2D1_BITMAP_BRUSH_PROPERTIES* bitmapBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1BitmapBrush** bitmapBrush)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::CreateBitmapBrush</unmanaged-short>
        internal unsafe void CreateBitmapBrush(SharpDX.Direct2D1.Bitmap bitmap, SharpDX.Direct2D1.BitmapBrushProperties? bitmapBrushProperties, SharpDX.Direct2D1.BrushProperties? brushProperties, SharpDX.Direct2D1.BitmapBrush bitmapBrush)
        {
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.BitmapBrushProperties bitmapBrushProperties_;
            SharpDX.Direct2D1.BrushProperties brushProperties_;
            System.IntPtr bitmapBrush_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            bitmap_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Bitmap>(bitmap);
            if (bitmapBrushProperties != null)
                bitmapBrushProperties_ = bitmapBrushProperties.Value;
            if (brushProperties != null)
                brushProperties_ = brushProperties.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)bitmap_, bitmapBrushProperties == null ? (void *)0 : &bitmapBrushProperties_, brushProperties == null ? (void *)0 : &brushProperties_, &bitmapBrush_, (*(void ***)this._nativePointer)[7]);
            (bitmapBrush).NativePointer = bitmapBrush_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a new <strong><see cref = "SharpDX.Direct2D1.SolidColorBrush"/></strong> that has the specified color and a base opacity of 1.0f.  </p>
        /// </summary>
        /// <param name = "color">No documentation.</param>
        /// <param name = "brushProperties">No documentation.</param>
        /// <param name = "solidColorBrush">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371871</doc-id>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateSolidColorBrush([In] const D2D_COLOR_F* color,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[Out, Fast] ID2D1SolidColorBrush** solidColorBrush)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::CreateSolidColorBrush</unmanaged-short>
        internal unsafe void CreateSolidColorBrush(SharpDX.Mathematics.Interop.RawColor4 color, SharpDX.Direct2D1.BrushProperties? brushProperties, SharpDX.Direct2D1.SolidColorBrush solidColorBrush)
        {
            SharpDX.Direct2D1.BrushProperties brushProperties_;
            System.IntPtr solidColorBrush_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (brushProperties != null)
                brushProperties_ = brushProperties.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &color, brushProperties == null ? (void *)0 : &brushProperties_, &solidColorBrush_, (*(void ***)this._nativePointer)[8]);
            (solidColorBrush).NativePointer = solidColorBrush_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates an <strong><see cref = "SharpDX.Direct2D1.GradientStopCollection"/></strong> from the specified gradient stops that uses the <strong>D2D1_GAMMA_2_2</strong> color interpolation gamma and the clamp extend mode.</p>
        /// </summary>
        /// <param name = "gradientStops">No documentation.</param>
        /// <param name = "gradientStopsCount">No documentation.</param>
        /// <param name = "colorInterpolationGamma">No documentation.</param>
        /// <param name = "extendMode">No documentation.</param>
        /// <param name = "gradientStopCollection">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371832</doc-id>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateGradientStopCollection([In, Buffer] const D2D1_GRADIENT_STOP* gradientStops,[In] unsigned int gradientStopsCount,[In] D2D1_GAMMA colorInterpolationGamma,[In] D2D1_EXTEND_MODE extendMode,[Out, Fast] ID2D1GradientStopCollection** gradientStopCollection)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::CreateGradientStopCollection</unmanaged-short>
        internal unsafe void CreateGradientStopCollection(SharpDX.Direct2D1.GradientStop[] gradientStops, System.Int32 gradientStopsCount, SharpDX.Direct2D1.Gamma colorInterpolationGamma, SharpDX.Direct2D1.ExtendMode extendMode, SharpDX.Direct2D1.GradientStopCollection gradientStopCollection)
        {
            System.IntPtr gradientStopCollection_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *gradientStops_ = gradientStops)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, gradientStops_, gradientStopsCount, unchecked ((System.Int32)colorInterpolationGamma), unchecked ((System.Int32)extendMode), &gradientStopCollection_, (*(void ***)this._nativePointer)[9]);
            (gradientStopCollection).NativePointer = gradientStopCollection_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.Direct2D1.LinearGradientBrush"/></strong> that contains the specified gradient stops, has no transform, and has a base opacity of 1.0. </p>
        /// </summary>
        /// <param name = "linearGradientBrushProperties">No documentation.</param>
        /// <param name = "brushProperties">No documentation.</param>
        /// <param name = "gradientStopCollection">No documentation.</param>
        /// <param name = "linearGradientBrush">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371845</doc-id>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateLinearGradientBrush([In] const D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES* linearGradientBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[In] ID2D1GradientStopCollection* gradientStopCollection,[Out, Fast] ID2D1LinearGradientBrush** linearGradientBrush)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::CreateLinearGradientBrush</unmanaged-short>
        internal unsafe void CreateLinearGradientBrush(SharpDX.Direct2D1.LinearGradientBrushProperties linearGradientBrushProperties, SharpDX.Direct2D1.BrushProperties? brushProperties, SharpDX.Direct2D1.GradientStopCollection gradientStopCollection, SharpDX.Direct2D1.LinearGradientBrush linearGradientBrush)
        {
            SharpDX.Direct2D1.BrushProperties brushProperties_;
            System.IntPtr gradientStopCollection_ = System.IntPtr.Zero;
            System.IntPtr linearGradientBrush_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (brushProperties != null)
                brushProperties_ = brushProperties.Value;
            gradientStopCollection_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.GradientStopCollection>(gradientStopCollection);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &linearGradientBrushProperties, brushProperties == null ? (void *)0 : &brushProperties_, (void *)gradientStopCollection_, &linearGradientBrush_, (*(void ***)this._nativePointer)[10]);
            (linearGradientBrush).NativePointer = linearGradientBrush_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates an <strong><see cref = "SharpDX.Direct2D1.RadialGradientBrush"/></strong> that contains the specified gradient stops, has no transform, and has a base opacity of 1.0. </p>
        /// </summary>
        /// <param name = "radialGradientBrushProperties">No documentation.</param>
        /// <param name = "brushProperties">No documentation.</param>
        /// <param name = "gradientStopCollection">No documentation.</param>
        /// <param name = "radialGradientBrush">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd371859</doc-id>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateRadialGradientBrush([In] const D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES* radialGradientBrushProperties,[In, Optional] const D2D1_BRUSH_PROPERTIES* brushProperties,[In] ID2D1GradientStopCollection* gradientStopCollection,[Out, Fast] ID2D1RadialGradientBrush** radialGradientBrush)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::CreateRadialGradientBrush</unmanaged-short>
        internal unsafe void CreateRadialGradientBrush(ref SharpDX.Direct2D1.RadialGradientBrushProperties radialGradientBrushProperties, SharpDX.Direct2D1.BrushProperties? brushProperties, SharpDX.Direct2D1.GradientStopCollection gradientStopCollection, SharpDX.Direct2D1.RadialGradientBrush radialGradientBrush)
        {
            SharpDX.Direct2D1.BrushProperties brushProperties_;
            System.IntPtr gradientStopCollection_ = System.IntPtr.Zero;
            System.IntPtr radialGradientBrush_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (brushProperties != null)
                brushProperties_ = brushProperties.Value;
            gradientStopCollection_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.GradientStopCollection>(gradientStopCollection);
            fixed (void *radialGradientBrushProperties_ = &radialGradientBrushProperties)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, radialGradientBrushProperties_, brushProperties == null ? (void *)0 : &brushProperties_, (void *)gradientStopCollection_, &radialGradientBrush_, (*(void ***)this._nativePointer)[11]);
            (radialGradientBrush).NativePointer = radialGradientBrush_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Creates a new  bitmap render target for use during intermediate offscreen drawing that is compatible with the current render target and has the same size, DPI, and pixel format (but not alpha mode) as the current render target.  </p>
        /// </summary>
        /// <param name = "desiredSize"><dd>  <p>When this method returns, contains a reference to a reference to a new bitmap render target. This parameter is passed uninitialized.</p> </dd></param>
        /// <param name = "desiredPixelSize">No documentation.</param>
        /// <param name = "desiredFormat">No documentation.</param>
        /// <param name = "options">No documentation.</param>
        /// <param name = "bitmapRenderTarget">No documentation.</param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The bitmap render target created by this method is not compatible with GDI and has an alpha mode of  <strong>D2D1_ALPHA_MODE_PREMULTIPLIED</strong>.</p>
        /// </remarks>
        /// <doc-id>dd371825</doc-id>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateCompatibleRenderTarget([In, Optional] const D2D_SIZE_F* desiredSize,[In, Optional] const D2D_SIZE_U* desiredPixelSize,[In, Optional] const D2D1_PIXEL_FORMAT* desiredFormat,[In] D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS options,[Out, Fast] ID2D1BitmapRenderTarget** bitmapRenderTarget)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::CreateCompatibleRenderTarget</unmanaged-short>
        internal unsafe void CreateCompatibleRenderTarget(SharpDX.Size2F? desiredSize, SharpDX.Size2? desiredPixelSize, SharpDX.Direct2D1.PixelFormat? desiredFormat, SharpDX.Direct2D1.CompatibleRenderTargetOptions options, SharpDX.Direct2D1.BitmapRenderTarget bitmapRenderTarget)
        {
            SharpDX.Size2F desiredSize_;
            SharpDX.Size2 desiredPixelSize_;
            SharpDX.Direct2D1.PixelFormat desiredFormat_;
            System.IntPtr bitmapRenderTarget_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (desiredSize != null)
                desiredSize_ = desiredSize.Value;
            if (desiredPixelSize != null)
                desiredPixelSize_ = desiredPixelSize.Value;
            if (desiredFormat != null)
                desiredFormat_ = desiredFormat.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, desiredSize == null ? (void *)0 : &desiredSize_, desiredPixelSize == null ? (void *)0 : &desiredPixelSize_, desiredFormat == null ? (void *)0 : &desiredFormat_, unchecked ((System.Int32)options), &bitmapRenderTarget_, (*(void ***)this._nativePointer)[12]);
            (bitmapRenderTarget).NativePointer = bitmapRenderTarget_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Creates a layer resource that can be used with this render target and its compatible render targets. The new layer has the specified initial size.  </p>
        /// </summary>
        /// <param name = "size"><dd>  <p>If (0, 0) is specified, no backing store is created behind the layer resource. The layer resource is allocated to the minimum size when <strong>PushLayer</strong> is called.</p> </dd></param>
        /// <param name = "layer"><dd>  <p>When the method returns, contains a reference to a reference to the new layer. This parameter is passed uninitialized.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Regardless of whether a size is initially specified, the layer automatically resizes as needed.</p>
        /// </remarks>
        /// <doc-id>dd371835</doc-id>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateLayer([In, Optional] const D2D_SIZE_F* size,[Out, Fast] ID2D1Layer** layer)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::CreateLayer</unmanaged-short>
        internal unsafe void CreateLayer(SharpDX.Size2F? size, SharpDX.Direct2D1.Layer layer)
        {
            SharpDX.Size2F size_;
            System.IntPtr layer_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (size != null)
                size_ = size.Value;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, size == null ? (void *)0 : &size_, &layer_, (*(void ***)this._nativePointer)[13]);
            (layer).NativePointer = layer_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Create a mesh that uses triangles to describe a shape.</p>
        /// </summary>
        /// <param name = "mesh"><dd>  <p>When this method returns, contains a reference to a reference to the new mesh.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>To populate a mesh, use its <strong>Open</strong> method to obtain an <strong><see cref = "SharpDX.Direct2D1.TessellationSink"/></strong>. To draw the mesh, use the render target's <strong>FillMesh</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd371851</doc-id>
        /// <unmanaged>HRESULT ID2D1RenderTarget::CreateMesh([Out, Fast] ID2D1Mesh** mesh)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::CreateMesh</unmanaged-short>
        internal unsafe void CreateMesh(SharpDX.Direct2D1.Mesh mesh)
        {
            System.IntPtr mesh_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &mesh_, (*(void ***)this._nativePointer)[14]);
            (mesh).NativePointer = mesh_;
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Draws a line between the specified points using the specified stroke style. </p>
        /// </summary>
        /// <param name = "point0"><dd>  <p>The start point of the line, in device-independent pixels.</p> </dd></param>
        /// <param name = "point1"><dd>  <p>The end point of the line, in device-independent pixels.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush used to paint the line's stroke.</p> </dd></param>
        /// <param name = "strokeWidth"><dd>  <p>The width of the stroke, in device-independent pixels. The value must be greater than or equal to 0.0f. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</p> </dd></param>
        /// <param name = "strokeStyle"><dd>  <p>The style of stroke to paint, or <strong><c>null</c></strong> to paint a solid line.</p> </dd></param>
        /// <remarks>
        /// <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawLine</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd371895</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::DrawLine([In] D2D_POINT_2F point0,[In] D2D_POINT_2F point1,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::DrawLine</unmanaged-short>
        public unsafe void DrawLine(SharpDX.Mathematics.Interop.RawVector2 point0, SharpDX.Mathematics.Interop.RawVector2 point1, SharpDX.Direct2D1.Brush brush, System.Single strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            System.IntPtr brush_ = System.IntPtr.Zero;
            System.IntPtr strokeStyle_ = System.IntPtr.Zero;
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            strokeStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.StrokeStyle>(strokeStyle);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, point0, point1, (void *)brush_, strokeWidth, (void *)strokeStyle_, (*(void ***)this._nativePointer)[15]);
        }

        public unsafe void DrawLine(Engine.Mathematics.LinearAlgebra.Vector2 point0, Engine.Mathematics.LinearAlgebra.Vector2 point1, SharpDX.Direct2D1.Brush brush, System.Single strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            System.IntPtr brush_ = System.IntPtr.Zero;
            System.IntPtr strokeStyle_ = System.IntPtr.Zero;
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            strokeStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.StrokeStyle>(strokeStyle);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, point0, point1, (void*)brush_, strokeWidth, (void*)strokeStyle_, (*(void***)this._nativePointer)[15]);
        }

        /// <summary>
        /// <p>Draws the outline of a rectangle that has the specified dimensions and stroke style. </p>
        /// </summary>
        /// <param name = "rect"><dd>  <p>The dimensions of the rectangle to draw, in device-independent pixels.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush used to paint the rectangle's stroke.</p> </dd></param>
        /// <param name = "strokeWidth"><dd>  <p>The width of the stroke, in device-independent pixels. The value must be greater than or equal to 0.0f. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</p> </dd></param>
        /// <param name = "strokeStyle"><dd>  <p>The style of stroke to paint, or <strong><c>null</c></strong> to paint a solid stroke.</p> </dd></param>
        /// <remarks>
        /// <p>When this method fails, it does not return an error code. To determine whether a drawing method (such as <strong>DrawRectangle</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> method. </p>
        /// </remarks>
        /// <doc-id>dd371902</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::DrawRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::DrawRectangle</unmanaged-short>
        public unsafe void DrawRectangle(SharpDX.Mathematics.Interop.RawRectangleF rect, SharpDX.Direct2D1.Brush brush, System.Single strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            System.IntPtr brush_ = System.IntPtr.Zero;
            System.IntPtr strokeStyle_ = System.IntPtr.Zero;
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            strokeStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.StrokeStyle>(strokeStyle);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &rect, (void *)brush_, strokeWidth, (void *)strokeStyle_, (*(void ***)this._nativePointer)[16]);
        }

        /// <summary>
        /// <p>Paints the interior of the specified rectangle. </p>
        /// </summary>
        /// <param name = "rect"><dd>  <p>The dimension of the rectangle to paint, in device-independent pixels.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush used to paint the rectangle's interior.</p> </dd></param>
        /// <remarks>
        /// <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>FillRectangle</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd371954</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::FillRectangle([In] const D2D_RECT_F* rect,[In] ID2D1Brush* brush)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::FillRectangle</unmanaged-short>
        public unsafe void FillRectangle(SharpDX.Mathematics.Interop.RawRectangleF rect, SharpDX.Direct2D1.Brush brush)
        {
            System.IntPtr brush_ = System.IntPtr.Zero;
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &rect, (void *)brush_, (*(void ***)this._nativePointer)[17]);
        }

        /// <summary>
        /// <p> Draws the outline of the specified rounded rectangle using the specified stroke style.</p>
        /// </summary>
        /// <param name = "roundedRect"><dd>  <p>The dimensions of the rounded rectangle to draw, in device-independent pixels.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush used to paint the rounded rectangle's outline. </p> </dd></param>
        /// <param name = "strokeWidth"><dd>  <p>The width of the stroke, in device-independent pixels. The value must be greater than or equal to 0.0f. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</p> </dd></param>
        /// <param name = "strokeStyle"><dd>  <p>The style of the rounded rectangle's stroke, or <strong><c>null</c></strong> to paint a solid stroke. The default value is <strong><c>null</c></strong>.</p> </dd></param>
        /// <remarks>
        /// <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawRoundedRectangle</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd371908</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::DrawRoundedRectangle([In] const D2D1_ROUNDED_RECT* roundedRect,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::DrawRoundedRectangle</unmanaged-short>
        public unsafe void DrawRoundedRectangle(ref SharpDX.Direct2D1.RoundedRectangle roundedRect, SharpDX.Direct2D1.Brush brush, System.Single strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            System.IntPtr brush_ = System.IntPtr.Zero;
            System.IntPtr strokeStyle_ = System.IntPtr.Zero;
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            strokeStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.StrokeStyle>(strokeStyle);
            fixed (void *roundedRect_ = &roundedRect)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, roundedRect_, (void *)brush_, strokeWidth, (void *)strokeStyle_, (*(void ***)this._nativePointer)[18]);
        }

        /// <summary>
        /// <p> Paints the interior of the specified rounded rectangle.</p>
        /// </summary>
        /// <param name = "roundedRect"><dd>  <p>The dimensions of the rounded rectangle to paint, in device-independent pixels.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush used to paint the interior of the rounded rectangle.</p> </dd></param>
        /// <remarks>
        /// <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>FillRoundedRectangle</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd371959</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::FillRoundedRectangle([In] const D2D1_ROUNDED_RECT* roundedRect,[In] ID2D1Brush* brush)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::FillRoundedRectangle</unmanaged-short>
        public unsafe void FillRoundedRectangle(ref SharpDX.Direct2D1.RoundedRectangle roundedRect, SharpDX.Direct2D1.Brush brush)
        {
            System.IntPtr brush_ = System.IntPtr.Zero;
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            fixed (void *roundedRect_ = &roundedRect)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, roundedRect_, (void *)brush_, (*(void ***)this._nativePointer)[19]);
        }

        /// <summary>
        /// <p>Draws the outline of the specified ellipse using the specified stroke style. </p>
        /// </summary>
        /// <param name = "ellipse"><dd>  <p>The position and radius of the ellipse to draw, in device-independent pixels.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush used to paint the ellipse's outline.</p> </dd></param>
        /// <param name = "strokeWidth"><dd>  <p>The width of the stroke, in device-independent pixels. The value must be greater than or equal to 0.0f. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</p> </dd></param>
        /// <param name = "strokeStyle"><dd>  <p>The style of stroke to apply to the ellipse's outline, or <strong><c>null</c></strong> to paint a solid stroke.</p> </dd></param>
        /// <remarks>
        /// <p>The <strong>DrawEllipse</strong> method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawEllipse</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd371886</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::DrawEllipse([In] const D2D1_ELLIPSE* ellipse,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::DrawEllipse</unmanaged-short>
        public unsafe void DrawEllipse(SharpDX.Direct2D1.Ellipse ellipse, SharpDX.Direct2D1.Brush brush, System.Single strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            System.IntPtr brush_ = System.IntPtr.Zero;
            System.IntPtr strokeStyle_ = System.IntPtr.Zero;
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            strokeStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.StrokeStyle>(strokeStyle);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &ellipse, (void *)brush_, strokeWidth, (void *)strokeStyle_, (*(void ***)this._nativePointer)[20]);
        }

        /// <summary>
        /// <p>Paints the interior of the specified ellipse. </p>
        /// </summary>
        /// <param name = "ellipse"><dd>  <p>The position and radius, in device-independent pixels, of the ellipse to paint.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush used to paint the interior of the ellipse.</p> </dd></param>
        /// <remarks>
        /// <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>FillEllipse</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd371928</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::FillEllipse([In] const D2D1_ELLIPSE* ellipse,[In] ID2D1Brush* brush)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::FillEllipse</unmanaged-short>
        public unsafe void FillEllipse(SharpDX.Direct2D1.Ellipse ellipse, SharpDX.Direct2D1.Brush brush)
        {
            System.IntPtr brush_ = System.IntPtr.Zero;
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &ellipse, (void *)brush_, (*(void ***)this._nativePointer)[21]);
        }

        /// <summary>
        /// <p>Draws the outline of the specified geometry using the specified stroke style. </p>
        /// </summary>
        /// <param name = "geometry"><dd>  <p>The geometry to draw.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush used to paint the geometry's stroke.</p> </dd></param>
        /// <param name = "strokeWidth"><dd>  <p>The width of the stroke, in device-independent pixels. The value must be greater than or equal to 0.0f. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</p> </dd></param>
        /// <param name = "strokeStyle"><dd>  <p>The style of stroke to apply to the geometry's outline, or <strong><c>null</c></strong> to paint a solid stroke.</p> </dd></param>
        /// <remarks>
        /// <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawGeometry</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd371890</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::DrawGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In] float strokeWidth,[In, Optional] ID2D1StrokeStyle* strokeStyle)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::DrawGeometry</unmanaged-short>
        public unsafe void DrawGeometry(SharpDX.Direct2D1.Geometry geometry, SharpDX.Direct2D1.Brush brush, System.Single strokeWidth, SharpDX.Direct2D1.StrokeStyle strokeStyle)
        {
            System.IntPtr geometry_ = System.IntPtr.Zero;
            System.IntPtr brush_ = System.IntPtr.Zero;
            System.IntPtr strokeStyle_ = System.IntPtr.Zero;
            geometry_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Geometry>(geometry);
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            strokeStyle_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.StrokeStyle>(strokeStyle);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)geometry_, (void *)brush_, strokeWidth, (void *)strokeStyle_, (*(void ***)this._nativePointer)[22]);
        }

        /// <summary>
        /// <p>Paints the interior of the specified geometry. </p>
        /// </summary>
        /// <param name = "geometry"><dd>  <p>The geometry to paint.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush used to paint the geometry's interior.</p> </dd></param>
        /// <param name = "opacityBrush"><dd>  <p>The opacity mask to apply to the geometry, or <strong><c>null</c></strong> for no opacity mask. If an opacity mask (the <em>opacityBrush</em> parameter) is specified, <em>brush</em> must be an <strong><see cref = "SharpDX.Direct2D1.BitmapBrush"/></strong> that has   its x- and y-extend modes set to <strong>D2D1_EXTEND_MODE_CLAMP</strong>. For more information, see the Remarks section. </p> </dd></param>
        /// <remarks>
        /// <p>If the <em>opacityBrush</em> parameter is not <strong><c>null</c></strong>, the alpha value of each pixel of the mapped <em>opacityBrush</em> is used to determine the resulting opacity of each corresponding pixel of the geometry. Only the alpha value of each color in the brush is used for this processing; all other color information is ignored.  The alpha value specified by the brush is multiplied by the alpha value of the geometry after the geometry has been painted by <em>brush</em>.  
        /// </p><p>When this method fails, it does not return an error code. To determine whether a drawing operation (such as <strong>FillGeometry</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> method. </p>
        /// </remarks>
        /// <doc-id>dd371933</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::FillGeometry([In] ID2D1Geometry* geometry,[In] ID2D1Brush* brush,[In, Optional] ID2D1Brush* opacityBrush)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::FillGeometry</unmanaged-short>
        public unsafe void FillGeometry(SharpDX.Direct2D1.Geometry geometry, SharpDX.Direct2D1.Brush brush, SharpDX.Direct2D1.Brush opacityBrush)
        {
            System.IntPtr geometry_ = System.IntPtr.Zero;
            System.IntPtr brush_ = System.IntPtr.Zero;
            System.IntPtr opacityBrush_ = System.IntPtr.Zero;
            geometry_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Geometry>(geometry);
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            opacityBrush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(opacityBrush);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)geometry_, (void *)brush_, (void *)opacityBrush_, (*(void ***)this._nativePointer)[23]);
        }

        /// <summary>
        /// <p> Paints the interior of the specified mesh.</p>
        /// </summary>
        /// <param name = "mesh"><dd>  <p>The mesh to paint.</p> </dd></param>
        /// <param name = "brush"><dd>  <p>The brush used to paint the mesh.</p> </dd></param>
        /// <remarks>
        /// <p>The current antialias mode of the render target must be <strong>D2D1_ANTIALIAS_MODE_ALIASED</strong> when <strong>FillMesh</strong> is called. To change the render target's antialias mode, use the <strong>SetAntialiasMode</strong> method.</p><p><strong>FillMesh</strong> does not expect a particular winding order for the triangles in the <strong><see cref = "SharpDX.Direct2D1.Mesh"/></strong>; both clockwise and counter-clockwise will work. </p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>FillMesh</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd371939</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::FillMesh([In] ID2D1Mesh* mesh,[In] ID2D1Brush* brush)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::FillMesh</unmanaged-short>
        public unsafe void FillMesh(SharpDX.Direct2D1.Mesh mesh, SharpDX.Direct2D1.Brush brush)
        {
            System.IntPtr mesh_ = System.IntPtr.Zero;
            System.IntPtr brush_ = System.IntPtr.Zero;
            mesh_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Mesh>(mesh);
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)mesh_, (void *)brush_, (*(void ***)this._nativePointer)[24]);
        }

        /// <summary>
        /// Applies the opacity mask described by the specified bitmap to a brush and uses that brush to paint a region of the render target.
        /// </summary>
        /// <param name = "opacityMask">No documentation.</param>
        /// <param name = "brush">No documentation.</param>
        /// <param name = "content">No documentation.</param>
        /// <param name = "destinationRectangle">No documentation.</param>
        /// <param name = "sourceRectangle">No documentation.</param>
        /// <remarks>
        /// <p>For this method to work properly, the render target must be using the <strong>D2D1_ANTIALIAS_MODE_ALIASED</strong> antialiasing mode. You can set the antialiasing mode by calling the <strong>ID2D1RenderTarget::SetAntialiasMode</strong> method.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>FillOpacityMask</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd742850</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::FillOpacityMask([In] ID2D1Bitmap* opacityMask,[In] ID2D1Brush* brush,[In] D2D1_OPACITY_MASK_CONTENT content,[In, Optional] const D2D_RECT_F* destinationRectangle,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::FillOpacityMask</unmanaged-short>
        public unsafe void FillOpacityMask(SharpDX.Direct2D1.Bitmap opacityMask, SharpDX.Direct2D1.Brush brush, SharpDX.Direct2D1.OpacityMaskContent content, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle)
        {
            System.IntPtr opacityMask_ = System.IntPtr.Zero;
            System.IntPtr brush_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangleF destinationRectangle_;
            SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle_;
            opacityMask_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Bitmap>(opacityMask);
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            if (destinationRectangle != null)
                destinationRectangle_ = destinationRectangle.Value;
            if (sourceRectangle != null)
                sourceRectangle_ = sourceRectangle.Value;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)opacityMask_, (void *)brush_, unchecked ((System.Int32)content), destinationRectangle == null ? (void *)0 : &destinationRectangle_, sourceRectangle == null ? (void *)0 : &sourceRectangle_, (*(void ***)this._nativePointer)[25]);
        }

        /// <summary>
        /// <p>Draws the specified bitmap after scaling it to the size of the specified rectangle. </p>
        /// </summary>
        /// <param name = "bitmap"><dd>  <p>The bitmap to render.</p> </dd></param>
        /// <param name = "destinationRectangle"><dd>  <p>The size and position, in device-independent pixels in the render target's coordinate space, of the area to which the bitmap is drawn. If the rectangle is not well-ordered, nothing is drawn, but the render target does not enter an error state.</p> </dd></param>
        /// <param name = "opacity"><dd>  <p>A value between 0.0f and 1.0f, inclusive, that specifies the opacity value to be applied to the bitmap; this value is multiplied against the alpha values of the bitmap's contents.  Default is 1.0f.</p> </dd></param>
        /// <param name = "interpolationMode"><dd>  <p>The interpolation mode to use if the bitmap is scaled or rotated by the drawing operation. The default value is <strong>D2D1_BITMAP_INTERPOLATION_MODE_LINEAR</strong>. </p> </dd></param>
        /// <param name = "sourceRectangle"><dd>  <p>The size and position, in device-independent pixels in the bitmap's coordinate space, of the area within the bitmap to draw; <strong><c>null</c></strong> to draw the entire bitmap.</p> </dd></param>
        /// <remarks>
        /// <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawBitmap</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd371878</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::DrawBitmap([In] ID2D1Bitmap* bitmap,[In, Optional] const D2D_RECT_F* destinationRectangle,[In] float opacity,[In] D2D1_BITMAP_INTERPOLATION_MODE interpolationMode,[In, Optional] const D2D_RECT_F* sourceRectangle)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::DrawBitmap</unmanaged-short>
        public unsafe void DrawBitmap(SharpDX.Direct2D1.Bitmap bitmap, SharpDX.Mathematics.Interop.RawRectangleF? destinationRectangle, System.Single opacity, SharpDX.Direct2D1.BitmapInterpolationMode interpolationMode, SharpDX.Mathematics.Interop.RawRectangleF? sourceRectangle)
        {
            System.IntPtr bitmap_ = System.IntPtr.Zero;
            SharpDX.Mathematics.Interop.RawRectangleF destinationRectangle_;
            SharpDX.Mathematics.Interop.RawRectangleF sourceRectangle_;
            bitmap_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Bitmap>(bitmap);
            if (destinationRectangle != null)
                destinationRectangle_ = destinationRectangle.Value;
            if (sourceRectangle != null)
                sourceRectangle_ = sourceRectangle.Value;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)bitmap_, destinationRectangle == null ? (void *)0 : &destinationRectangle_, opacity, unchecked ((System.Int32)interpolationMode), sourceRectangle == null ? (void *)0 : &sourceRectangle_, (*(void ***)this._nativePointer)[26]);
        }

        /// <summary>
        /// <p>Draws the specified text using the format information provided by an <strong><see cref = "SharpDX.DirectWrite.TextFormat"/></strong> object.</p>
        /// </summary>
        /// <param name = "text">No documentation.</param>
        /// <param name = "stringLength">No documentation.</param>
        /// <param name = "textFormat">No documentation.</param>
        /// <param name = "layoutRect">No documentation.</param>
        /// <param name = "defaultFillBrush">No documentation.</param>
        /// <param name = "options">No documentation.</param>
        /// <param name = "measuringMode">No documentation.</param>
        /// <remarks>
        /// <p>To create an <strong><see cref = "SharpDX.DirectWrite.TextFormat"/></strong> object, create an <strong><see cref = "SharpDX.DirectWrite.Factory"/></strong> and call its <strong>CreateTextFormat</strong> method.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawText</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd371919</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::DrawTextW([In, Buffer] const wchar_t* string,[In] unsigned int stringLength,[In] IDWriteTextFormat* textFormat,[In] const D2D_RECT_F* layoutRect,[In] ID2D1Brush* defaultFillBrush,[In] D2D1_DRAW_TEXT_OPTIONS options,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::DrawTextW</unmanaged-short>
        public unsafe void DrawText(System.String text, System.Int32 stringLength, SharpDX.DirectWrite.TextFormat textFormat, SharpDX.Mathematics.Interop.RawRectangleF layoutRect, SharpDX.Direct2D1.Brush defaultFillBrush, SharpDX.Direct2D1.DrawTextOptions options, SharpDX.Direct2D1.MeasuringMode measuringMode)
        {
            System.IntPtr textFormat_ = System.IntPtr.Zero;
            System.IntPtr defaultFillBrush_ = System.IntPtr.Zero;
            textFormat_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextFormat>(textFormat);
            defaultFillBrush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(defaultFillBrush);
            fixed (char *text_ = text)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)text_, stringLength, (void *)textFormat_, &layoutRect, (void *)defaultFillBrush_, unchecked ((System.Int32)options), unchecked ((System.Int32)measuringMode), (*(void ***)this._nativePointer)[27]);
        }

        /// <summary>
        /// <p>Draws the formatted text described by the specified <strong><see cref = "SharpDX.DirectWrite.TextLayout"/></strong> object.</p>
        /// </summary>
        /// <param name = "origin">No documentation.</param>
        /// <param name = "textLayout">No documentation.</param>
        /// <param name = "defaultFillBrush">No documentation.</param>
        /// <param name = "options">No documentation.</param>
        /// <remarks>
        /// <p>When drawing the same text repeatedly, using the <strong>DrawTextLayout</strong> method is more efficient than using the <strong>DrawText</strong> method because the text doesn't need to be formatted and the layout processed with each call.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawTextLayout</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd371913</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::DrawTextLayout([In] D2D_POINT_2F origin,[In] IDWriteTextLayout* textLayout,[In] ID2D1Brush* defaultFillBrush,[In] D2D1_DRAW_TEXT_OPTIONS options)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::DrawTextLayout</unmanaged-short>
        public unsafe void DrawTextLayout(SharpDX.Mathematics.Interop.RawVector2 origin, SharpDX.DirectWrite.TextLayout textLayout, SharpDX.Direct2D1.Brush defaultFillBrush, SharpDX.Direct2D1.DrawTextOptions options)
        {
            System.IntPtr textLayout_ = System.IntPtr.Zero;
            System.IntPtr defaultFillBrush_ = System.IntPtr.Zero;
            textLayout_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.TextLayout>(textLayout);
            defaultFillBrush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(defaultFillBrush);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, origin, (void *)textLayout_, (void *)defaultFillBrush_, unchecked ((System.Int32)options), (*(void ***)this._nativePointer)[28]);
        }

        /// <summary>
        /// <p>Draws the specified glyphs. </p>
        /// </summary>
        /// <param name = "baselineOrigin"><dd>  <p>The origin, in device-independent pixels, of the glyphs' baseline.</p> </dd></param>
        /// <param name = "glyphRun"><dd>  <p>The glyphs to render.</p> </dd></param>
        /// <param name = "foregroundBrush"><dd>  <p>The brush used to paint the specified glyphs.</p> </dd></param>
        /// <param name = "measuringMode"><dd>  <p>A value that indicates how glyph metrics are used to measure text when it is formatted.  The default value is <strong>DWRITE_MEASURING_MODE_NATURAL</strong>. </p> </dd></param>
        /// <remarks>
        /// <p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>DrawGlyphRun</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd371893</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::DrawGlyphRun([In] D2D_POINT_2F baselineOrigin,[In] const DWRITE_GLYPH_RUN* glyphRun,[In] ID2D1Brush* foregroundBrush,[In] DWRITE_MEASURING_MODE measuringMode)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::DrawGlyphRun</unmanaged-short>
        public unsafe void DrawGlyphRun(SharpDX.Mathematics.Interop.RawVector2 baselineOrigin, SharpDX.DirectWrite.GlyphRun glyphRun, SharpDX.Direct2D1.Brush foregroundBrush, SharpDX.Direct2D1.MeasuringMode measuringMode)
        {
            SharpDX.DirectWrite.GlyphRun.__Native glyphRun_ = default (SharpDX.DirectWrite.GlyphRun.__Native);
            System.IntPtr foregroundBrush_ = System.IntPtr.Zero;
            glyphRun.__MarshalTo(ref glyphRun_);
            foregroundBrush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(foregroundBrush);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, baselineOrigin, &glyphRun_, (void *)foregroundBrush_, unchecked ((System.Int32)measuringMode), (*(void ***)this._nativePointer)[29]);
            glyphRun.__MarshalFree(ref glyphRun_);
        }

        /// <summary>
        /// Applies the specified transform to the render target, replacing the existing transformation. All subsequent drawing operations occur in the transformed space.
        /// </summary>
        /// <param name = "transform">No documentation.</param>
        /// <doc-id>dd742857</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::SetTransform([In] const D2D_MATRIX_3X2_F* transform)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::SetTransform</unmanaged-short>
        internal unsafe void SetTransform(ref SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            fixed (void *transform_ = &transform)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, transform_, (*(void ***)this._nativePointer)[30]);
        }

        /// <summary>
        /// <p>Gets the current transform of the render target. </p>
        /// </summary>
        /// <param name = "transform"><dd>  <p>When this returns, contains the current transform of the render target. This parameter is passed uninitialized.</p> </dd></param>
        /// <doc-id>dd316845</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::GetTransform([Out] D2D_MATRIX_3X2_F* transform)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::GetTransform</unmanaged-short>
        internal unsafe void GetTransform(out SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            transform = default (SharpDX.Mathematics.Interop.RawMatrix3x2);
            fixed (void *transform_ = &transform)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, transform_, (*(void ***)this._nativePointer)[31]);
        }

        /// <summary>
        /// <p>Sets the antialiasing mode of the render target. The antialiasing mode applies to all subsequent drawing operations, excluding text and glyph drawing operations. </p>
        /// </summary>
        /// <param name = "antialiasMode"><dd>  <p>The antialiasing mode for future drawing operations. </p> </dd></param>
        /// <remarks>
        /// <p>To specify the antialiasing mode for text and glyph operations, use the <strong>SetTextAntialiasMode</strong> method. </p>
        /// </remarks>
        /// <doc-id>dd316881</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::SetAntialiasMode([In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::SetAntialiasMode</unmanaged-short>
        internal unsafe void SetAntialiasMode(SharpDX.Direct2D1.AntialiasMode antialiasMode)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)antialiasMode), (*(void ***)this._nativePointer)[32]);
        }

        /// <summary>
        /// <p> Retrieves the current antialiasing mode for nontext drawing operations.</p>
        /// </summary>
        /// <returns><p>The current antialiasing mode for nontext drawing operations. </p></returns>
        /// <doc-id>dd316805</doc-id>
        /// <unmanaged>D2D1_ANTIALIAS_MODE ID2D1RenderTarget::GetAntialiasMode()</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::GetAntialiasMode</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.AntialiasMode GetAntialiasMode()
        {
            SharpDX.Direct2D1.AntialiasMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1AntialiasMode(this._nativePointer, (*(void ***)this._nativePointer)[33]);
            return __result__;
        }

        /// <summary>
        /// <p>Specifies the antialiasing mode to use for subsequent text and glyph drawing operations. </p>
        /// </summary>
        /// <param name = "textAntialiasMode"><dd>  <p>The antialiasing mode to use for subsequent text and glyph drawing operations.</p> </dd></param>
        /// <doc-id>dd316897</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::SetTextAntialiasMode([In] D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::SetTextAntialiasMode</unmanaged-short>
        internal unsafe void SetTextAntialiasMode(SharpDX.Direct2D1.TextAntialiasMode textAntialiasMode)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)textAntialiasMode), (*(void ***)this._nativePointer)[34]);
        }

        /// <summary>
        /// <p>Gets the current antialiasing mode for text and glyph drawing operations. </p>
        /// </summary>
        /// <returns><p>The current antialiasing mode for text and glyph drawing operations. </p></returns>
        /// <doc-id>dd316835</doc-id>
        /// <unmanaged>D2D1_TEXT_ANTIALIAS_MODE ID2D1RenderTarget::GetTextAntialiasMode()</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::GetTextAntialiasMode</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.TextAntialiasMode GetTextAntialiasMode()
        {
            SharpDX.Direct2D1.TextAntialiasMode __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1TextAntialiasMode(this._nativePointer, (*(void ***)this._nativePointer)[35]);
            return __result__;
        }

        /// <summary>
        /// <p>Specifies text rendering options to be applied to all subsequent text and glyph drawing operations. </p>
        /// </summary>
        /// <param name = "textRenderingParams"><dd>  <p>The text rendering options to be applied to all subsequent text and glyph drawing operations; <strong><c>null</c></strong> to clear current text rendering options. </p> </dd></param>
        /// <remarks>
        /// <p>If the settings specified by  <em>textRenderingParams</em> are incompatible with the render target's text antialiasing mode (specified by <strong>SetTextAntialiasMode</strong>), subsequent text and glyph drawing operations will fail and put the render target into an error state.</p>
        /// </remarks>
        /// <doc-id>dd316898</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::SetTextRenderingParams([In, Optional] IDWriteRenderingParams* textRenderingParams)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::SetTextRenderingParams</unmanaged-short>
        internal unsafe void SetTextRenderingParams(SharpDX.DirectWrite.RenderingParams textRenderingParams)
        {
            System.IntPtr textRenderingParams_ = System.IntPtr.Zero;
            textRenderingParams_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.DirectWrite.RenderingParams>(textRenderingParams);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)textRenderingParams_, (*(void ***)this._nativePointer)[36]);
        }

        /// <summary>
        /// <p>Retrieves the render target's current text rendering options. </p>
        /// </summary>
        /// <param name = "textRenderingParams"><dd>  <p> When this method returns, <em>textRenderingParams</em>contains the address  of a reference to the render target's current text rendering options. </p> </dd></param>
        /// <remarks>
        /// <p>If the settings specified by  <em>textRenderingParams</em> are incompatible with the render target's text antialiasing mode (specified by <strong>SetTextAntialiasMode</strong>), subsequent text and glyph drawing operations will fail and put the render target into an error state.</p>
        /// </remarks>
        /// <doc-id>dd316841</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::GetTextRenderingParams([Out, Optional] IDWriteRenderingParams** textRenderingParams)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::GetTextRenderingParams</unmanaged-short>
        internal unsafe void GetTextRenderingParams(out SharpDX.DirectWrite.RenderingParams textRenderingParams)
        {
            System.IntPtr textRenderingParams_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &textRenderingParams_, (*(void ***)this._nativePointer)[37]);
            if (textRenderingParams_ != System.IntPtr.Zero)
                textRenderingParams = new SharpDX.DirectWrite.RenderingParams(textRenderingParams_);
            else
                textRenderingParams = null;
        }

        /// <summary>
        /// <p>Specifies a label for subsequent drawing operations.   </p>
        /// </summary>
        /// <param name = "tag1"><dd>  <p>A label to apply to subsequent drawing operations.</p> </dd></param>
        /// <param name = "tag2"><dd>  <p>A label to apply to subsequent drawing operations.</p> </dd></param>
        /// <remarks>
        /// <p>The labels specified by this method are printed by debug error messages. If no tag is set, the default value for each tag is 0.</p>
        /// </remarks>
        /// <doc-id>dd316892</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::SetTags([In] unsigned longlong tag1,[In] unsigned longlong tag2)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::SetTags</unmanaged-short>
        public unsafe void SetTags(System.Int64 tag1, System.Int64 tag2)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, tag1, tag2, (*(void ***)this._nativePointer)[38]);
        }

        /// <summary>
        /// <p>Gets the label for subsequent drawing operations. </p>
        /// </summary>
        /// <param name = "tag1"><dd>  <p>When this method returns, contains the first label for subsequent drawing operations. This parameter is passed uninitialized. If <strong><c>null</c></strong> is specified, no value is retrieved for this parameter. </p> </dd></param>
        /// <param name = "tag2"><dd>  <p>When this method returns, contains the second label for subsequent drawing operations. This parameter is passed uninitialized. If <strong><c>null</c></strong> is specified, no value is retrieved for this parameter.</p> </dd></param>
        /// <remarks>
        /// <p>If the same address is passed for both parameters, both parameters receive the value of the second tag. </p>
        /// </remarks>
        /// <doc-id>dd316830</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::GetTags([Out, Optional] unsigned longlong* tag1,[Out, Optional] unsigned longlong* tag2)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::GetTags</unmanaged-short>
        public unsafe void GetTags(out System.Int64 tag1, out System.Int64 tag2)
        {
            fixed (void *tag2_ = &tag2)
                fixed (void *tag1_ = &tag1)
                    SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, tag1_, tag2_, (*(void ***)this._nativePointer)[39]);
        }

        /// <summary>
        /// <p>Adds the specified layer to the render target so that it receives all subsequent drawing operations until <strong>PopLayer</strong> is called. </p>
        /// </summary>
        /// <param name = "layerParameters">No documentation.</param>
        /// <param name = "layer">No documentation.</param>
        /// <remarks>
        /// <p>The <strong>PushLayer</strong> method allows a caller to begin redirecting rendering to a layer. All rendering operations are valid in a layer. The location of the layer is affected by the world transform set on the render target. </p><p>Each <strong>PushLayer</strong> must have a matching <strong>PopLayer</strong> call. If there are more <strong>PopLayer</strong> calls than <strong>PushLayer</strong> calls, the render target is placed into an error state. If <strong>Flush</strong> is called before all outstanding layers are popped, the render target is placed into an error state, and an error is returned. The error state can be cleared by a call to <strong>EndDraw</strong>.</p><p>A particular <strong><see cref = "SharpDX.Direct2D1.Layer"/></strong> resource can be active only at one time. In other words, you cannot call a <strong>PushLayer</strong> method, and then immediately follow  with another <strong>PushLayer</strong> method with the same layer resource. Instead, you must call the second <strong>PushLayer</strong> method with different layer resources. 
        /// </p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>PushLayer</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd316869</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::PushLayer([In] const D2D1_LAYER_PARAMETERS* layerParameters,[In, Optional] ID2D1Layer* layer)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::PushLayer</unmanaged-short>
        public unsafe void PushLayer(ref SharpDX.Direct2D1.LayerParameters layerParameters, SharpDX.Direct2D1.Layer layer)
        {
            SharpDX.Direct2D1.LayerParameters.__Native layerParameters_ = default (SharpDX.Direct2D1.LayerParameters.__Native);
            System.IntPtr layer_ = System.IntPtr.Zero;
            layerParameters.__MarshalTo(ref layerParameters_);
            layer_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Layer>(layer);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &layerParameters_, (void *)layer_, (*(void ***)this._nativePointer)[40]);
            layerParameters.__MarshalFree(ref layerParameters_);
        }

        /// <summary>
        /// <p>Stops redirecting drawing operations to the layer that is specified by the last <strong>PushLayer</strong> call. </p>
        /// </summary>
        /// <remarks>
        /// <p>A <strong>PopLayer</strong> must match a previous <strong>PushLayer</strong> call.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>PopLayer</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd316852</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::PopLayer()</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::PopLayer</unmanaged-short>
        public unsafe void PopLayer()
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[41]);
        }

        /// <summary>
        /// <p>Executes all pending drawing commands. </p>
        /// </summary>
        /// <param name = "tag1"><dd>  <p>When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</p> </dd></param>
        /// <param name = "tag2"><dd>  <p>When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code and sets <em>tag1</em> and <em>tag2</em> to the tags that were active when the error occurred. If no error occurred, this method sets the error tag state to be (0,0).</p></returns>
        /// <remarks>
        /// <p>This command does not flush the Direct3D device context that is associated with the render target.</p><p>Calling this method resets the error state of the render target.</p>
        /// </remarks>
        /// <doc-id>dd316801</doc-id>
        /// <unmanaged>HRESULT ID2D1RenderTarget::Flush([Out, Optional] unsigned longlong* tag1,[Out, Optional] unsigned longlong* tag2)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::Flush</unmanaged-short>
        public unsafe void Flush(out System.Int64 tag1, out System.Int64 tag2)
        {
            SharpDX.Result __result__;
            fixed (void *tag2_ = &tag2)
                fixed (void *tag1_ = &tag1)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, tag1_, tag2_, (*(void ***)this._nativePointer)[42]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Saves the current drawing state to the specified <strong><see cref = "SharpDX.Direct2D1.DrawingStateBlock"/></strong>.</p>
        /// </summary>
        /// <param name = "drawingStateBlock">No documentation.</param>
        /// <doc-id>dd316876</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::SaveDrawingState([InOut] ID2D1DrawingStateBlock* drawingStateBlock)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::SaveDrawingState</unmanaged-short>
        public unsafe void SaveDrawingState(SharpDX.Direct2D1.DrawingStateBlock drawingStateBlock)
        {
            System.IntPtr drawingStateBlock_ = System.IntPtr.Zero;
            drawingStateBlock_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.DrawingStateBlock>(drawingStateBlock);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)drawingStateBlock_, (*(void ***)this._nativePointer)[43]);
        }

        /// <summary>
        /// <p>Sets the render target's drawing state to that of the specified <strong><see cref = "SharpDX.Direct2D1.DrawingStateBlock"/></strong>.</p>
        /// </summary>
        /// <param name = "drawingStateBlock">No documentation.</param>
        /// <doc-id>dd316872</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::RestoreDrawingState([In] ID2D1DrawingStateBlock* drawingStateBlock)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::RestoreDrawingState</unmanaged-short>
        public unsafe void RestoreDrawingState(SharpDX.Direct2D1.DrawingStateBlock drawingStateBlock)
        {
            System.IntPtr drawingStateBlock_ = System.IntPtr.Zero;
            drawingStateBlock_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.DrawingStateBlock>(drawingStateBlock);
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (void *)drawingStateBlock_, (*(void ***)this._nativePointer)[44]);
        }

        /// <summary>
        /// <p>Specifies a rectangle to which all subsequent drawing operations are clipped. </p>
        /// </summary>
        /// <param name = "clipRect"><dd>  <p>The size and position of the clipping area, in device-independent pixels.</p> </dd></param>
        /// <param name = "antialiasMode"><dd>  <p>The antialiasing mode that is used to draw the edges of clip rects that have subpixel boundaries, and to blend the clip with the scene contents. The blending is performed once when the <strong>PopAxisAlignedClip</strong> method is called, and does not apply to each primitive within the layer. </p> </dd></param>
        /// <remarks>
        /// <p>The <em>clipRect</em> is transformed by the current world transform set on the render target. After the transform is applied to the <em>clipRect</em> that is passed in, the axis-aligned bounding box for the <em>clipRect</em> is computed.  For efficiency, the contents are clipped to this axis-aligned bounding box and not to the original <em>clipRect</em> that is passed in. </p><p>The following diagrams show how a rotation transform is applied to the render target, the resulting <em>clipRect</em>, and  a calculated axis-aligned bounding box.</p><ol> <li> <p>Assume the rectangle in the following illustration is a render target that is aligned to the screen pixels.</p> <p></p> </li> <li> <p>Apply a rotation transform to the render target. In the following illustration, the black rectangle represents the original render target and the red dashed rectangle represents the transformed render target.</p> <p></p> </li> <li> <p>After calling <strong>PushAxisAlignedClip</strong>, the rotation transform is applied to the <em>clipRect</em>. In the following illustration, the blue rectangle represents the transformed <em>clipRect</em>.</p> <p></p> </li> <li> <p>The axis-aligned bounding box is calculated. The green dashed rectangle represents the bounding box in the following illustration. All contents are clipped to this axis-aligned bounding box.</p> <p></p> </li> </ol><strong>Note</strong>??If rendering operations fail or if <strong>PopAxisAlignedClip</strong> is not called, clip rects may cause some artifacts on the render target. <strong>PopAxisAlignedClip</strong> can be considered a drawing operation that is designed to fix the borders of a clipping region. Without this call, the borders of a clipped area may be not antialiased or otherwise corrected.?<p>The <strong>PushAxisAlignedClip</strong> and <strong>PopAxisAlignedClip</strong> must match. Otherwise, the error state is set. For the render target to continue receiving new commands, you can call <strong>Flush</strong> to clear the error. </p><p>A           <strong>PushAxisAlignedClip</strong> and <strong>PopAxisAlignedClip</strong> pair can occur around or within a PushLayer and PopLayer, but cannot overlap. For example, the sequence of <strong>PushAxisAlignedClip</strong>, <strong>PushLayer</strong>, <strong>PopLayer</strong>, <strong>PopAxisAlignedClip</strong> is valid, but the sequence of <strong>PushAxisAlignedClip</strong>, <strong>PushLayer</strong>, <strong>PopAxisAlignedClip</strong>, <strong>PopLayer</strong> is invalid.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>PushAxisAlignedClip</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd316860</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::PushAxisAlignedClip([In] const D2D_RECT_F* clipRect,[In] D2D1_ANTIALIAS_MODE antialiasMode)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::PushAxisAlignedClip</unmanaged-short>
        public unsafe void PushAxisAlignedClip(SharpDX.Mathematics.Interop.RawRectangleF clipRect, SharpDX.Direct2D1.AntialiasMode antialiasMode)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &clipRect, unchecked ((System.Int32)antialiasMode), (*(void ***)this._nativePointer)[45]);
        }

        /// <summary>
        /// <p>Removes the last axis-aligned clip from the render target. After this method is called, the clip is no longer applied to subsequent drawing operations. </p>
        /// </summary>
        /// <remarks>
        /// <p>A <strong>PushAxisAlignedClip</strong>/<strong>PopAxisAlignedClip</strong> pair can occur around or within a <strong>PushLayer</strong>/<strong>PopLayer</strong> pair, but may not overlap. For example, a <strong>PushAxisAlignedClip</strong>, <strong>PushLayer</strong>, <strong>PopLayer</strong>, <strong>PopAxisAlignedClip</strong> sequence is valid, but a <strong>PushAxisAlignedClip</strong>, <strong>PushLayer</strong>, <strong>PopAxisAlignedClip</strong>, <strong>PopLayer</strong> sequence is not. </p><p><strong>PopAxisAlignedClip</strong> must be called once for every call to <strong>PushAxisAlignedClip</strong>.</p><p>For an example, see How to Clip with an Axis-Aligned Clip Rectangle.</p><p>This method doesn't return an error code if it fails. To determine whether a drawing operation (such as <strong>PopAxisAlignedClip</strong>) failed, check the result returned by the <strong>ID2D1RenderTarget::EndDraw</strong> or <strong>ID2D1RenderTarget::Flush</strong> methods. </p>
        /// </remarks>
        /// <doc-id>dd316850</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::PopAxisAlignedClip()</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::PopAxisAlignedClip</unmanaged-short>
        public unsafe void PopAxisAlignedClip()
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[46]);
        }

        /// <summary>
        /// <p>Clears the drawing area to the specified color. </p>
        /// </summary>
        /// <param name = "clearColor"><dd>  <p>The color to which the drawing area is cleared, or <strong><c>null</c></strong> for transparent black.</p> </dd></param>
        /// <remarks>
        /// <p>Direct2D interprets the <em>clearColor</em> as straight alpha (not premultiplied).  If the render target's alpha mode is <strong>D2D1_ALPHA_MODE_IGNORE</strong>, the alpha channel of <em>clearColor</em> is ignored and replaced with 1.0f (fully opaque).</p><p>If the render target has an active clip (specified by <strong>PushAxisAlignedClip</strong>), the clear command is applied only to the area within the clip region.</p>
        /// </remarks>
        /// <doc-id>dd371769</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::Clear([In, Optional] const D2D_COLOR_F* clearColor)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::Clear</unmanaged-short>
        public unsafe void Clear(SharpDX.Mathematics.Interop.RawColor4? clearColor)
        {
            SharpDX.Mathematics.Interop.RawColor4 clearColor_;
            if (clearColor != null)
                clearColor_ = clearColor.Value;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, clearColor == null ? (void *)0 : &clearColor_, (*(void ***)this._nativePointer)[47]);
        }

        /// <summary>
        /// <p>Initiates drawing on this render target. </p>
        /// </summary>
        /// <remarks>
        /// <p>Drawing operations can only be issued between a <strong>BeginDraw</strong> and <strong>EndDraw</strong> call.</p><p>BeginDraw and EndDraw are used to indicate that a render target is in use by the Direct2D system. Different implementations of <strong><see cref = "SharpDX.Direct2D1.RenderTarget"/></strong> might behave differently when <strong>BeginDraw</strong> is called. An <strong><see cref = "SharpDX.Direct2D1.BitmapRenderTarget"/></strong> may be locked between <strong>BeginDraw</strong>/<strong>EndDraw</strong> calls, a DXGI surface render target might be acquired on <strong>BeginDraw</strong> and released on <strong>EndDraw</strong>, while an <strong><see cref = "SharpDX.Direct2D1.WindowRenderTarget"/></strong> may begin batching at <strong>BeginDraw</strong> and may present on <strong>EndDraw</strong>, for example.</p><p> The BeginDraw method must be called before rendering operations can be called, though state-setting and state-retrieval operations can be performed even outside of <strong>BeginDraw</strong>/<strong>EndDraw</strong>. </p><p>After <strong>BeginDraw</strong> is called, a render target will normally build up a batch of rendering commands, but defer processing of these commands until either an internal buffer is full, the <strong>Flush</strong> method is called, or until <strong>EndDraw</strong> is called. The <strong>EndDraw</strong> method causes any batched drawing operations to complete, and then returns an <see cref = "SharpDX.Result"/> indicating the success of the operations and, optionally, the tag state of the render target at the time the error occurred. The <strong>EndDraw</strong> method always succeeds: it should not be called twice even if a previous <strong>EndDraw</strong> resulted in a failing <see cref = "SharpDX.Result"/>. </p><p>If <strong>EndDraw</strong> is called without a matched call to <strong>BeginDraw</strong>, it returns an error indicating that <strong>BeginDraw</strong> must be called before <strong>EndDraw</strong>. Calling <strong>BeginDraw</strong> twice on a render target puts the target into an error state where nothing further is drawn, and returns an appropriate <see cref = "SharpDX.Result"/> and error information when <strong>EndDraw</strong> is called.
        /// </p>
        /// </remarks>
        /// <doc-id>dd371768</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::BeginDraw()</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::BeginDraw</unmanaged-short>
        public unsafe void BeginDraw()
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[48]);
        }

        /// <summary>
        /// <p>Ends drawing operations  on the render target and indicates the current error state and associated tags. </p>
        /// </summary>
        /// <param name = "tag1"><dd>  <p>When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</p> </dd></param>
        /// <param name = "tag2"><dd>  <p>When this method returns, contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code and sets <em>tag1</em> and <em>tag2</em> to the tags that were active when the error occurred. </p></returns>
        /// <remarks>
        /// <p>Drawing operations can only be issued between a <strong>BeginDraw</strong> and <strong>EndDraw</strong> call.</p><p> <strong>BeginDraw</strong> and <strong>EndDraw</strong> are use to indicate that a render target is in use by the Direct2D system. Different implementations of <strong><see cref = "SharpDX.Direct2D1.RenderTarget"/></strong> might behave differently when <strong>BeginDraw</strong> is called. An <strong><see cref = "SharpDX.Direct2D1.BitmapRenderTarget"/></strong> may be locked between <strong>BeginDraw</strong>/<strong>EndDraw</strong> calls, a DXGI surface render target might be acquired on <strong>BeginDraw</strong> and released on <strong>EndDraw</strong>, while an <strong><see cref = "SharpDX.Direct2D1.WindowRenderTarget"/></strong> may begin batching at <strong>BeginDraw</strong> and may present on <strong>EndDraw</strong>, for example.</p><p> The <strong>BeginDraw</strong> method must be called before rendering operations can be called, though state-setting and state-retrieval operations can be performed even outside of <strong>BeginDraw</strong>/<strong>EndDraw</strong>. </p><p>After <strong>BeginDraw</strong> is called, a render target will normally build up a batch of rendering commands, but defer processing of these commands until either an internal buffer is full, the <strong>Flush</strong> method is called, or until <strong>EndDraw</strong> is called. The <strong>EndDraw</strong> method causes any batched drawing operations to complete, and then returns an <strong><see cref = "SharpDX.Result"/></strong> indicating the success of the operations and, optionally, the tag state of the render target at the time the error occurred. The <strong>EndDraw</strong> method always succeeds: it should not be called twice even if a previous <strong>EndDraw</strong> resulted in a failing <strong><see cref = "SharpDX.Result"/></strong>. </p><p>If <strong>EndDraw</strong> is called without a matched call to <strong>BeginDraw</strong>, it returns an error indicating that <strong>BeginDraw</strong> must be called before <strong>EndDraw</strong>. Calling <strong>BeginDraw</strong> twice on a render target puts the target into an error state where nothing further is drawn, and returns an appropriate <strong><see cref = "SharpDX.Result"/></strong> and error information when <strong>EndDraw</strong> is called.
        /// </p>
        /// </remarks>
        /// <doc-id>dd371924</doc-id>
        /// <unmanaged>HRESULT ID2D1RenderTarget::EndDraw([Out, Optional] unsigned longlong* tag1,[Out, Optional] unsigned longlong* tag2)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::EndDraw</unmanaged-short>
        public unsafe SharpDX.Result TryEndDraw(out System.Int64 tag1, out System.Int64 tag2)
        {
            SharpDX.Result __result__;
            fixed (void *tag2_ = &tag2)
                fixed (void *tag1_ = &tag1)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, tag1_, tag2_, (*(void ***)this._nativePointer)[49]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves the pixel format and alpha mode of the render target. </p>
        /// </summary>
        /// <returns><p>The pixel format and alpha mode of the render target.</p></returns>
        /// <doc-id>dd316814</doc-id>
        /// <unmanaged>D2D1_PIXEL_FORMAT ID2D1RenderTarget::GetPixelFormat()</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::GetPixelFormat</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.PixelFormat GetPixelFormat()
        {
            SharpDX.Direct2D1.PixelFormat __result__;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[50]);
            return __result__;
        }

        /// <summary>
        /// <p>Sets the dots per inch (DPI) of the render target. </p>
        /// </summary>
        /// <param name = "dpiX"><dd>  <p>A value greater than or equal to zero that specifies the horizontal DPI of the render target.</p> </dd></param>
        /// <param name = "dpiY"><dd>  <p>A value greater than or equal to zero that specifies the vertical DPI of the render target.</p> </dd></param>
        /// <remarks>
        /// <p>This method specifies the mapping from pixel space to device-independent space  for the render target.  If both <em>dpiX</em> and <em>dpiY</em> are 0, the factory-read system DPI is chosen. If one parameter is zero and the other unspecified, the DPI is not changed.</p><p>For <strong><see cref = "SharpDX.Direct2D1.WindowRenderTarget"/></strong>, the DPI defaults to the most recently factory-read system DPI. The default value for all other render targets is 96 DPI.  </p>
        /// </remarks>
        /// <doc-id>dd316887</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::SetDpi([In] float dpiX,[In] float dpiY)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::SetDpi</unmanaged-short>
        internal unsafe void SetDpi(System.Single dpiX, System.Single dpiY)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, dpiX, dpiY, (*(void ***)this._nativePointer)[51]);
        }

        /// <summary>
        /// <p>Return the render target's dots per inch (DPI).</p>
        /// </summary>
        /// <param name = "dpiX"><dd>  <p>When this method returns, contains the horizontal DPI of the render target. This parameter is passed uninitialized.</p> </dd></param>
        /// <param name = "dpiY"><dd>  <p>When this method returns, contains the vertical DPI of the render target. This parameter is passed uninitialized.</p> </dd></param>
        /// <remarks>
        /// <p>This method indicates the mapping from pixel space to device-independent space  for the render target.  </p><p>For <strong><see cref = "SharpDX.Direct2D1.WindowRenderTarget"/></strong>, the DPI defaults to the most recently factory-read system DPI. The default value for all other render targets is 96 DPI.  </p>
        /// </remarks>
        /// <doc-id>dd316809</doc-id>
        /// <unmanaged>void ID2D1RenderTarget::GetDpi([Out] float* dpiX,[Out] float* dpiY)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::GetDpi</unmanaged-short>
        internal unsafe void GetDpi(out System.Single dpiX, out System.Single dpiY)
        {
            fixed (void *dpiY_ = &dpiY)
                fixed (void *dpiX_ = &dpiX)
                    SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, dpiX_, dpiY_, (*(void ***)this._nativePointer)[52]);
        }

        /// <summary>
        /// <p>Returns the size of the render target in device-independent pixels.</p>
        /// </summary>
        /// <returns><p>The current size of the render target in device-independent pixels.</p></returns>
        /// <doc-id>dd316823</doc-id>
        /// <unmanaged>D2D_SIZE_F ID2D1RenderTarget::GetSize()</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::GetSize</unmanaged-short>
        internal unsafe SharpDX.Size2F GetSize()
        {
            SharpDX.Size2F __result__;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[53]);
            return __result__;
        }

        /// <summary>
        /// <p>Returns the size of the render target in device pixels.</p>
        /// </summary>
        /// <returns><p>The size of the render target in device pixels.</p></returns>
        /// <doc-id>dd316820</doc-id>
        /// <unmanaged>D2D_SIZE_U ID2D1RenderTarget::GetPixelSize()</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::GetPixelSize</unmanaged-short>
        internal unsafe SharpDX.Size2 GetPixelSize()
        {
            SharpDX.Size2 __result__;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[54]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets the maximum size, in device-dependent units (pixels), of  any one bitmap dimension supported by the render target.</p>
        /// </summary>
        /// <returns><p> The maximum size, in pixels, of  any one bitmap dimension supported by the render target.</p></returns>
        /// <remarks>
        /// <p>This method returns the maximum texture size of the Direct3D device.</p><strong>Note</strong>??The software renderer and WARP devices return the value of 16 megapixels (16*1024*1024).  You can create a Direct2D texture that is this size, but not a Direct3D texture that is this size.?
        /// </remarks>
        /// <doc-id>dd742853</doc-id>
        /// <unmanaged>unsigned int ID2D1RenderTarget::GetMaximumBitmapSize()</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::GetMaximumBitmapSize</unmanaged-short>
        internal unsafe System.Int32 GetMaximumBitmapSize()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[55]);
            return __result__;
        }

        /// <summary>
        /// <p>Indicates whether the render target supports the specified properties.</p>
        /// </summary>
        /// <param name = "renderTargetProperties"><dd>  <p>The render target properties to test.</p> </dd></param>
        /// <returns><p><strong>TRUE</strong> if the specified render target properties are supported by this render target; otherwise, <strong><see cref = "SharpDX.Result.False"/></strong>.</p></returns>
        /// <remarks>
        /// <p>This method does not evaluate the DPI settings specified by the <em>renderTargetProperties</em> parameter.</p>
        /// </remarks>
        /// <doc-id>dd742854</doc-id>
        /// <unmanaged>BOOL ID2D1RenderTarget::IsSupported([In] const D2D1_RENDER_TARGET_PROPERTIES* renderTargetProperties)</unmanaged>
        /// <unmanaged-short>ID2D1RenderTarget::IsSupported</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool IsSupported(ref SharpDX.Direct2D1.RenderTargetProperties renderTargetProperties)
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            fixed (void *renderTargetProperties_ = &renderTargetProperties)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, renderTargetProperties_, (*(void ***)this._nativePointer)[56]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd90691-12e2-11dc-9fed-001143a055f9")]
    public partial class Resource : SharpDX.ComObject
    {
        public Resource(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator Resource(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new Resource(nativePtr);
        /// <summary>
        /// <p>Retrieves the factory associated with this resource.</p>
        /// </summary>
        /// <doc-id>dd316911</doc-id>
        /// <unmanaged>GetFactory</unmanaged>
        /// <unmanaged-short>GetFactory</unmanaged-short>
        public SharpDX.Direct2D1.Factory Factory
        {
            get
            {
                GetFactory(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves the factory associated with this resource.</p>
        /// </summary>
        /// <param name = "factory"><dd>  <p>When this method returns, contains a reference to a reference to the factory that created this resource. This parameter is passed uninitialized.</p> </dd></param>
        /// <doc-id>dd316911</doc-id>
        /// <unmanaged>void ID2D1Resource::GetFactory([Out] ID2D1Factory** factory)</unmanaged>
        /// <unmanaged-short>ID2D1Resource::GetFactory</unmanaged-short>
        internal unsafe void GetFactory(out SharpDX.Direct2D1.Factory factory)
        {
            System.IntPtr factory_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &factory_, (*(void ***)this._nativePointer)[3]);
            if (factory_ != System.IntPtr.Zero)
                factory = new SharpDX.Direct2D1.Factory(factory_);
            else
                factory = null;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("688d15c3-02b0-438d-b13a-d1b44c32c39a")]
    public partial class ResourceTexture : SharpDX.ComObject
    {
        public ResourceTexture(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator ResourceTexture(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new ResourceTexture(nativePtr);
        /// <summary>
        /// <p>Updates the specific resource texture inside the specific range or box using the supplied data.</p>
        /// </summary>
        /// <param name = "minimumExtents"><dd>  <p>The "left" extent of the updates if specified; if <strong><c>null</c></strong>, the entire texture is updated.</p> </dd></param>
        /// <param name = "maximimumExtents"><dd>  <p>The "right" extent of the updates if specified; if <strong><c>null</c></strong>, the entire texture is updated.</p> </dd></param>
        /// <param name = "strides"><dd>  <p>The stride to advance through the input data, according to dimension.</p> </dd></param>
        /// <param name = "dimensions"><dd>  <p>The number of dimensions in the resource texture. This must match the number used to load the texture.</p> </dd></param>
        /// <param name = "data"><dd>  <p>The data to be placed into the resource texture.</p> </dd></param>
        /// <param name = "dataCount"><dd>  <p>The size of the data buffer to be used to update the resource texture.</p> </dd></param>
        /// <returns><p>The method returns an <see cref = "SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td> E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The number of dimensions in the update must match those of the created texture.</p>
        /// </remarks>
        /// <doc-id>hh446906</doc-id>
        /// <unmanaged>HRESULT ID2D1ResourceTexture::Update([In, Buffer, Optional] const unsigned int* minimumExtents,[In, Buffer, Optional] const unsigned int* maximimumExtents,[In, Buffer, Optional] const unsigned int* strides,[In] unsigned int dimensions,[In, Buffer] const unsigned char* data,[In] unsigned int dataCount)</unmanaged>
        /// <unmanaged-short>ID2D1ResourceTexture::Update</unmanaged-short>
        public unsafe void Update(System.Int32[] minimumExtents, System.Int32[] maximimumExtents, System.Int32[] strides, System.Int32 dimensions, System.Byte[] data, System.Int32 dataCount)
        {
            SharpDX.Result __result__;
            fixed (void *data_ = data)
                fixed (void *strides_ = strides)
                    fixed (void *maximimumExtents_ = maximimumExtents)
                        fixed (void *minimumExtents_ = minimumExtents)
                            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, minimumExtents_, maximimumExtents_, strides_, dimensions, data_, dataCount, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd906a3-12e2-11dc-9fed-001143a055f9")]
    public partial class RoundedRectangleGeometry : SharpDX.Direct2D1.Geometry
    {
        public RoundedRectangleGeometry(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator RoundedRectangleGeometry(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new RoundedRectangleGeometry(nativePtr);
        /// <summary>
        /// <p>Retrieves a rounded rectangle that describes this rounded rectangle geometry. </p>
        /// </summary>
        /// <doc-id>dd316917</doc-id>
        /// <unmanaged>GetRoundedRect</unmanaged>
        /// <unmanaged-short>GetRoundedRect</unmanaged-short>
        public SharpDX.Direct2D1.RoundedRectangle RoundedRect
        {
            get
            {
                GetRoundedRect(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves a rounded rectangle that describes this rounded rectangle geometry. </p>
        /// </summary>
        /// <param name = "roundedRect"><dd>  <p>A reference that receives a rounded rectangle that describes this rounded rectangle geometry. You must allocate storage for this parameter. </p> </dd></param>
        /// <doc-id>dd316917</doc-id>
        /// <unmanaged>void ID2D1RoundedRectangleGeometry::GetRoundedRect([Out] D2D1_ROUNDED_RECT* roundedRect)</unmanaged>
        /// <unmanaged-short>ID2D1RoundedRectangleGeometry::GetRoundedRect</unmanaged-short>
        internal unsafe void GetRoundedRect(out SharpDX.Direct2D1.RoundedRectangle roundedRect)
        {
            roundedRect = default (SharpDX.Direct2D1.RoundedRectangle);
            fixed (void *roundedRect_ = &roundedRect)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, roundedRect_, (*(void ***)this._nativePointer)[17]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd9069e-12e2-11dc-9fed-001143a055f9")]
    public partial interface SimplifiedGeometrySink : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd9069e-12e2-11dc-9fed-001143a055f9")]
    internal partial class SimplifiedGeometrySinkNative : SharpDX.ComObject, SharpDX.Direct2D1.SimplifiedGeometrySink
    {
        public SimplifiedGeometrySinkNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SimplifiedGeometrySinkNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SimplifiedGeometrySinkNative(nativePtr);
        /// <summary>
        /// <p>Specifies the method used to determine which points are inside the geometry described by this geometry sink  and which points are outside.  </p>
        /// </summary>
        /// <remarks>
        /// <p>The fill mode defaults to D2D1_FILL_MODE_ALTERNATE. To set the fill mode, call <strong>SetFillMode</strong> before the first call to <strong>BeginFigure</strong>. Not doing will put the geometry sink in an error state. </p>
        /// </remarks>
        /// <doc-id>dd316937</doc-id>
        /// <unmanaged>SetFillMode</unmanaged>
        /// <unmanaged-short>SetFillMode</unmanaged-short>
        public SharpDX.Direct2D1.FillMode FillMode_
        {
            set => SetFillMode_(value);
        }

        /// <summary>
        /// <p>Specifies stroke and join options to be applied to new segments added to the geometry sink. </p>
        /// </summary>
        /// <remarks>
        /// <p>After this method is called, the specified segment flags are applied to each segment subsequently added to the sink. The segment flags are applied to every additional segment until this method is called again and a different set of segment flags is specified.     </p>
        /// </remarks>
        /// <doc-id>dd316939</doc-id>
        /// <unmanaged>SetSegmentFlags</unmanaged>
        /// <unmanaged-short>SetSegmentFlags</unmanaged-short>
        public SharpDX.Direct2D1.PathSegment SegmentFlags_
        {
            set => SetSegmentFlags_(value);
        }

        /// <summary>
        /// <p>Specifies the method used to determine which points are inside the geometry described by this geometry sink  and which points are outside.  </p>
        /// </summary>
        /// <param name = "fillMode"><dd>  <p>The method used to determine whether a given point is part of the geometry.</p> </dd></param>
        /// <remarks>
        /// <p>The fill mode defaults to D2D1_FILL_MODE_ALTERNATE. To set the fill mode, call <strong>SetFillMode</strong> before the first call to <strong>BeginFigure</strong>. Not doing will put the geometry sink in an error state. </p>
        /// </remarks>
        /// <doc-id>dd316937</doc-id>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::SetFillMode([In] D2D1_FILL_MODE fillMode)</unmanaged>
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::SetFillMode</unmanaged-short>
        internal unsafe void SetFillMode_(SharpDX.Direct2D1.FillMode fillMode)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)fillMode), (*(void ***)this._nativePointer)[3]);
        }

        /// <summary>
        /// <p>Specifies stroke and join options to be applied to new segments added to the geometry sink. </p>
        /// </summary>
        /// <param name = "vertexFlags"><dd>  <p>Stroke and join options to be applied to new segments added to the geometry sink.</p> </dd></param>
        /// <remarks>
        /// <p>After this method is called, the specified segment flags are applied to each segment subsequently added to the sink. The segment flags are applied to every additional segment until this method is called again and a different set of segment flags is specified.     </p>
        /// </remarks>
        /// <doc-id>dd316939</doc-id>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::SetSegmentFlags([In] D2D1_PATH_SEGMENT vertexFlags)</unmanaged>
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::SetSegmentFlags</unmanaged-short>
        internal unsafe void SetSegmentFlags_(SharpDX.Direct2D1.PathSegment vertexFlags)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)vertexFlags), (*(void ***)this._nativePointer)[4]);
        }

        /// <summary>
        /// <p>Starts a new figure at the specified point. </p>
        /// </summary>
        /// <param name = "startPoint"><dd>  <p>The point at which to begin the new figure.</p> </dd></param>
        /// <param name = "figureBegin"><dd>  <p>Whether the new figure should be hollow or filled.</p> </dd></param>
        /// <remarks>
        /// <p>If this method is called while a figure is currently in progress, the interface is invalidated and all future methods will fail.</p>
        /// </remarks>
        /// <doc-id>dd316929</doc-id>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::BeginFigure([In] D2D_POINT_2F startPoint,[In] D2D1_FIGURE_BEGIN figureBegin)</unmanaged>
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::BeginFigure</unmanaged-short>
        internal unsafe void BeginFigure_(SharpDX.Mathematics.Interop.RawVector2 startPoint, SharpDX.Direct2D1.FigureBegin figureBegin)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid0(this._nativePointer, startPoint, unchecked ((System.Int32)figureBegin), (*(void ***)this._nativePointer)[5]);
        }

        /// <summary>
        /// <p> Creates a sequence of lines using the specified points and adds them to the geometry sink.</p>
        /// </summary>
        /// <param name = "ointsRef"><dd>  <p>A reference to an array of one or more points that describe the lines to draw. A line is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by <strong>BeginFigure</strong>) to the first point in the array. if the array contains additional points, a line is drawn from the first point to the second point in the array, from the second point to the third point, and so on.   </p> </dd></param>
        /// <param name = "pointsCount"><dd>  <p>The number of points in the <em>points</em> array.</p> </dd></param>
        /// <doc-id>dd316925</doc-id>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::AddLines([In, Buffer] const D2D_POINT_2F* points,[In] unsigned int pointsCount)</unmanaged>
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::AddLines</unmanaged-short>
        internal unsafe void AddLines_(SharpDX.Mathematics.Interop.RawVector2[] ointsRef, System.Int32 pointsCount)
        {
            fixed (void *ointsRef_ = ointsRef)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, ointsRef_, pointsCount, (*(void ***)this._nativePointer)[6]);
        }

        /// <summary>
        /// <p>Creates a sequence of cubic Bezier curves and adds them to the geometry sink. </p>
        /// </summary>
        /// <param name = "beziers"><dd>  <p>A reference to an array of Bezier segments that describes the Bezier curves to create. A curve is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by <strong>BeginFigure</strong>) to the end point of the first Bezier segment in the array. if the array contains additional Bezier segments, each subsequent Bezier segment uses the end point of the preceding Bezier segment as its start point.</p> </dd></param>
        /// <param name = "beziersCount"><dd>  <p>The number of Bezier segments in the <em>beziers</em> array.</p> </dd></param>
        /// <doc-id>dd316922</doc-id>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::AddBeziers([In, Buffer] const D2D1_BEZIER_SEGMENT* beziers,[In] unsigned int beziersCount)</unmanaged>
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::AddBeziers</unmanaged-short>
        internal unsafe void AddBeziers_(SharpDX.Direct2D1.BezierSegment[] beziers, System.Int32 beziersCount)
        {
            fixed (void *beziers_ = beziers)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, beziers_, beziersCount, (*(void ***)this._nativePointer)[7]);
        }

        /// <summary>
        /// <p> Ends the current figure; optionally, closes it.</p>
        /// </summary>
        /// <param name = "figureEnd"><dd>  <p>A value that indicates whether the current figure is closed. If the figure is closed, a line is drawn between the current point and the start point specified by <strong>BeginFigure</strong>.</p> </dd></param>
        /// <remarks>
        /// <p>Calling this method without a matching call to <strong>BeginFigure</strong> places the geometry sink in an error state; subsequent calls are ignored, and the overall failure will be returned when the <strong>Close</strong> method is called.</p>
        /// </remarks>
        /// <doc-id>dd316934</doc-id>
        /// <unmanaged>void ID2D1SimplifiedGeometrySink::EndFigure([In] D2D1_FIGURE_END figureEnd)</unmanaged>
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::EndFigure</unmanaged-short>
        internal unsafe void EndFigure_(SharpDX.Direct2D1.FigureEnd figureEnd)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, unchecked ((System.Int32)figureEnd), (*(void ***)this._nativePointer)[8]);
        }

        /// <summary>
        /// <p>Closes the geometry sink, indicates whether it is in an error state, and resets the sink's error state. </p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Do not close the geometry sink while a figure is still in progress; doing so puts the geometry sink in an error state. For the close operation to be successful, there must be one <strong>EndFigure</strong> call for each call to <strong>BeginFigure</strong>.</p><p>After calling this method, the geometry sink might not be usable. Direct2D implementations of this interface do not allow the geometry sink to be modified after it is closed, but other implementations might not impose this restriction.</p>
        /// </remarks>
        /// <doc-id>dd316932</doc-id>
        /// <unmanaged>HRESULT ID2D1SimplifiedGeometrySink::Close()</unmanaged>
        /// <unmanaged-short>ID2D1SimplifiedGeometrySink::Close</unmanaged-short>
        internal unsafe void Close_()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd906a9-12e2-11dc-9fed-001143a055f9")]
    public partial class SolidColorBrush : SharpDX.Direct2D1.Brush
    {
        public SolidColorBrush(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SolidColorBrush(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SolidColorBrush(nativePtr);
        /// <summary>
        /// <p>Retrieves or sets the color of the solid color brush.</p>
        /// </summary>
        /// <doc-id>dd372209</doc-id>
        /// <unmanaged>GetColor / SetColor</unmanaged>
        /// <unmanaged-short>GetColor</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawColor4 Color
        {
            get => GetColor();
            set => SetColor(value);
        }

        /// <summary>
        /// <p>Specifies the color of this solid color brush. </p>
        /// </summary>
        /// <param name = "color"><dd>  <p>The color of this solid color brush.</p> </dd></param>
        /// <remarks>
        /// <p>To help create colors, Direct2D provides the <strong>ColorF</strong> class. It offers several helper methods for creating colors and provides a set or predefined colors. </p>
        /// </remarks>
        /// <doc-id>dd372211</doc-id>
        /// <unmanaged>void ID2D1SolidColorBrush::SetColor([In] const D2D_COLOR_F* color)</unmanaged>
        /// <unmanaged-short>ID2D1SolidColorBrush::SetColor</unmanaged-short>
        internal unsafe void SetColor(SharpDX.Mathematics.Interop.RawColor4 color)
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &color, (*(void ***)this._nativePointer)[8]);
        }

        /// <summary>
        /// <p> Retrieves the color of the solid color brush.</p>
        /// </summary>
        /// <returns><p>The color of this solid color brush.</p></returns>
        /// <doc-id>dd372209</doc-id>
        /// <unmanaged>D2D_COLOR_F ID2D1SolidColorBrush::GetColor()</unmanaged>
        /// <unmanaged-short>ID2D1SolidColorBrush::GetColor</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawColor4 GetColor()
        {
            SharpDX.Mathematics.Interop.RawColor4 __result__;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("db1800dd-0c34-4cf9-be90-31cc0a5653e1")]
    public partial interface SourceTransform : SharpDX.Direct2D1.Transform
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("db1800dd-0c34-4cf9-be90-31cc0a5653e1")]
    public partial class SourceTransformNative : SharpDX.Direct2D1.TransformNative, SharpDX.Direct2D1.SourceTransform
    {
        public SourceTransformNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SourceTransformNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SourceTransformNative(nativePtr);
        /// <summary>
        /// <p>Sets the render information for the transform.</p>
        /// </summary>
        /// <remarks>
        /// <p>Provides a render information interface to the source transform to allow it to specify state to the rendering system.</p>
        /// </remarks>
        /// <doc-id>hh446912</doc-id>
        /// <unmanaged>SetRenderInfo</unmanaged>
        /// <unmanaged-short>SetRenderInfo</unmanaged-short>
        public SharpDX.Direct2D1.RenderInformation RenderInfo_
        {
            set => SetRenderInfo_(value);
        }

        /// <summary>
        /// <p>Sets the render information for the transform.</p>
        /// </summary>
        /// <param name = "renderInfo"><dd>  <p>The interface supplied to the transform to allow specifying the CPU based transform pass.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>Provides a render information interface to the source transform to allow it to specify state to the rendering system.</p>
        /// </remarks>
        /// <doc-id>hh446912</doc-id>
        /// <unmanaged>HRESULT ID2D1SourceTransform::SetRenderInfo([In] ID2D1RenderInfo* renderInfo)</unmanaged>
        /// <unmanaged-short>ID2D1SourceTransform::SetRenderInfo</unmanaged-short>
        internal unsafe void SetRenderInfo_(SharpDX.Direct2D1.RenderInformation renderInfo)
        {
            System.IntPtr renderInfo_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            renderInfo_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.RenderInformation>(renderInfo);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)renderInfo_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Draws the transform to the graphics processing unit (GPU)?based Direct2D pipeline.</p>
        /// </summary>
        /// <param name = "target"><dd>  <p>The target to which the transform should be written.</p> </dd></param>
        /// <param name = "drawRect"><dd>  <p>The area within the source from which the image should be drawn.</p> </dd></param>
        /// <param name = "targetOrigin"><dd>  <p>The origin within the target bitmap to which the source data should be drawn.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The implementation of the rasterizer guarantees that adding the <em>renderRect</em> to the <em>targetOrigin</em> does not exceed the bounds of the bitmap.</p><p>When implementing this method you must update the bitmap in this way: </p><ol> <li>Call the <strong>ID2D1Bitmap::Map</strong> method with the  D2D1_MAP_OPTIONS_DISCARD and D2D1_MAP_OPTIONS_WRITE
        /// flags.</li> <li>Update the buffer this method returns.</li> <li>Call the <strong>ID2D1Bitmap::Unmap</strong> method.</li> </ol><p>If you  set the buffer precision manually on the associated <strong><see cref = "SharpDX.Direct2D1.RenderInformation"/></strong> object, it must handle different pixel formats in this method by calling <strong>ID2D1Bitmap::GetPixelFormat</strong>.  If you set the buffer precision manually, then you can rely on that format always being the one you provided.</p>
        /// </remarks>
        /// <doc-id>hh446910</doc-id>
        /// <unmanaged>HRESULT ID2D1SourceTransform::Draw([In] ID2D1Bitmap1* target,[In] const RECT* drawRect,[In] D2D_POINT_2U targetOrigin)</unmanaged>
        /// <unmanaged-short>ID2D1SourceTransform::Draw</unmanaged-short>
        internal unsafe void Draw_(SharpDX.Direct2D1.Bitmap1 target, SharpDX.Mathematics.Interop.RawRectangle drawRect, SharpDX.Mathematics.Interop.RawPoint targetOrigin)
        {
            System.IntPtr target_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            target_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Bitmap1>(target);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, (void *)target_, &drawRect, targetOrigin, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("4dc583bf-3a10-438a-8722-e9765224f1f1")]
    public partial class SpriteBatch : SharpDX.Direct2D1.Resource
    {
        public SpriteBatch(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SpriteBatch(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SpriteBatch(nativePtr);
        /// <summary>
        /// <p>Retrieves the number of sprites in this sprite batch.</p>
        /// </summary>
        /// <doc-id>mt619836</doc-id>
        /// <unmanaged>GetSpriteCount</unmanaged>
        /// <unmanaged-short>GetSpriteCount</unmanaged-short>
        public System.Int32 SpriteCount
        {
            get => GetSpriteCount();
        }

        /// <summary>
        /// <p>Adds the given sprites to the end of this sprite batch.</p>
        /// </summary>
        /// <param name = "spriteCount"><dd>  <p>The number of sprites to be added. This determines how many strides into each given array Direct2D will read.</p> </dd></param>
        /// <param name = "destinationRectangles"><dd>  <p>A reference to an array containing the destination rectangles specifying where to draw the sprites on the destination device context.</p> </dd></param>
        /// <param name = "sourceRectangles"><dd>  <p>A reference to an array containing the source rectangles specifying the regions of the source bitmap to draw as sprites. Direct2D will use the entire source bitmap for sprites that are assigned a null value or the InfiniteRectU.  If this parameter is omitted entirely or set to a null value, then Direct2D will use the entire source bitmap for all the added sprites.</p> </dd></param>
        /// <param name = "colors"><dd>  <p>A reference to an array containing the colors to apply to each sprite.  The output color is the result of component-wise multiplication of the source bitmap color and the provided color.  The output color is not clamped. </p> <p>Direct2D will not change the color of sprites that are assigned a null value. If this parameter is omitted entirely or set to a null value,  then Direct2D will not change the color of any of the added sprites.</p> </dd></param>
        /// <param name = "transforms"><dd>  <p>A reference to an array containing the transforms to apply to each sprite?s destination rectangle. </p> <p>Direct2D will not transform the destination rectangle of any sprites that are assigned a null value.  If this parameter is omitted entirely or set to a null value,  then Direct2D will not transform the destination rectangle of any of the added sprites.</p> </dd></param>
        /// <param name = "destinationRectanglesStride"><dd>  <p>Specifies the distance, in bytes, between each rectangle in the destinationRectangles array.  If you provide a stride of 0, then the same destination rectangle will be used for each added sprite.</p> </dd></param>
        /// <param name = "sourceRectanglesStride"><dd>  <p>Specifies the distance, in bytes, between each rectangle in the sourceRectangles array (if that array is given).  If you provide a stride of 0, then the same source rectangle will be used for each added sprite.</p> </dd></param>
        /// <param name = "colorsStride"><dd>  <p>Specifies the distance, in bytes, between each color in the colors array (if that array is given).  If you provide a stride of 0, then the same color will be used for each added sprite.</p> </dd></param>
        /// <param name = "transformsStride"><dd>  <p>Specifies the distance, in bytes, between each transform in the transforms array (if that array is given).  If you provide a stride of 0, then the same transform will be used for each added sprite.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>In Direct2D, a sprite is defined by four properties: a destination rectangle, a source rectangle, a color, and a transform.  Destination rectangles are mandatory, but the remaining properties are optional.</p><strong>Note</strong>??Always omit or pass a null value for properties you do not wish to use. This allows Direct2D to avoid storing values for those properties and to skip their handling entirely,  which improves drawing speed. For example, suppose you have a batch of 500 sprites, and you do not wish to transform any of their destination rectangles.  Rather than passing an array of identity matrices, simply omit the transforms parameter. This allows Direct2D to avoid storing any transforms and will yield the fastest drawing performance.  On the other hand, if any sprite in the batch has any value set for a property, then internally  Direct2D must allocate space for that property array and assign every sprite a value for that property (even if it?s just the default value).?
        /// </remarks>
        /// <doc-id>mt619834</doc-id>
        /// <unmanaged>HRESULT ID2D1SpriteBatch::AddSprites([In] unsigned int spriteCount,[In, Buffer] const D2D_RECT_F* destinationRectangles,[In, Buffer, Optional] const D2D_RECT_U* sourceRectangles,[In, Buffer, Optional] const D2D_COLOR_F* colors,[In, Buffer, Optional] const D2D_MATRIX_3X2_F* transforms,[In] unsigned int destinationRectanglesStride,[In] unsigned int sourceRectanglesStride,[In] unsigned int colorsStride,[In] unsigned int transformsStride)</unmanaged>
        /// <unmanaged-short>ID2D1SpriteBatch::AddSprites</unmanaged-short>
        public unsafe void AddSprites(System.Int32 spriteCount, SharpDX.Mathematics.Interop.RawRectangleF[] destinationRectangles, SharpDX.Mathematics.Interop.RawRectangle[] sourceRectangles, SharpDX.Mathematics.Interop.RawColor4[] colors, SharpDX.Mathematics.Interop.RawMatrix3x2[] transforms, System.Int32 destinationRectanglesStride, System.Int32 sourceRectanglesStride, System.Int32 colorsStride, System.Int32 transformsStride)
        {
            SharpDX.Result __result__;
            fixed (void *transforms_ = transforms)
                fixed (void *colors_ = colors)
                    fixed (void *sourceRectangles_ = sourceRectangles)
                        fixed (void *destinationRectangles_ = destinationRectangles)
                            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, spriteCount, destinationRectangles_, sourceRectangles_, colors_, transforms_, destinationRectanglesStride, sourceRectanglesStride, colorsStride, transformsStride, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Updates the properties of the specified sprites in this sprite batch. Providing a null value for any property will leave that property unmodified for that sprite. </p>
        /// </summary>
        /// <param name = "startIndex"><dd>  <p>The index of the first sprite in this sprite batch to update.</p> </dd></param>
        /// <param name = "spriteCount"><dd>  <p>The number of sprites to update with new properties. This determines how many strides into each given array Direct2D will read.</p> </dd></param>
        /// <param name = "destinationRectangles"><dd>  <p>A reference to an array containing the destination rectangles specifying where to draw the sprites on the destination device context.</p> </dd></param>
        /// <param name = "sourceRectangles"><dd>  <p>A reference to an array containing the source rectangles specifying the regions of the source bitmap to draw as sprites. </p> <p>Direct2D will use the entire source bitmap for sprites that are assigned a null value or the InfiniteRectU.  If this parameter is omitted entirely or set to a null value, then Direct2D will use the entire source bitmap for all the updated sprites.</p> </dd></param>
        /// <param name = "colors"><dd>  <p>A reference to an array containing the colors to apply to each sprite. The output color is the result of component-wise multiplication of the source bitmap color and the provided color.  The output color is not clamped. </p> <p>Direct2D will not change the color of sprites that are assigned a null value. If this parameter is omitted entirely or set to a null value,  then Direct2D will not change the color of any of the updated sprites.</p> </dd></param>
        /// <param name = "transforms"><dd>  <p>A reference to an array containing the transforms to apply to each sprite?s destination rectangle. </p> <p>Direct2D will not transform the destination rectangle of any sprites that are assigned a null value.  If this parameter is omitted entirely or set to a null value, then Direct2D will not transform the destination rectangle of any of the updated sprites.</p> </dd></param>
        /// <param name = "destinationRectanglesStride"><dd>  <p>Specifies the distance, in bytes, between each rectangle in the destinationRectangles array.  If you provide a stride of 0, then the same destination rectangle will be used for each updated sprite.</p> </dd></param>
        /// <param name = "sourceRectanglesStride"><dd>  <p>Specifies the distance, in bytes, between each rectangle in the sourceRectangles array (if that array is given).  If you provide a stride of 0, then the same source rectangle will be used for each updated sprite.</p> </dd></param>
        /// <param name = "colorsStride"><dd>  <p>Specifies the distance, in bytes, between each color in the colors array (if that array is given).  If you provide a stride of 0, then the same color will be used for each updated sprite.</p> </dd></param>
        /// <param name = "transformsStride"><dd>  <p>Specifies the distance, in bytes, between each transform in the transforms array (if that array is given).  If you provide a stride of 0, then the same transform will be used for each updated sprite.</p> </dd></param>
        /// <returns><p>Returns <see cref = "SharpDX.Result.Ok"/> on success. Returns E_INVALIDARG if an invalid value was passed to the method. In this case, no sprites are modified by this call to SetSprites.</p></returns>
        /// <doc-id>mt604121</doc-id>
        /// <unmanaged>HRESULT ID2D1SpriteBatch::SetSprites([In] unsigned int startIndex,[In] unsigned int spriteCount,[In, Buffer, Optional] const D2D_RECT_F* destinationRectangles,[In, Buffer, Optional] const D2D_RECT_U* sourceRectangles,[In, Buffer, Optional] const D2D_COLOR_F* colors,[In, Buffer, Optional] const D2D_MATRIX_3X2_F* transforms,[In] unsigned int destinationRectanglesStride,[In] unsigned int sourceRectanglesStride,[In] unsigned int colorsStride,[In] unsigned int transformsStride)</unmanaged>
        /// <unmanaged-short>ID2D1SpriteBatch::SetSprites</unmanaged-short>
        public unsafe void SetSprites(System.Int32 startIndex, System.Int32 spriteCount, SharpDX.Mathematics.Interop.RawRectangleF[] destinationRectangles, SharpDX.Mathematics.Interop.RawRectangle[] sourceRectangles, SharpDX.Mathematics.Interop.RawColor4[] colors, SharpDX.Mathematics.Interop.RawMatrix3x2[] transforms, System.Int32 destinationRectanglesStride, System.Int32 sourceRectanglesStride, System.Int32 colorsStride, System.Int32 transformsStride)
        {
            SharpDX.Result __result__;
            fixed (void *transforms_ = transforms)
                fixed (void *colors_ = colors)
                    fixed (void *sourceRectangles_ = sourceRectangles)
                        fixed (void *destinationRectangles_ = destinationRectangles)
                            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, startIndex, spriteCount, destinationRectangles_, sourceRectangles_, colors_, transforms_, destinationRectanglesStride, sourceRectanglesStride, colorsStride, transformsStride, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the specified subset of sprites from this sprite batch. For the best performance, use nullptr for properties that you do not need to retrieve.</p>
        /// </summary>
        /// <param name = "startIndex"><dd>  <p>The index of the first sprite in this sprite batch to retrieve.</p> </dd></param>
        /// <param name = "spriteCount"><dd>  <p>The number of sprites to retrieve.</p> </dd></param>
        /// <param name = "destinationRectangles"><dd>  <p>When this method returns, contains a reference to an array containing the destination rectangles for the retrieved sprites.</p> </dd></param>
        /// <param name = "sourceRectangles"><dd>  <p>When this method returns, contains a reference to an array containing the source rectangles for the retrieved sprites. </p> <p>The InfiniteRectU is returned for any sprites that were not assigned a source rectangle.</p> </dd></param>
        /// <param name = "colors"><dd>  <p>When this method returns, contains a reference to an array containing the colors to be applied to the retrieved sprites. </p> <p>The color {1.0f, 1.0f, 1.0f, 1.0f} is returned for any sprites that were not assigned a color.</p> </dd></param>
        /// <param name = "transforms"><dd>  <p>When this method returns, contains a reference to an array containing the transforms to be applied to the retrieved sprites. </p> <p>The identity matrix is returned for any sprites that were not assigned a transform.</p> </dd></param>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>mt619837</doc-id>
        /// <unmanaged>HRESULT ID2D1SpriteBatch::GetSprites([In] unsigned int startIndex,[In] unsigned int spriteCount,[Out, Buffer, Optional] D2D_RECT_F* destinationRectangles,[Out, Buffer, Optional] D2D_RECT_U* sourceRectangles,[Out, Buffer, Optional] D2D_COLOR_F* colors,[Out, Buffer, Optional] D2D_MATRIX_3X2_F* transforms)</unmanaged>
        /// <unmanaged-short>ID2D1SpriteBatch::GetSprites</unmanaged-short>
        public unsafe void GetSprites(System.Int32 startIndex, System.Int32 spriteCount, SharpDX.Mathematics.Interop.RawRectangleF[] destinationRectangles, SharpDX.Mathematics.Interop.RawRectangle[] sourceRectangles, SharpDX.Mathematics.Interop.RawColor4[] colors, SharpDX.Mathematics.Interop.RawMatrix3x2[] transforms)
        {
            SharpDX.Result __result__;
            fixed (void *transforms_ = transforms)
                fixed (void *colors_ = colors)
                    fixed (void *sourceRectangles_ = sourceRectangles)
                        fixed (void *destinationRectangles_ = destinationRectangles)
                            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, startIndex, spriteCount, destinationRectangles_, sourceRectangles_, colors_, transforms_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Retrieves the number of sprites in this sprite batch.</p>
        /// </summary>
        /// <returns><p>Returns the number of sprites in this sprite batch</p></returns>
        /// <doc-id>mt619836</doc-id>
        /// <unmanaged>unsigned int ID2D1SpriteBatch::GetSpriteCount()</unmanaged>
        /// <unmanaged-short>ID2D1SpriteBatch::GetSpriteCount</unmanaged-short>
        internal unsafe System.Int32 GetSpriteCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }

        /// <summary>
        /// <p>Removes all sprites from this sprite batch.</p>
        /// </summary>
        /// <doc-id>mt619835</doc-id>
        /// <unmanaged>void ID2D1SpriteBatch::Clear()</unmanaged>
        /// <unmanaged-short>ID2D1SpriteBatch::Clear</unmanaged-short>
        public unsafe void Clear()
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[8]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd9069d-12e2-11dc-9fed-001143a055f9")]
    public partial class StrokeStyle : SharpDX.Direct2D1.Resource
    {
        public StrokeStyle(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator StrokeStyle(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new StrokeStyle(nativePtr);
        /// <summary>
        /// <p> Retrieves the type of shape used at the beginning of a stroke.  </p>
        /// </summary>
        /// <doc-id>dd372244</doc-id>
        /// <unmanaged>GetStartCap</unmanaged>
        /// <unmanaged-short>GetStartCap</unmanaged-short>
        public SharpDX.Direct2D1.CapStyle StartCap
        {
            get => GetStartCap();
        }

        /// <summary>
        /// <p>Retrieves the type of shape used at the end of a stroke. </p>
        /// </summary>
        /// <doc-id>dd372238</doc-id>
        /// <unmanaged>GetEndCap</unmanaged>
        /// <unmanaged-short>GetEndCap</unmanaged-short>
        public SharpDX.Direct2D1.CapStyle EndCap
        {
            get => GetEndCap();
        }

        /// <summary>
        /// <p>Gets a value that specifies how the ends of each dash are drawn. </p>
        /// </summary>
        /// <doc-id>dd372218</doc-id>
        /// <unmanaged>GetDashCap</unmanaged>
        /// <unmanaged-short>GetDashCap</unmanaged-short>
        public SharpDX.Direct2D1.CapStyle DashCap
        {
            get => GetDashCap();
        }

        /// <summary>
        /// <p>Retrieves the limit on the ratio of the miter length to half the stroke's thickness. </p>
        /// </summary>
        /// <doc-id>dd372242</doc-id>
        /// <unmanaged>GetMiterLimit</unmanaged>
        /// <unmanaged-short>GetMiterLimit</unmanaged-short>
        public System.Single MiterLimit
        {
            get => GetMiterLimit();
        }

        /// <summary>
        /// <p>Retrieves the type of joint used at the vertices of a shape's outline.  </p>
        /// </summary>
        /// <doc-id>dd372240</doc-id>
        /// <unmanaged>GetLineJoin</unmanaged>
        /// <unmanaged-short>GetLineJoin</unmanaged-short>
        public SharpDX.Direct2D1.LineJoin LineJoin
        {
            get => GetLineJoin();
        }

        /// <summary>
        /// <p>Retrieves a value that specifies how far in the dash sequence the stroke will start.  </p>
        /// </summary>
        /// <doc-id>dd372234</doc-id>
        /// <unmanaged>GetDashOffset</unmanaged>
        /// <unmanaged-short>GetDashOffset</unmanaged-short>
        public System.Single DashOffset
        {
            get => GetDashOffset();
        }

        /// <summary>
        /// <p>Gets a value that describes the stroke's dash pattern. </p>
        /// </summary>
        /// <remarks>
        /// <p>If a custom dash style is specified, the dash pattern is described by the dashes array, which can be retrieved by calling the <strong>GetDashes</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd372236</doc-id>
        /// <unmanaged>GetDashStyle</unmanaged>
        /// <unmanaged-short>GetDashStyle</unmanaged-short>
        public SharpDX.Direct2D1.DashStyle DashStyle
        {
            get => GetDashStyle();
        }

        /// <summary>
        /// <p>Retrieves the number of entries in the dashes array. </p>
        /// </summary>
        /// <doc-id>dd372232</doc-id>
        /// <unmanaged>GetDashesCount</unmanaged>
        /// <unmanaged-short>GetDashesCount</unmanaged-short>
        public System.Int32 DashesCount
        {
            get => GetDashesCount();
        }

        /// <summary>
        /// <p> Retrieves the type of shape used at the beginning of a stroke.  </p>
        /// </summary>
        /// <returns><p>The type of shape used at the beginning of a stroke.</p></returns>
        /// <doc-id>dd372244</doc-id>
        /// <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetStartCap()</unmanaged>
        /// <unmanaged-short>ID2D1StrokeStyle::GetStartCap</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.CapStyle GetStartCap()
        {
            SharpDX.Direct2D1.CapStyle __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1CapStyle(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves the type of shape used at the end of a stroke. </p>
        /// </summary>
        /// <returns><p>The type of shape used at the end of a stroke.</p></returns>
        /// <doc-id>dd372238</doc-id>
        /// <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetEndCap()</unmanaged>
        /// <unmanaged-short>ID2D1StrokeStyle::GetEndCap</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.CapStyle GetEndCap()
        {
            SharpDX.Direct2D1.CapStyle __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1CapStyle(this._nativePointer, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets a value that specifies how the ends of each dash are drawn. </p>
        /// </summary>
        /// <returns><p>A value that specifies how the ends of each dash are drawn.</p></returns>
        /// <doc-id>dd372218</doc-id>
        /// <unmanaged>D2D1_CAP_STYLE ID2D1StrokeStyle::GetDashCap()</unmanaged>
        /// <unmanaged-short>ID2D1StrokeStyle::GetDashCap</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.CapStyle GetDashCap()
        {
            SharpDX.Direct2D1.CapStyle __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1CapStyle(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves the limit on the ratio of the miter length to half the stroke's thickness. </p>
        /// </summary>
        /// <returns><p>A positive number greater than or equal to 1.0f that describes the limit on the ratio of the miter length to half the stroke's thickness.</p></returns>
        /// <doc-id>dd372242</doc-id>
        /// <unmanaged>float ID2D1StrokeStyle::GetMiterLimit()</unmanaged>
        /// <unmanaged-short>ID2D1StrokeStyle::GetMiterLimit</unmanaged-short>
        internal unsafe System.Single GetMiterLimit()
        {
            System.Single __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallfloat(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves the type of joint used at the vertices of a shape's outline.  </p>
        /// </summary>
        /// <returns><p>A value that specifies the type of joint used at the vertices of a shape's outline.</p></returns>
        /// <doc-id>dd372240</doc-id>
        /// <unmanaged>D2D1_LINE_JOIN ID2D1StrokeStyle::GetLineJoin()</unmanaged>
        /// <unmanaged-short>ID2D1StrokeStyle::GetLineJoin</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.LineJoin GetLineJoin()
        {
            SharpDX.Direct2D1.LineJoin __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1LineJoin(this._nativePointer, (*(void ***)this._nativePointer)[8]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves a value that specifies how far in the dash sequence the stroke will start.  </p>
        /// </summary>
        /// <returns><p>A value that specifies how far in the dash sequence the stroke will start. </p></returns>
        /// <doc-id>dd372234</doc-id>
        /// <unmanaged>float ID2D1StrokeStyle::GetDashOffset()</unmanaged>
        /// <unmanaged-short>ID2D1StrokeStyle::GetDashOffset</unmanaged-short>
        internal unsafe System.Single GetDashOffset()
        {
            System.Single __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallfloat(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }

        /// <summary>
        /// <p>Gets a value that describes the stroke's dash pattern. </p>
        /// </summary>
        /// <returns><p>A value that describes the predefined dash pattern used, or <strong>D2D1_DASH_STYLE_CUSTOM</strong> if a custom dash style is used.</p></returns>
        /// <remarks>
        /// <p>If a custom dash style is specified, the dash pattern is described by the dashes array, which can be retrieved by calling the <strong>GetDashes</strong> method.</p>
        /// </remarks>
        /// <doc-id>dd372236</doc-id>
        /// <unmanaged>D2D1_DASH_STYLE ID2D1StrokeStyle::GetDashStyle()</unmanaged>
        /// <unmanaged-short>ID2D1StrokeStyle::GetDashStyle</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.DashStyle GetDashStyle()
        {
            SharpDX.Direct2D1.DashStyle __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1DashStyle(this._nativePointer, (*(void ***)this._nativePointer)[10]);
            return __result__;
        }

        /// <summary>
        /// <p>Retrieves the number of entries in the dashes array. </p>
        /// </summary>
        /// <returns><p>The number of entries in the dashes array if the stroke is dashed; otherwise, 0.</p></returns>
        /// <doc-id>dd372232</doc-id>
        /// <unmanaged>unsigned int ID2D1StrokeStyle::GetDashesCount()</unmanaged>
        /// <unmanaged-short>ID2D1StrokeStyle::GetDashesCount</unmanaged-short>
        internal unsafe System.Int32 GetDashesCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[11]);
            return __result__;
        }

        /// <summary>
        /// <p>Copies the dash pattern to the specified array. </p>
        /// </summary>
        /// <param name = "dashes"><dd>  <p>A reference to an array that will receive the dash pattern. The array must be able to contain at least as many elements as specified by <em>dashesCount</em>. You must allocate storage for this array.</p> </dd></param>
        /// <param name = "dashesCount"><dd>  <p>The number of dashes to copy. If this value is less than the number of dashes in the stroke style's dashes array, the returned dashes are truncated to <em>dashesCount</em>. If this value is greater than the number of dashes in the stroke style's dashes array, the extra dashes are set to 0.0f. To obtain the actual number of dashes in the stroke style's dashes array, use the <strong>GetDashesCount</strong> method. </p> </dd></param>
        /// <remarks>
        /// <p>The dashes are specified in units that are a multiple of the stroke width, with subsequent members of the array indicating the dashes and gaps between dashes: the first entry indicates a filled dash, the second a gap, and so on. </p>
        /// </remarks>
        /// <doc-id>dd372230</doc-id>
        /// <unmanaged>void ID2D1StrokeStyle::GetDashes([Out, Buffer] float* dashes,[In] unsigned int dashesCount)</unmanaged>
        /// <unmanaged-short>ID2D1StrokeStyle::GetDashes</unmanaged-short>
        public unsafe void GetDashes(System.Single[] dashes, System.Int32 dashesCount)
        {
            fixed (void *dashes_ = dashes)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, dashes_, dashesCount, (*(void ***)this._nativePointer)[12]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("10a72a66-e91c-43f4-993f-ddf4b82b0b4a")]
    public partial class StrokeStyle1 : SharpDX.Direct2D1.StrokeStyle
    {
        public StrokeStyle1(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator StrokeStyle1(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new StrokeStyle1(nativePtr);
        /// <summary>
        /// <p>Gets the stroke transform type.</p>
        /// </summary>
        /// <doc-id>hh446916</doc-id>
        /// <unmanaged>GetStrokeTransformType</unmanaged>
        /// <unmanaged-short>GetStrokeTransformType</unmanaged-short>
        public SharpDX.Direct2D1.StrokeTransformType StrokeTransformType
        {
            get => GetStrokeTransformType();
        }

        /// <summary>
        /// <p>Gets the stroke transform type.</p>
        /// </summary>
        /// <returns><p>This method returns the stroke transform type.</p></returns>
        /// <doc-id>hh446916</doc-id>
        /// <unmanaged>D2D1_STROKE_TRANSFORM_TYPE ID2D1StrokeStyle1::GetStrokeTransformType()</unmanaged>
        /// <unmanaged-short>ID2D1StrokeStyle1::GetStrokeTransformType</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.StrokeTransformType GetStrokeTransformType()
        {
            SharpDX.Direct2D1.StrokeTransformType __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1StrokeTransformType(this._nativePointer, (*(void ***)this._nativePointer)[13]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("c9cdb0dd-f8c9-4e70-b7c2-301c80292c5e")]
    public partial class SvgAttribute : SharpDX.Direct2D1.Resource
    {
        public SvgAttribute(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SvgAttribute(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SvgAttribute(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetElement</unmanaged>
        /// <unmanaged-short>GetElement</unmanaged-short>
        public SharpDX.Direct2D1.SvgElement Element
        {
            get
            {
                GetElement(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "element">No documentation.</param>
        /// <unmanaged>void ID2D1SvgAttribute::GetElement([Out, Optional] ID2D1SvgElement** element)</unmanaged>
        /// <unmanaged-short>ID2D1SvgAttribute::GetElement</unmanaged-short>
        internal unsafe void GetElement(out SharpDX.Direct2D1.SvgElement element)
        {
            System.IntPtr element_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &element_, (*(void ***)this._nativePointer)[4]);
            if (element_ != System.IntPtr.Zero)
                element = new SharpDX.Direct2D1.SvgElement(element_);
            else
                element = null;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "attribute">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgAttribute::Clone([Out] ID2D1SvgAttribute** attribute)</unmanaged>
        /// <unmanaged-short>ID2D1SvgAttribute::Clone</unmanaged-short>
        internal unsafe void Clone(out SharpDX.Direct2D1.SvgAttribute attribute)
        {
            System.IntPtr attribute_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &attribute_, (*(void ***)this._nativePointer)[5]);
            if (attribute_ != System.IntPtr.Zero)
                attribute = new SharpDX.Direct2D1.SvgAttribute(attribute_);
            else
                attribute = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("86b88e4d-afa4-4d7b-88e4-68a51c4a0aec")]
    public partial class SvgDocument : SharpDX.Direct2D1.Resource
    {
        public SvgDocument(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SvgDocument(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SvgDocument(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetViewportSize / SetViewportSize</unmanaged>
        /// <unmanaged-short>GetViewportSize</unmanaged-short>
        public SharpDX.Size2F ViewportSize
        {
            get => GetViewportSize();
            set => SetViewportSize(value);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetRoot / SetRoot</unmanaged>
        /// <unmanaged-short>GetRoot</unmanaged-short>
        public SharpDX.Direct2D1.SvgElement Root
        {
            get
            {
                GetRoot(out var __output__);
                return __output__;
            }

            set => SetRoot(value);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "viewportSize">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgDocument::SetViewportSize([In] D2D_SIZE_F viewportSize)</unmanaged>
        /// <unmanaged-short>ID2D1SvgDocument::SetViewportSize</unmanaged-short>
        internal unsafe void SetViewportSize(SharpDX.Size2F viewportSize)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, viewportSize, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>D2D_SIZE_F ID2D1SvgDocument::GetViewportSize()</unmanaged>
        /// <unmanaged-short>ID2D1SvgDocument::GetViewportSize</unmanaged-short>
        internal unsafe SharpDX.Size2F GetViewportSize()
        {
            SharpDX.Size2F __result__;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoidPtr(this._nativePointer, &__result__, (*(void ***)this._nativePointer)[5]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "root">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgDocument::SetRoot([In, Optional] ID2D1SvgElement* root)</unmanaged>
        /// <unmanaged-short>ID2D1SvgDocument::SetRoot</unmanaged-short>
        internal unsafe void SetRoot(SharpDX.Direct2D1.SvgElement root)
        {
            System.IntPtr root_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            root_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SvgElement>(root);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)root_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "root">No documentation.</param>
        /// <unmanaged>void ID2D1SvgDocument::GetRoot([Out, Optional] ID2D1SvgElement** root)</unmanaged>
        /// <unmanaged-short>ID2D1SvgDocument::GetRoot</unmanaged-short>
        internal unsafe void GetRoot(out SharpDX.Direct2D1.SvgElement root)
        {
            System.IntPtr root_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &root_, (*(void ***)this._nativePointer)[7]);
            if (root_ != System.IntPtr.Zero)
                root = new SharpDX.Direct2D1.SvgElement(root_);
            else
                root = null;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "id">No documentation.</param>
        /// <param name = "svgElement">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgDocument::FindElementById([In] const wchar_t* id,[Out, Optional] ID2D1SvgElement** svgElement)</unmanaged>
        /// <unmanaged-short>ID2D1SvgDocument::FindElementById</unmanaged-short>
        private unsafe SharpDX.Result TryFindElementById_(System.String id, out SharpDX.Direct2D1.SvgElement svgElement)
        {
            System.IntPtr svgElement_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (char *id_ = id)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)id_, &svgElement_, (*(void ***)this._nativePointer)[8]);
            if (svgElement_ != System.IntPtr.Zero)
                svgElement = new SharpDX.Direct2D1.SvgElement(svgElement_);
            else
                svgElement = null;
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "outputXmlStream">No documentation.</param>
        /// <param name = "subtree">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgDocument::Serialize([In] IStream* outputXmlStream,[In, Optional] ID2D1SvgElement* subtree)</unmanaged>
        /// <unmanaged-short>ID2D1SvgDocument::Serialize</unmanaged-short>
        public unsafe void Serialize(SharpDX.Win32.IStream outputXmlStream, SharpDX.Direct2D1.SvgElement subtree)
        {
            System.IntPtr outputXmlStream_ = System.IntPtr.Zero;
            System.IntPtr subtree_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            outputXmlStream_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Win32.IStream>(outputXmlStream);
            subtree_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SvgElement>(subtree);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)outputXmlStream_, (void *)subtree_, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "inputXmlStream">No documentation.</param>
        /// <param name = "subtree">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgDocument::Deserialize([In] IStream* inputXmlStream,[Out] ID2D1SvgElement** subtree)</unmanaged>
        /// <unmanaged-short>ID2D1SvgDocument::Deserialize</unmanaged-short>
        public unsafe void Deserialize(SharpDX.Win32.IStream inputXmlStream, out SharpDX.Direct2D1.SvgElement subtree)
        {
            System.IntPtr inputXmlStream_ = System.IntPtr.Zero;
            System.IntPtr subtree_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            inputXmlStream_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Win32.IStream>(inputXmlStream);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)inputXmlStream_, &subtree_, (*(void ***)this._nativePointer)[10]);
            if (subtree_ != System.IntPtr.Zero)
                subtree = new SharpDX.Direct2D1.SvgElement(subtree_);
            else
                subtree = null;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "paintType">No documentation.</param>
        /// <param name = "color">No documentation.</param>
        /// <param name = "id">No documentation.</param>
        /// <param name = "aintRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgDocument::CreatePaint([In] D2D1_SVG_PAINT_TYPE paintType,[In, Optional] const D2D_COLOR_F* color,[In, Optional] const wchar_t* id,[Out] ID2D1SvgPaint** paint)</unmanaged>
        /// <unmanaged-short>ID2D1SvgDocument::CreatePaint</unmanaged-short>
        public unsafe void CreatePaint(SharpDX.Direct2D1.SvgPaintType paintType, SharpDX.Mathematics.Interop.RawColor4? color, System.String id, out SharpDX.Direct2D1.SvgPaint aintRef)
        {
            SharpDX.Mathematics.Interop.RawColor4 color_;
            System.IntPtr aintRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            if (color != null)
                color_ = color.Value;
            fixed (char *id_ = id)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)paintType), color == null ? (void *)0 : &color_, (void *)id_, &aintRef_, (*(void ***)this._nativePointer)[11]);
            if (aintRef_ != System.IntPtr.Zero)
                aintRef = new SharpDX.Direct2D1.SvgPaint(aintRef_);
            else
                aintRef = null;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "dashes">No documentation.</param>
        /// <param name = "dashesCount">No documentation.</param>
        /// <param name = "strokeDashArray">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgDocument::CreateStrokeDashArray([In, Buffer, Optional] const D2D1_SVG_LENGTH* dashes,[In] unsigned int dashesCount,[Out] ID2D1SvgStrokeDashArray** strokeDashArray)</unmanaged>
        /// <unmanaged-short>ID2D1SvgDocument::CreateStrokeDashArray</unmanaged-short>
        public unsafe void CreateStrokeDashArray(SharpDX.Direct2D1.SvgLength[] dashes, System.Int32 dashesCount, out SharpDX.Direct2D1.SvgStrokeDashArray strokeDashArray)
        {
            System.IntPtr strokeDashArray_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *dashes_ = dashes)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, dashes_, dashesCount, &strokeDashArray_, (*(void ***)this._nativePointer)[12]);
            if (strokeDashArray_ != System.IntPtr.Zero)
                strokeDashArray = new SharpDX.Direct2D1.SvgStrokeDashArray(strokeDashArray_);
            else
                strokeDashArray = null;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "ointsRef">No documentation.</param>
        /// <param name = "pointsCount">No documentation.</param>
        /// <param name = "ointCollectionRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgDocument::CreatePointCollection([In, Buffer, Optional] const D2D_POINT_2F* points,[In] unsigned int pointsCount,[Out] ID2D1SvgPointCollection** pointCollection)</unmanaged>
        /// <unmanaged-short>ID2D1SvgDocument::CreatePointCollection</unmanaged-short>
        public unsafe void CreatePointCollection(SharpDX.Mathematics.Interop.RawVector2[] ointsRef, System.Int32 pointsCount, out SharpDX.Direct2D1.SvgPointCollection ointCollectionRef)
        {
            System.IntPtr ointCollectionRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *ointsRef_ = ointsRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, ointsRef_, pointsCount, &ointCollectionRef_, (*(void ***)this._nativePointer)[13]);
            if (ointCollectionRef_ != System.IntPtr.Zero)
                ointCollectionRef = new SharpDX.Direct2D1.SvgPointCollection(ointCollectionRef_);
            else
                ointCollectionRef = null;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "segmentData">No documentation.</param>
        /// <param name = "segmentDataCount">No documentation.</param>
        /// <param name = "commands">No documentation.</param>
        /// <param name = "commandsCount">No documentation.</param>
        /// <param name = "athDataRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgDocument::CreatePathData([In, Buffer, Optional] const float* segmentData,[In] unsigned int segmentDataCount,[In, Buffer, Optional] const D2D1_SVG_PATH_COMMAND* commands,[In] unsigned int commandsCount,[Out] ID2D1SvgPathData** pathData)</unmanaged>
        /// <unmanaged-short>ID2D1SvgDocument::CreatePathData</unmanaged-short>
        public unsafe void CreatePathData(System.Single[] segmentData, System.Int32 segmentDataCount, SharpDX.Direct2D1.SvgPathCommand[] commands, System.Int32 commandsCount, out SharpDX.Direct2D1.SvgPathData athDataRef)
        {
            System.IntPtr athDataRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (void *commands_ = commands)
                fixed (void *segmentData_ = segmentData)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, segmentData_, segmentDataCount, commands_, commandsCount, &athDataRef_, (*(void ***)this._nativePointer)[14]);
            if (athDataRef_ != System.IntPtr.Zero)
                athDataRef = new SharpDX.Direct2D1.SvgPathData(athDataRef_);
            else
                athDataRef = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("ac7b67a6-183e-49c1-a823-0ebe40b0db29")]
    public partial class SvgElement : SharpDX.Direct2D1.Resource
    {
        public SvgElement(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SvgElement(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SvgElement(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetDocument</unmanaged>
        /// <unmanaged-short>GetDocument</unmanaged-short>
        public SharpDX.Direct2D1.SvgDocument Document
        {
            get
            {
                GetDocument(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetTagNameLength</unmanaged>
        /// <unmanaged-short>GetTagNameLength</unmanaged-short>
        public System.Int32 TagNameLength
        {
            get => GetTagNameLength();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>IsTextContent</unmanaged>
        /// <unmanaged-short>IsTextContent</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawBool IsTextContent
        {
            get => IsTextContent_();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetParent</unmanaged>
        /// <unmanaged-short>GetParent</unmanaged-short>
        public SharpDX.Direct2D1.SvgElement Parent
        {
            get
            {
                GetParent(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetFirstChild</unmanaged>
        /// <unmanaged-short>GetFirstChild</unmanaged-short>
        public SharpDX.Direct2D1.SvgElement FirstChild
        {
            get
            {
                GetFirstChild(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetLastChild</unmanaged>
        /// <unmanaged-short>GetLastChild</unmanaged-short>
        public SharpDX.Direct2D1.SvgElement LastChild
        {
            get
            {
                GetLastChild(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetSpecifiedAttributeCount</unmanaged>
        /// <unmanaged-short>GetSpecifiedAttributeCount</unmanaged-short>
        public System.Int32 SpecifiedAttributeCount
        {
            get => GetSpecifiedAttributeCount();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetTextValueLength</unmanaged>
        /// <unmanaged-short>GetTextValueLength</unmanaged-short>
        public System.Int32 TextValueLength
        {
            get => GetTextValueLength();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "document">No documentation.</param>
        /// <unmanaged>void ID2D1SvgElement::GetDocument([Out, Optional] ID2D1SvgDocument** document)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetDocument</unmanaged-short>
        internal unsafe void GetDocument(out SharpDX.Direct2D1.SvgDocument document)
        {
            System.IntPtr document_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &document_, (*(void ***)this._nativePointer)[4]);
            if (document_ != System.IntPtr.Zero)
                document = new SharpDX.Direct2D1.SvgDocument(document_);
            else
                document = null;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "name">No documentation.</param>
        /// <param name = "nameCount">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::GetTagName([Out, Buffer] wchar_t* name,[In] unsigned int nameCount)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetTagName</unmanaged-short>
        public unsafe void GetTagName(System.IntPtr name, System.Int32 nameCount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name, nameCount, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>unsigned int ID2D1SvgElement::GetTagNameLength()</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetTagNameLength</unmanaged-short>
        internal unsafe System.Int32 GetTagNameLength()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[6]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>BOOL ID2D1SvgElement::IsTextContent()</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::IsTextContent</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawBool IsTextContent_()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "arentRef">No documentation.</param>
        /// <unmanaged>void ID2D1SvgElement::GetParent([Out, Optional] ID2D1SvgElement** parent)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetParent</unmanaged-short>
        internal unsafe void GetParent(out SharpDX.Direct2D1.SvgElement arentRef)
        {
            System.IntPtr arentRef_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &arentRef_, (*(void ***)this._nativePointer)[8]);
            if (arentRef_ != System.IntPtr.Zero)
                arentRef = new SharpDX.Direct2D1.SvgElement(arentRef_);
            else
                arentRef = null;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>BOOL ID2D1SvgElement::HasChildren()</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::HasChildren</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool HasChildren()
        {
            SharpDX.Mathematics.Interop.RawBool __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "child">No documentation.</param>
        /// <unmanaged>void ID2D1SvgElement::GetFirstChild([Out, Optional] ID2D1SvgElement** child)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetFirstChild</unmanaged-short>
        internal unsafe void GetFirstChild(out SharpDX.Direct2D1.SvgElement child)
        {
            System.IntPtr child_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &child_, (*(void ***)this._nativePointer)[10]);
            if (child_ != System.IntPtr.Zero)
                child = new SharpDX.Direct2D1.SvgElement(child_);
            else
                child = null;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "child">No documentation.</param>
        /// <unmanaged>void ID2D1SvgElement::GetLastChild([Out, Optional] ID2D1SvgElement** child)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetLastChild</unmanaged-short>
        internal unsafe void GetLastChild(out SharpDX.Direct2D1.SvgElement child)
        {
            System.IntPtr child_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &child_, (*(void ***)this._nativePointer)[11]);
            if (child_ != System.IntPtr.Zero)
                child = new SharpDX.Direct2D1.SvgElement(child_);
            else
                child = null;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "referenceChild">No documentation.</param>
        /// <param name = "reviousChildRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::GetPreviousChild([In] ID2D1SvgElement* referenceChild,[Out, Optional] ID2D1SvgElement** previousChild)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetPreviousChild</unmanaged-short>
        public unsafe void GetPreviousChild(SharpDX.Direct2D1.SvgElement referenceChild, out SharpDX.Direct2D1.SvgElement reviousChildRef)
        {
            System.IntPtr referenceChild_ = System.IntPtr.Zero;
            System.IntPtr reviousChildRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            referenceChild_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SvgElement>(referenceChild);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)referenceChild_, &reviousChildRef_, (*(void ***)this._nativePointer)[12]);
            if (reviousChildRef_ != System.IntPtr.Zero)
                reviousChildRef = new SharpDX.Direct2D1.SvgElement(reviousChildRef_);
            else
                reviousChildRef = null;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "referenceChild">No documentation.</param>
        /// <param name = "nextChild">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::GetNextChild([In] ID2D1SvgElement* referenceChild,[Out, Optional] ID2D1SvgElement** nextChild)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetNextChild</unmanaged-short>
        public unsafe void GetNextChild(SharpDX.Direct2D1.SvgElement referenceChild, out SharpDX.Direct2D1.SvgElement nextChild)
        {
            System.IntPtr referenceChild_ = System.IntPtr.Zero;
            System.IntPtr nextChild_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            referenceChild_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SvgElement>(referenceChild);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)referenceChild_, &nextChild_, (*(void ***)this._nativePointer)[13]);
            if (nextChild_ != System.IntPtr.Zero)
                nextChild = new SharpDX.Direct2D1.SvgElement(nextChild_);
            else
                nextChild = null;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "newChild">No documentation.</param>
        /// <param name = "referenceChild">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::InsertChildBefore([In] ID2D1SvgElement* newChild,[In, Optional] ID2D1SvgElement* referenceChild)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::InsertChildBefore</unmanaged-short>
        public unsafe void InsertChildBefore(SharpDX.Direct2D1.SvgElement newChild, SharpDX.Direct2D1.SvgElement referenceChild)
        {
            System.IntPtr newChild_ = System.IntPtr.Zero;
            System.IntPtr referenceChild_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            newChild_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SvgElement>(newChild);
            referenceChild_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SvgElement>(referenceChild);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)newChild_, (void *)referenceChild_, (*(void ***)this._nativePointer)[14]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "newChild">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::AppendChild([In] ID2D1SvgElement* newChild)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::AppendChild</unmanaged-short>
        public unsafe void AppendChild(SharpDX.Direct2D1.SvgElement newChild)
        {
            System.IntPtr newChild_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            newChild_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SvgElement>(newChild);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)newChild_, (*(void ***)this._nativePointer)[15]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "newChild">No documentation.</param>
        /// <param name = "oldChild">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::ReplaceChild([In] ID2D1SvgElement* newChild,[In] ID2D1SvgElement* oldChild)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::ReplaceChild</unmanaged-short>
        public unsafe void ReplaceChild(SharpDX.Direct2D1.SvgElement newChild, SharpDX.Direct2D1.SvgElement oldChild)
        {
            System.IntPtr newChild_ = System.IntPtr.Zero;
            System.IntPtr oldChild_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            newChild_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SvgElement>(newChild);
            oldChild_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SvgElement>(oldChild);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)newChild_, (void *)oldChild_, (*(void ***)this._nativePointer)[16]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "oldChild">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::RemoveChild([In] ID2D1SvgElement* oldChild)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::RemoveChild</unmanaged-short>
        public unsafe void RemoveChild(SharpDX.Direct2D1.SvgElement oldChild)
        {
            System.IntPtr oldChild_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            oldChild_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SvgElement>(oldChild);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)oldChild_, (*(void ***)this._nativePointer)[17]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "tagName">No documentation.</param>
        /// <param name = "newChild">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::CreateChild([In] const wchar_t* tagName,[Out] ID2D1SvgElement** newChild)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::CreateChild</unmanaged-short>
        public unsafe void CreateChild(System.String tagName, out SharpDX.Direct2D1.SvgElement newChild)
        {
            System.IntPtr newChild_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fixed (char *tagName_ = tagName)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)tagName_, &newChild_, (*(void ***)this._nativePointer)[18]);
            if (newChild_ != System.IntPtr.Zero)
                newChild = new SharpDX.Direct2D1.SvgElement(newChild_);
            else
                newChild = null;
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "name">No documentation.</param>
        /// <param name = "inherited">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>BOOL ID2D1SvgElement::IsAttributeSpecified([In] const wchar_t* name,[Out, Optional] BOOL* inherited)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::IsAttributeSpecified</unmanaged-short>
        public unsafe SharpDX.Mathematics.Interop.RawBool IsAttributeSpecified(System.String name, out SharpDX.Mathematics.Interop.RawBool inherited)
        {
            inherited = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Mathematics.Interop.RawBool __result__;
            fixed (void *inherited_ = &inherited)
                fixed (char *name_ = name)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXMathematicsInteropRawBool(this._nativePointer, (void *)name_, inherited_, (*(void ***)this._nativePointer)[19]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>unsigned int ID2D1SvgElement::GetSpecifiedAttributeCount()</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetSpecifiedAttributeCount</unmanaged-short>
        internal unsafe System.Int32 GetSpecifiedAttributeCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[20]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "index">No documentation.</param>
        /// <param name = "name">No documentation.</param>
        /// <param name = "nameCount">No documentation.</param>
        /// <param name = "inherited">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::GetSpecifiedAttributeName([In] unsigned int index,[Out, Buffer] wchar_t* name,[In] unsigned int nameCount,[Out, Optional] BOOL* inherited)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetSpecifiedAttributeName</unmanaged-short>
        public unsafe void GetSpecifiedAttributeName(System.Int32 index, System.IntPtr name, System.Int32 nameCount, out SharpDX.Mathematics.Interop.RawBool inherited)
        {
            inherited = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *inherited_ = &inherited)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, index, (void *)name, nameCount, inherited_, (*(void ***)this._nativePointer)[21]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "index">No documentation.</param>
        /// <param name = "nameLength">No documentation.</param>
        /// <param name = "inherited">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::GetSpecifiedAttributeNameLength([In] unsigned int index,[Out] unsigned int* nameLength,[Out, Optional] BOOL* inherited)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetSpecifiedAttributeNameLength</unmanaged-short>
        public unsafe void GetSpecifiedAttributeNameLength(System.Int32 index, out System.Int32 nameLength, out SharpDX.Mathematics.Interop.RawBool inherited)
        {
            inherited = default (SharpDX.Mathematics.Interop.RawBool);
            SharpDX.Result __result__;
            fixed (void *inherited_ = &inherited)
                fixed (void *nameLength_ = &nameLength)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, index, nameLength_, inherited_, (*(void ***)this._nativePointer)[22]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "name">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::RemoveAttribute([In] const wchar_t* name)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::RemoveAttribute</unmanaged-short>
        public unsafe void RemoveAttribute(System.String name)
        {
            SharpDX.Result __result__;
            fixed (char *name_ = name)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, (*(void ***)this._nativePointer)[23]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "name">No documentation.</param>
        /// <param name = "nameCount">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::SetTextValue([In, Buffer] const wchar_t* name,[In] unsigned int nameCount)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::SetTextValue</unmanaged-short>
        public unsafe void SetTextValue(System.String name, System.Int32 nameCount)
        {
            SharpDX.Result __result__;
            fixed (char *name_ = name)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, nameCount, (*(void ***)this._nativePointer)[24]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "name">No documentation.</param>
        /// <param name = "nameCount">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::GetTextValue([Out, Buffer] wchar_t* name,[In] unsigned int nameCount)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetTextValue</unmanaged-short>
        public unsafe void GetTextValue(System.IntPtr name, System.Int32 nameCount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name, nameCount, (*(void ***)this._nativePointer)[25]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>unsigned int ID2D1SvgElement::GetTextValueLength()</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetTextValueLength</unmanaged-short>
        internal unsafe System.Int32 GetTextValueLength()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[26]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "name">No documentation.</param>
        /// <param name = "value">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::SetAttributeValue([In] const wchar_t* name,[In] ID2D1SvgAttribute* value)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::SetAttributeValue</unmanaged-short>
        public unsafe void SetAttributeValue(System.String name, SharpDX.Direct2D1.SvgAttribute value)
        {
            System.IntPtr value_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            value_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.SvgAttribute>(value);
            fixed (char *name_ = name)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, (void *)value_, (*(void ***)this._nativePointer)[27]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "name">No documentation.</param>
        /// <param name = "type">No documentation.</param>
        /// <param name = "value">No documentation.</param>
        /// <param name = "valueSizeInBytes">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::SetAttributeValue([In] const wchar_t* name,[In] D2D1_SVG_ATTRIBUTE_POD_TYPE type,[In, Buffer] const void* value,[In] unsigned int valueSizeInBytes)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::SetAttributeValue</unmanaged-short>
        public unsafe void SetAttributeValue(System.String name, SharpDX.Direct2D1.SvgAttributePodType type, System.IntPtr value, System.Int32 valueSizeInBytes)
        {
            SharpDX.Result __result__;
            fixed (char *name_ = name)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, unchecked ((System.Int32)type), (void *)value, valueSizeInBytes, (*(void ***)this._nativePointer)[28]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "name">No documentation.</param>
        /// <param name = "type">No documentation.</param>
        /// <param name = "value">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::SetAttributeValue([In] const wchar_t* name,[In] D2D1_SVG_ATTRIBUTE_STRING_TYPE type,[In] const wchar_t* value)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::SetAttributeValue</unmanaged-short>
        public unsafe void SetAttributeValue(System.String name, SharpDX.Direct2D1.SvgAttributeStringType type, System.String value)
        {
            SharpDX.Result __result__;
            fixed (char *value_ = value)
                fixed (char *name_ = name)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, unchecked ((System.Int32)type), (void *)value_, (*(void ***)this._nativePointer)[29]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "name">No documentation.</param>
        /// <param name = "riid">No documentation.</param>
        /// <param name = "value">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::GetAttributeValue([In] const wchar_t* name,[In] const GUID&amp; riid,[Out, Optional] void** value)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetAttributeValue</unmanaged-short>
        public unsafe void GetAttributeValue(System.String name, System.Guid riid, out System.IntPtr value)
        {
            SharpDX.Result __result__;
            fixed (void *value_ = &value)
                fixed (char *name_ = name)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, &riid, value_, (*(void ***)this._nativePointer)[30]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "name">No documentation.</param>
        /// <param name = "type">No documentation.</param>
        /// <param name = "value">No documentation.</param>
        /// <param name = "valueSizeInBytes">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::GetAttributeValue([In] const wchar_t* name,[In] D2D1_SVG_ATTRIBUTE_POD_TYPE type,[Out, Buffer] void* value,[In] unsigned int valueSizeInBytes)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetAttributeValue</unmanaged-short>
        public unsafe void GetAttributeValue(System.String name, SharpDX.Direct2D1.SvgAttributePodType type, System.IntPtr value, System.Int32 valueSizeInBytes)
        {
            SharpDX.Result __result__;
            fixed (char *name_ = name)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, unchecked ((System.Int32)type), (void *)value, valueSizeInBytes, (*(void ***)this._nativePointer)[31]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "name">No documentation.</param>
        /// <param name = "type">No documentation.</param>
        /// <param name = "value">No documentation.</param>
        /// <param name = "valueCount">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::GetAttributeValue([In] const wchar_t* name,[In] D2D1_SVG_ATTRIBUTE_STRING_TYPE type,[Out, Buffer] wchar_t* value,[In] unsigned int valueCount)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetAttributeValue</unmanaged-short>
        public unsafe void GetAttributeValue(System.String name, SharpDX.Direct2D1.SvgAttributeStringType type, System.IntPtr value, System.Int32 valueCount)
        {
            SharpDX.Result __result__;
            fixed (char *name_ = name)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, unchecked ((System.Int32)type), (void *)value, valueCount, (*(void ***)this._nativePointer)[32]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "name">No documentation.</param>
        /// <param name = "type">No documentation.</param>
        /// <param name = "valueLength">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgElement::GetAttributeValueLength([In] const wchar_t* name,[In] D2D1_SVG_ATTRIBUTE_STRING_TYPE type,[Out] unsigned int* valueLength)</unmanaged>
        /// <unmanaged-short>ID2D1SvgElement::GetAttributeValueLength</unmanaged-short>
        public unsafe void GetAttributeValueLength(System.String name, SharpDX.Direct2D1.SvgAttributeStringType type, out System.Int32 valueLength)
        {
            SharpDX.Result __result__;
            fixed (void *valueLength_ = &valueLength)
                fixed (char *name_ = name)
                    __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)name_, unchecked ((System.Int32)type), valueLength_, (*(void ***)this._nativePointer)[33]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("af671749-d241-4db8-8e41-dcc2e5c1a438")]
    public partial class SvgGlyphStyle : SharpDX.Direct2D1.Resource
    {
        public SvgGlyphStyle(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SvgGlyphStyle(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SvgGlyphStyle(nativePtr);
        /// <summary>
        /// <p>Returns or sets the requested fill parameters.</p>
        /// </summary>
        /// <doc-id>mt750194</doc-id>
        /// <unmanaged>GetFill / SetFill</unmanaged>
        /// <unmanaged-short>GetFill</unmanaged-short>
        public SharpDX.Direct2D1.Brush Fill
        {
            get
            {
                GetFill(out var __output__);
                return __output__;
            }

            set => SetFill(value);
        }

        /// <summary>
        /// <p>Returns the number of dashes in the dash array.</p>
        /// </summary>
        /// <doc-id>mt750196</doc-id>
        /// <unmanaged>GetStrokeDashesCount</unmanaged>
        /// <unmanaged-short>GetStrokeDashesCount</unmanaged-short>
        public System.Int32 StrokeDashesCount
        {
            get => GetStrokeDashesCount();
        }

        /// <summary>
        /// <p>Provides values to an SVG glyph for fill.</p>
        /// </summary>
        /// <param name = "brush"><dd>  <p>Describes how the area is painted.  A null brush will cause the context-fill value to come from the <strong>defaultFillBrush</strong>. If the defaultFillBrush is also null, the context-fill value will be 'none'. To set the ?context-fill? value, this method uses the provided brush with its opacity set to 1. To set the ?context-fill-opacity? value, this method uses the opacity of the provided brush. </p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code.</p></returns>
        /// <doc-id>mt750197</doc-id>
        /// <unmanaged>HRESULT ID2D1SvgGlyphStyle::SetFill([In, Optional] ID2D1Brush* brush)</unmanaged>
        /// <unmanaged-short>ID2D1SvgGlyphStyle::SetFill</unmanaged-short>
        internal unsafe void SetFill(SharpDX.Direct2D1.Brush brush)
        {
            System.IntPtr brush_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)brush_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns the requested fill parameters.</p>
        /// </summary>
        /// <param name = "brush"><dd>  <p>Describes how the area is painted.</p> </dd></param>
        /// <doc-id>mt750194</doc-id>
        /// <unmanaged>void ID2D1SvgGlyphStyle::GetFill([Out, Optional] ID2D1Brush** brush)</unmanaged>
        /// <unmanaged-short>ID2D1SvgGlyphStyle::GetFill</unmanaged-short>
        internal unsafe void GetFill(out SharpDX.Direct2D1.Brush brush)
        {
            System.IntPtr brush_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &brush_, (*(void ***)this._nativePointer)[5]);
            if (brush_ != System.IntPtr.Zero)
                brush = new SharpDX.Direct2D1.Brush(brush_);
            else
                brush = null;
        }

        /// <summary>
        /// <p>Provides values to an SVG glyph for stroke properties. The brush with opacity set to 1 is used as the 'context-stroke'. The opacity of the brush is used as the 'context-stroke-opacity' value.</p>
        /// </summary>
        /// <param name = "brush"><dd>  <p>Describes how the stroke is painted. A null brush will cause the context-stroke value to be none.</p> </dd></param>
        /// <param name = "strokeWidth"><dd>  <p>Specifies the 'context-value' for the 'stroke-width' property.</p> </dd></param>
        /// <param name = "dashes"><dd>  <p>Specifies the 'context-value' for the 'stroke-dasharray' property. A null value will cause the stroke-dasharray to be set to 'none'.</p> </dd></param>
        /// <param name = "dashesCount"><dd>  <p>The the number of dashes in the dash array.</p> </dd></param>
        /// <param name = "dashOffset"><dd>  <p>Specifies the 'context-value' for the 'stroke-dashoffset' property.</p> </dd></param>
        /// <returns><p>This method returns an <see cref = "SharpDX.Result"/> success or error code.</p></returns>
        /// <doc-id>mt750198</doc-id>
        /// <unmanaged>HRESULT ID2D1SvgGlyphStyle::SetStroke([In, Optional] ID2D1Brush* brush,[In] float strokeWidth,[In, Buffer, Optional] const float* dashes,[In] unsigned int dashesCount,[In] float dashOffset)</unmanaged>
        /// <unmanaged-short>ID2D1SvgGlyphStyle::SetStroke</unmanaged-short>
        public unsafe void SetStroke(SharpDX.Direct2D1.Brush brush, System.Single strokeWidth, System.Single[] dashes, System.Int32 dashesCount, System.Single dashOffset)
        {
            System.IntPtr brush_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            brush_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.Brush>(brush);
            fixed (void *dashes_ = dashes)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)brush_, strokeWidth, dashes_, dashesCount, dashOffset, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Returns the number of dashes in the dash array.</p>
        /// </summary>
        /// <returns><p>Returns the number of dashes in the dash array.</p></returns>
        /// <doc-id>mt750196</doc-id>
        /// <unmanaged>unsigned int ID2D1SvgGlyphStyle::GetStrokeDashesCount()</unmanaged>
        /// <unmanaged-short>ID2D1SvgGlyphStyle::GetStrokeDashesCount</unmanaged-short>
        internal unsafe System.Int32 GetStrokeDashesCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }

        /// <summary>
        /// <p>Returns the requested stroke parameters. Any parameters that are non-null will receive the value of the requested parameter. </p>
        /// </summary>
        /// <param name = "brush"><dd>  <p>Describes how the stroke is painted.</p> </dd></param>
        /// <param name = "strokeWidth"><dd>  <p>The 'context-value' for the 'stroke-width' property.</p> </dd></param>
        /// <param name = "dashes"><dd>  <p>The 'context-value' for the 'stroke-dasharray' property.</p> </dd></param>
        /// <param name = "dashesCount"><dd>  <p>The the number of dashes in the dash array.</p> </dd></param>
        /// <param name = "dashOffset"><dd>  <p>The 'context-value' for the 'stroke-dashoffset' property.</p> </dd></param>
        /// <doc-id>mt750195</doc-id>
        /// <unmanaged>void ID2D1SvgGlyphStyle::GetStroke([Out, Optional] ID2D1Brush** brush,[Out, Optional] float* strokeWidth,[Out, Buffer, Optional] float* dashes,[In] unsigned int dashesCount,[Out, Optional] float* dashOffset)</unmanaged>
        /// <unmanaged-short>ID2D1SvgGlyphStyle::GetStroke</unmanaged-short>
        public unsafe void GetStroke(out SharpDX.Direct2D1.Brush brush, out System.Single strokeWidth, System.Single[] dashes, System.Int32 dashesCount, out System.Single dashOffset)
        {
            System.IntPtr brush_ = System.IntPtr.Zero;
            fixed (void *dashOffset_ = &dashOffset)
                fixed (void *dashes_ = dashes)
                    fixed (void *strokeWidth_ = &strokeWidth)
                        SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &brush_, strokeWidth_, dashes_, dashesCount, dashOffset_, (*(void ***)this._nativePointer)[8]);
            if (brush_ != System.IntPtr.Zero)
                brush = new SharpDX.Direct2D1.Brush(brush_);
            else
                brush = null;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("d59bab0a-68a2-455b-a5dc-9eb2854e2490")]
    public partial class SvgPaint : SharpDX.Direct2D1.SvgAttribute
    {
        public SvgPaint(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SvgPaint(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SvgPaint(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetPaintType / SetPaintType</unmanaged>
        /// <unmanaged-short>GetPaintType</unmanaged-short>
        public SharpDX.Direct2D1.SvgPaintType PaintType
        {
            get => GetPaintType();
            set => SetPaintType(value);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetColor / SetColor</unmanaged>
        /// <unmanaged-short>GetColor</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawColor4 Color
        {
            get
            {
                GetColor(out var __output__);
                return __output__;
            }

            set => SetColor(value);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetIdLength</unmanaged>
        /// <unmanaged-short>GetIdLength</unmanaged-short>
        public System.Int32 IdLength
        {
            get => GetIdLength();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "paintType">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgPaint::SetPaintType([In] D2D1_SVG_PAINT_TYPE paintType)</unmanaged>
        /// <unmanaged-short>ID2D1SvgPaint::SetPaintType</unmanaged-short>
        internal unsafe void SetPaintType(SharpDX.Direct2D1.SvgPaintType paintType)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)paintType), (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>D2D1_SVG_PAINT_TYPE ID2D1SvgPaint::GetPaintType()</unmanaged>
        /// <unmanaged-short>ID2D1SvgPaint::GetPaintType</unmanaged-short>
        internal unsafe SharpDX.Direct2D1.SvgPaintType GetPaintType()
        {
            SharpDX.Direct2D1.SvgPaintType __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1SvgPaintType(this._nativePointer, (*(void ***)this._nativePointer)[7]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "color">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgPaint::SetColor([In] const D2D_COLOR_F* color)</unmanaged>
        /// <unmanaged-short>ID2D1SvgPaint::SetColor</unmanaged-short>
        internal unsafe void SetColor(SharpDX.Mathematics.Interop.RawColor4 color)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &color, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "color">No documentation.</param>
        /// <unmanaged>void ID2D1SvgPaint::GetColor([Out] D2D_COLOR_F* color)</unmanaged>
        /// <unmanaged-short>ID2D1SvgPaint::GetColor</unmanaged-short>
        internal unsafe void GetColor(out SharpDX.Mathematics.Interop.RawColor4 color)
        {
            color = default (SharpDX.Mathematics.Interop.RawColor4);
            fixed (void *color_ = &color)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, color_, (*(void ***)this._nativePointer)[9]);
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "id">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgPaint::SetId([In] const wchar_t* id)</unmanaged>
        /// <unmanaged-short>ID2D1SvgPaint::SetId</unmanaged-short>
        public unsafe void SetId(System.String id)
        {
            SharpDX.Result __result__;
            fixed (char *id_ = id)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)id_, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "id">No documentation.</param>
        /// <param name = "idCount">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgPaint::GetId([Out, Buffer] wchar_t* id,[In] unsigned int idCount)</unmanaged>
        /// <unmanaged-short>ID2D1SvgPaint::GetId</unmanaged-short>
        public unsafe void GetId(System.IntPtr id, System.Int32 idCount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)id, idCount, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>unsigned int ID2D1SvgPaint::GetIdLength()</unmanaged>
        /// <unmanaged-short>ID2D1SvgPaint::GetIdLength</unmanaged-short>
        internal unsafe System.Int32 GetIdLength()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[12]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("c095e4f4-bb98-43d6-9745-4d1b84ec9888")]
    public partial class SvgPathData : SharpDX.Direct2D1.SvgAttribute
    {
        public SvgPathData(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SvgPathData(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SvgPathData(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetSegmentDataCount</unmanaged>
        /// <unmanaged-short>GetSegmentDataCount</unmanaged-short>
        public System.Int32 SegmentDataCount
        {
            get => GetSegmentDataCount();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetCommandsCount</unmanaged>
        /// <unmanaged-short>GetCommandsCount</unmanaged-short>
        public System.Int32 CommandsCount
        {
            get => GetCommandsCount();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "dataCount">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgPathData::RemoveSegmentDataAtEnd([In] unsigned int dataCount)</unmanaged>
        /// <unmanaged-short>ID2D1SvgPathData::RemoveSegmentDataAtEnd</unmanaged-short>
        public unsafe void RemoveSegmentDataAtEnd(System.Int32 dataCount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, dataCount, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "data">No documentation.</param>
        /// <param name = "dataCount">No documentation.</param>
        /// <param name = "startIndex">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgPathData::UpdateSegmentData([In, Buffer] const float* data,[In] unsigned int dataCount,[In] unsigned int startIndex)</unmanaged>
        /// <unmanaged-short>ID2D1SvgPathData::UpdateSegmentData</unmanaged-short>
        public unsafe void UpdateSegmentData(System.Single[] data, System.Int32 dataCount, System.Int32 startIndex)
        {
            SharpDX.Result __result__;
            fixed (void *data_ = data)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, data_, dataCount, startIndex, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "data">No documentation.</param>
        /// <param name = "dataCount">No documentation.</param>
        /// <param name = "startIndex">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgPathData::GetSegmentData([Out, Buffer] float* data,[In] unsigned int dataCount,[In] unsigned int startIndex)</unmanaged>
        /// <unmanaged-short>ID2D1SvgPathData::GetSegmentData</unmanaged-short>
        public unsafe void GetSegmentData(System.Single[] data, System.Int32 dataCount, System.Int32 startIndex)
        {
            SharpDX.Result __result__;
            fixed (void *data_ = data)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, data_, dataCount, startIndex, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>unsigned int ID2D1SvgPathData::GetSegmentDataCount()</unmanaged>
        /// <unmanaged-short>ID2D1SvgPathData::GetSegmentDataCount</unmanaged-short>
        internal unsafe System.Int32 GetSegmentDataCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "commandsCount">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgPathData::RemoveCommandsAtEnd([In] unsigned int commandsCount)</unmanaged>
        /// <unmanaged-short>ID2D1SvgPathData::RemoveCommandsAtEnd</unmanaged-short>
        public unsafe void RemoveCommandsAtEnd(System.Int32 commandsCount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, commandsCount, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "commands">No documentation.</param>
        /// <param name = "commandsCount">No documentation.</param>
        /// <param name = "startIndex">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgPathData::UpdateCommands([In, Buffer] const D2D1_SVG_PATH_COMMAND* commands,[In] unsigned int commandsCount,[In] unsigned int startIndex)</unmanaged>
        /// <unmanaged-short>ID2D1SvgPathData::UpdateCommands</unmanaged-short>
        public unsafe void UpdateCommands(SharpDX.Direct2D1.SvgPathCommand[] commands, System.Int32 commandsCount, System.Int32 startIndex)
        {
            SharpDX.Result __result__;
            fixed (void *commands_ = commands)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, commands_, commandsCount, startIndex, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "commands">No documentation.</param>
        /// <param name = "commandsCount">No documentation.</param>
        /// <param name = "startIndex">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgPathData::GetCommands([Out, Buffer] D2D1_SVG_PATH_COMMAND* commands,[In] unsigned int commandsCount,[In] unsigned int startIndex)</unmanaged>
        /// <unmanaged-short>ID2D1SvgPathData::GetCommands</unmanaged-short>
        public unsafe void GetCommands(SharpDX.Direct2D1.SvgPathCommand[] commands, System.Int32 commandsCount, System.Int32 startIndex)
        {
            SharpDX.Result __result__;
            fixed (void *commands_ = commands)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, commands_, commandsCount, startIndex, (*(void ***)this._nativePointer)[12]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>unsigned int ID2D1SvgPathData::GetCommandsCount()</unmanaged>
        /// <unmanaged-short>ID2D1SvgPathData::GetCommandsCount</unmanaged-short>
        internal unsafe System.Int32 GetCommandsCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[13]);
            return __result__;
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "fillMode">No documentation.</param>
        /// <param name = "athGeometryRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgPathData::CreatePathGeometry([In] D2D1_FILL_MODE fillMode,[Out] ID2D1PathGeometry1** pathGeometry)</unmanaged>
        /// <unmanaged-short>ID2D1SvgPathData::CreatePathGeometry</unmanaged-short>
        public unsafe void CreatePathGeometry(SharpDX.Direct2D1.FillMode fillMode, out SharpDX.Direct2D1.PathGeometry1 athGeometryRef)
        {
            System.IntPtr athGeometryRef_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, unchecked ((System.Int32)fillMode), &athGeometryRef_, (*(void ***)this._nativePointer)[14]);
            if (athGeometryRef_ != System.IntPtr.Zero)
                athGeometryRef = new SharpDX.Direct2D1.PathGeometry1(athGeometryRef_);
            else
                athGeometryRef = null;
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("9dbe4c0d-3572-4dd9-9825-5530813bb712")]
    public partial class SvgPointCollection : SharpDX.Direct2D1.SvgAttribute
    {
        public SvgPointCollection(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SvgPointCollection(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SvgPointCollection(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetPointsCount</unmanaged>
        /// <unmanaged-short>GetPointsCount</unmanaged-short>
        public System.Int32 PointsCount
        {
            get => GetPointsCount();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "pointsCount">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgPointCollection::RemovePointsAtEnd([In] unsigned int pointsCount)</unmanaged>
        /// <unmanaged-short>ID2D1SvgPointCollection::RemovePointsAtEnd</unmanaged-short>
        public unsafe void RemovePointsAtEnd(System.Int32 pointsCount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, pointsCount, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "ointsRef">No documentation.</param>
        /// <param name = "pointsCount">No documentation.</param>
        /// <param name = "startIndex">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgPointCollection::UpdatePoints([In, Buffer] const D2D_POINT_2F* points,[In] unsigned int pointsCount,[In] unsigned int startIndex)</unmanaged>
        /// <unmanaged-short>ID2D1SvgPointCollection::UpdatePoints</unmanaged-short>
        public unsafe void UpdatePoints(SharpDX.Mathematics.Interop.RawVector2[] ointsRef, System.Int32 pointsCount, System.Int32 startIndex)
        {
            SharpDX.Result __result__;
            fixed (void *ointsRef_ = ointsRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, ointsRef_, pointsCount, startIndex, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "ointsRef">No documentation.</param>
        /// <param name = "pointsCount">No documentation.</param>
        /// <param name = "startIndex">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgPointCollection::GetPoints([Out, Buffer] D2D_POINT_2F* points,[In] unsigned int pointsCount,[In] unsigned int startIndex)</unmanaged>
        /// <unmanaged-short>ID2D1SvgPointCollection::GetPoints</unmanaged-short>
        public unsafe void GetPoints(SharpDX.Mathematics.Interop.RawVector2[] ointsRef, System.Int32 pointsCount, System.Int32 startIndex)
        {
            SharpDX.Result __result__;
            fixed (void *ointsRef_ = ointsRef)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, ointsRef_, pointsCount, startIndex, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>unsigned int ID2D1SvgPointCollection::GetPointsCount()</unmanaged>
        /// <unmanaged-short>ID2D1SvgPointCollection::GetPointsCount</unmanaged-short>
        internal unsafe System.Int32 GetPointsCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[9]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("f1c0ca52-92a3-4f00-b4ce-f35691efd9d9")]
    public partial class SvgStrokeDashArray : SharpDX.Direct2D1.SvgAttribute
    {
        public SvgStrokeDashArray(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator SvgStrokeDashArray(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new SvgStrokeDashArray(nativePtr);
        /// <summary>
        /// No documentation.
        /// </summary>
        /// <unmanaged>GetDashesCount</unmanaged>
        /// <unmanaged-short>GetDashesCount</unmanaged-short>
        public System.Int32 DashesCount
        {
            get => GetDashesCount();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "dashesCount">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgStrokeDashArray::RemoveDashesAtEnd([In] unsigned int dashesCount)</unmanaged>
        /// <unmanaged-short>ID2D1SvgStrokeDashArray::RemoveDashesAtEnd</unmanaged-short>
        public unsafe void RemoveDashesAtEnd(System.Int32 dashesCount)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, dashesCount, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "dashes">No documentation.</param>
        /// <param name = "dashesCount">No documentation.</param>
        /// <param name = "startIndex">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgStrokeDashArray::UpdateDashes([In, Buffer] const D2D1_SVG_LENGTH* dashes,[In] unsigned int dashesCount,[In] unsigned int startIndex)</unmanaged>
        /// <unmanaged-short>ID2D1SvgStrokeDashArray::UpdateDashes</unmanaged-short>
        public unsafe void UpdateDashes(SharpDX.Direct2D1.SvgLength[] dashes, System.Int32 dashesCount, System.Int32 startIndex)
        {
            SharpDX.Result __result__;
            fixed (void *dashes_ = dashes)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, dashes_, dashesCount, startIndex, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "dashes">No documentation.</param>
        /// <param name = "dashesCount">No documentation.</param>
        /// <param name = "startIndex">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgStrokeDashArray::UpdateDashes([In, Buffer] const float* dashes,[In] unsigned int dashesCount,[In] unsigned int startIndex)</unmanaged>
        /// <unmanaged-short>ID2D1SvgStrokeDashArray::UpdateDashes</unmanaged-short>
        public unsafe void UpdateDashes(System.Single[] dashes, System.Int32 dashesCount, System.Int32 startIndex)
        {
            SharpDX.Result __result__;
            fixed (void *dashes_ = dashes)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, dashes_, dashesCount, startIndex, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "dashes">No documentation.</param>
        /// <param name = "dashesCount">No documentation.</param>
        /// <param name = "startIndex">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgStrokeDashArray::GetDashes([Out, Buffer] D2D1_SVG_LENGTH* dashes,[In] unsigned int dashesCount,[In] unsigned int startIndex)</unmanaged>
        /// <unmanaged-short>ID2D1SvgStrokeDashArray::GetDashes</unmanaged-short>
        public unsafe void GetDashes(SharpDX.Direct2D1.SvgLength[] dashes, System.Int32 dashesCount, System.Int32 startIndex)
        {
            SharpDX.Result __result__;
            fixed (void *dashes_ = dashes)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, dashes_, dashesCount, startIndex, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <param name = "dashes">No documentation.</param>
        /// <param name = "dashesCount">No documentation.</param>
        /// <param name = "startIndex">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <unmanaged>HRESULT ID2D1SvgStrokeDashArray::GetDashes([Out, Buffer] float* dashes,[In] unsigned int dashesCount,[In] unsigned int startIndex)</unmanaged>
        /// <unmanaged-short>ID2D1SvgStrokeDashArray::GetDashes</unmanaged-short>
        public unsafe void GetDashes(System.Single[] dashes, System.Int32 dashesCount, System.Int32 startIndex)
        {
            SharpDX.Result __result__;
            fixed (void *dashes_ = dashes)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, dashes_, dashesCount, startIndex, (*(void ***)this._nativePointer)[10]);
            __result__.CheckError();
        }

        /// <summary>
        /// No documentation.
        /// </summary>
        /// <returns>No documentation.</returns>
        /// <unmanaged>unsigned int ID2D1SvgStrokeDashArray::GetDashesCount()</unmanaged>
        /// <unmanaged-short>ID2D1SvgStrokeDashArray::GetDashesCount</unmanaged-short>
        internal unsafe System.Int32 GetDashesCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[11]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd906c1-12e2-11dc-9fed-001143a055f9")]
    public partial interface TessellationSink : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd906c1-12e2-11dc-9fed-001143a055f9")]
    internal partial class TessellationSinkNative : SharpDX.ComObject, SharpDX.Direct2D1.TessellationSink
    {
        public TessellationSinkNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TessellationSinkNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TessellationSinkNative(nativePtr);
        /// <summary>
        /// <p>Copies the specified triangles to the sink.  </p>
        /// </summary>
        /// <param name = "triangles"><dd>  <p>An array of <strong><see cref = "SharpDX.Direct2D1.Triangle"/></strong> structures that describe the triangles to add to the sink.</p> </dd></param>
        /// <param name = "trianglesCount"><dd>  <p>The number of triangles to copy from the <em>triangles</em> array.</p> </dd></param>
        /// <doc-id>dd372248</doc-id>
        /// <unmanaged>void ID2D1TessellationSink::AddTriangles([In, Buffer] const D2D1_TRIANGLE* triangles,[In] unsigned int trianglesCount)</unmanaged>
        /// <unmanaged-short>ID2D1TessellationSink::AddTriangles</unmanaged-short>
        internal unsafe void AddTriangles_(SharpDX.Direct2D1.Triangle[] triangles, System.Int32 trianglesCount)
        {
            fixed (void *triangles_ = triangles)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, triangles_, trianglesCount, (*(void ***)this._nativePointer)[3]);
        }

        /// <summary>
        /// <p> Closes the sink and returns its error status.</p>
        /// </summary>
        /// <returns><p>If this method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. Otherwise, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <doc-id>dd372250</doc-id>
        /// <unmanaged>HRESULT ID2D1TessellationSink::Close()</unmanaged>
        /// <unmanaged-short>ID2D1TessellationSink::Close</unmanaged-short>
        internal unsafe void Close_()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("ef1a287d-342a-4f76-8fdb-da0d6ea9f92b")]
    public partial interface Transform : SharpDX.Direct2D1.TransformNode
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd906bb-12e2-11dc-9fed-001143a055f9")]
    public partial class TransformedGeometry : SharpDX.Direct2D1.Geometry
    {
        public TransformedGeometry(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TransformedGeometry(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TransformedGeometry(nativePtr);
        /// <summary>
        /// <p>Retrieves the source geometry of this transformed geometry object. </p>
        /// </summary>
        /// <doc-id>dd372255</doc-id>
        /// <unmanaged>GetSourceGeometry</unmanaged>
        /// <unmanaged-short>GetSourceGeometry</unmanaged-short>
        public SharpDX.Direct2D1.Geometry SourceGeometry
        {
            get
            {
                GetSourceGeometry(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves the matrix used to transform the <strong><see cref = "SharpDX.Direct2D1.TransformedGeometry"/></strong> object's source geometry. </p>
        /// </summary>
        /// <doc-id>dd372256</doc-id>
        /// <unmanaged>GetTransform</unmanaged>
        /// <unmanaged-short>GetTransform</unmanaged-short>
        public SharpDX.Mathematics.Interop.RawMatrix3x2 Transform
        {
            get
            {
                GetTransform(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p>Retrieves the source geometry of this transformed geometry object. </p>
        /// </summary>
        /// <param name = "sourceGeometry"><dd>  <p>When this method returns, contains a reference to a reference to the source geometry for this transformed geometry object. This parameter is passed uninitialized.</p> </dd></param>
        /// <doc-id>dd372255</doc-id>
        /// <unmanaged>void ID2D1TransformedGeometry::GetSourceGeometry([Out] ID2D1Geometry** sourceGeometry)</unmanaged>
        /// <unmanaged-short>ID2D1TransformedGeometry::GetSourceGeometry</unmanaged-short>
        internal unsafe void GetSourceGeometry(out SharpDX.Direct2D1.Geometry sourceGeometry)
        {
            System.IntPtr sourceGeometry_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &sourceGeometry_, (*(void ***)this._nativePointer)[17]);
            if (sourceGeometry_ != System.IntPtr.Zero)
                sourceGeometry = new SharpDX.Direct2D1.Geometry(sourceGeometry_);
            else
                sourceGeometry = null;
        }

        /// <summary>
        /// <p>Retrieves the matrix used to transform the <strong><see cref = "SharpDX.Direct2D1.TransformedGeometry"/></strong> object's source geometry. </p>
        /// </summary>
        /// <param name = "transform">No documentation.</param>
        /// <doc-id>dd372256</doc-id>
        /// <unmanaged>void ID2D1TransformedGeometry::GetTransform([Out] D2D_MATRIX_3X2_F* transform)</unmanaged>
        /// <unmanaged-short>ID2D1TransformedGeometry::GetTransform</unmanaged-short>
        internal unsafe void GetTransform(out SharpDX.Mathematics.Interop.RawMatrix3x2 transform)
        {
            transform = default (SharpDX.Mathematics.Interop.RawMatrix3x2);
            fixed (void *transform_ = &transform)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, transform_, (*(void ***)this._nativePointer)[18]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("7f1f79e5-2796-416c-8f55-700f911445e5")]
    public partial class TransformedImageSource : SharpDX.Direct2D1.Image
    {
        public TransformedImageSource(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TransformedImageSource(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TransformedImageSource(nativePtr);
        /// <summary>
        /// <p> Retrieves the source image used to create the transformed image source. This value corresponds to the value passed to <strong>CreateTransformedImageSource</strong>. </p>
        /// </summary>
        /// <doc-id>dn952307</doc-id>
        /// <unmanaged>GetSource</unmanaged>
        /// <unmanaged-short>GetSource</unmanaged-short>
        public SharpDX.Direct2D1.ImageSource Source
        {
            get
            {
                GetSource(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Retrieves the properties specified when the transformed image source was created. This value corresponds to the value passed to <strong>CreateTransformedImageSource</strong>. </p>
        /// </summary>
        /// <doc-id>dn952306</doc-id>
        /// <unmanaged>GetProperties</unmanaged>
        /// <unmanaged-short>GetProperties</unmanaged-short>
        public SharpDX.Direct2D1.TransformedImageSourceProperties Properties
        {
            get
            {
                GetProperties(out var __output__);
                return __output__;
            }
        }

        /// <summary>
        /// <p> Retrieves the source image used to create the transformed image source. This value corresponds to the value passed to <strong>CreateTransformedImageSource</strong>. </p>
        /// </summary>
        /// <param name = "imageSource">No documentation.</param>
        /// <doc-id>dn952307</doc-id>
        /// <unmanaged>void ID2D1TransformedImageSource::GetSource([Out, Optional] ID2D1ImageSource** imageSource)</unmanaged>
        /// <unmanaged-short>ID2D1TransformedImageSource::GetSource</unmanaged-short>
        internal unsafe void GetSource(out SharpDX.Direct2D1.ImageSource imageSource)
        {
            System.IntPtr imageSource_ = System.IntPtr.Zero;
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, &imageSource_, (*(void ***)this._nativePointer)[4]);
            if (imageSource_ != System.IntPtr.Zero)
                imageSource = new SharpDX.Direct2D1.ImageSource(imageSource_);
            else
                imageSource = null;
        }

        /// <summary>
        /// <p> Retrieves the properties specified when the transformed image source was created. This value corresponds to the value passed to <strong>CreateTransformedImageSource</strong>. </p>
        /// </summary>
        /// <param name = "ropertiesRef">No documentation.</param>
        /// <doc-id>dn952306</doc-id>
        /// <unmanaged>void ID2D1TransformedImageSource::GetProperties([Out] D2D1_TRANSFORMED_IMAGE_SOURCE_PROPERTIES* properties)</unmanaged>
        /// <unmanaged-short>ID2D1TransformedImageSource::GetProperties</unmanaged-short>
        internal unsafe void GetProperties(out SharpDX.Direct2D1.TransformedImageSourceProperties ropertiesRef)
        {
            ropertiesRef = default (SharpDX.Direct2D1.TransformedImageSourceProperties);
            fixed (void *ropertiesRef_ = &ropertiesRef)
                SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, ropertiesRef_, (*(void ***)this._nativePointer)[5]);
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("13d29038-c3e6-4034-9081-13b53a417992")]
    public partial class TransformGraph : SharpDX.ComObject
    {
        public TransformGraph(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TransformGraph(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TransformGraph(nativePtr);
        /// <summary>
        /// <p>Returns the number of inputs to the transform graph.</p>
        /// </summary>
        /// <doc-id>hh871467</doc-id>
        /// <unmanaged>GetInputCount</unmanaged>
        /// <unmanaged-short>GetInputCount</unmanaged-short>
        public System.Int32 InputCount
        {
            get => GetInputCount();
        }

        /// <summary>
        /// <p>Returns the number of inputs to the transform graph.</p>
        /// </summary>
        /// <returns><p>The number of inputs to this transform graph.</p></returns>
        /// <doc-id>hh871467</doc-id>
        /// <unmanaged>unsigned int ID2D1TransformGraph::GetInputCount()</unmanaged>
        /// <unmanaged-short>ID2D1TransformGraph::GetInputCount</unmanaged-short>
        internal unsafe System.Int32 GetInputCount()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }

        /// <summary>
        /// <p>Sets a single transform node as being equivalent to the whole graph.</p>
        /// </summary>
        /// <param name = "node"><dd>  <p>The node to be set.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>This equivalent to calling <strong>ID2D1TransformGraph::Clear</strong>, adding a single node, connecting all of the node inputs to the effect inputs in order, and setting the transform not as the graph output.</p>
        /// </remarks>
        /// <doc-id>hh446935</doc-id>
        /// <unmanaged>HRESULT ID2D1TransformGraph::SetSingleTransformNode([In] ID2D1TransformNode* node)</unmanaged>
        /// <unmanaged-short>ID2D1TransformGraph::SetSingleTransformNode</unmanaged-short>
        public unsafe void SetSingleTransformNode(SharpDX.Direct2D1.TransformNode node)
        {
            System.IntPtr node_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            node_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.TransformNode>(node);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)node_, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Adds the provided node to the transform graph.</p>
        /// </summary>
        /// <param name = "node"><dd>  <p>The node that will be added to the transform graph.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>E_OUTOFMEMORY</td><td>Direct2D could not allocate sufficient memory to complete the call.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>This adds a transform node to the transform graph. A node must be added to the transform graph before it can be interconnected in any way.
        /// </p><p>A transform graph cannot be directly added to another transform graph. 
        /// Only interfaces derived from <strong><see cref = "SharpDX.Direct2D1.TransformNode"/></strong> can be added to the transform graph.
        /// </p>
        /// </remarks>
        /// <doc-id>hh446922</doc-id>
        /// <unmanaged>HRESULT ID2D1TransformGraph::AddNode([In] ID2D1TransformNode* node)</unmanaged>
        /// <unmanaged-short>ID2D1TransformGraph::AddNode</unmanaged-short>
        public unsafe void AddNode(SharpDX.Direct2D1.TransformNode node)
        {
            System.IntPtr node_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            node_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.TransformNode>(node);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)node_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Removes the provided node from the transform graph.</p>
        /// </summary>
        /// <param name = "node"><dd>  <p>The node that will be removed from the transform graph.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>D2DERR_NOT_FOUND = (HRESULT_FROM_WIN32(ERROR_NOT_FOUND))</td><td>Direct2D could not locate the specified node.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The node must already exist in the graph; otherwise, the call fails with <strong>D2DERR_NOT_FOUND</strong>.</p><p>Any connections to this node will be removed when the node is removed.</p><p>After the node is removed, it cannot be used by the interface until it has been added to the graph by <strong>AddNode</strong>.</p>
        /// </remarks>
        /// <doc-id>hh446931</doc-id>
        /// <unmanaged>HRESULT ID2D1TransformGraph::RemoveNode([In] ID2D1TransformNode* node)</unmanaged>
        /// <unmanaged-short>ID2D1TransformGraph::RemoveNode</unmanaged-short>
        public unsafe void RemoveNode(SharpDX.Direct2D1.TransformNode node)
        {
            System.IntPtr node_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            node_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.TransformNode>(node);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)node_, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Sets the output node for the transform graph.</p>
        /// </summary>
        /// <param name = "node"><dd>  <p>The node that will be considered the output of the transform node.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>D2DERR_NOT_FOUND = (HRESULT_FROM_WIN32(ERROR_NOT_FOUND))</td><td>Direct2D could not locate the specified node.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>The node must already exist in the graph; otherwise, the call fails with <strong>D2DERR_NOT_FOUND</strong>.</p>
        /// </remarks>
        /// <doc-id>hh446932</doc-id>
        /// <unmanaged>HRESULT ID2D1TransformGraph::SetOutputNode([In] ID2D1TransformNode* node)</unmanaged>
        /// <unmanaged-short>ID2D1TransformGraph::SetOutputNode</unmanaged-short>
        public unsafe void SetOutputNode(SharpDX.Direct2D1.TransformNode node)
        {
            System.IntPtr node_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            node_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.TransformNode>(node);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)node_, (*(void ***)this._nativePointer)[7]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Connects two nodes inside the transform graph.</p>
        /// </summary>
        /// <param name = "fromNode"><dd>  <p>The node from which the connection will be made.</p> </dd></param>
        /// <param name = "toNode"><dd>  <p>The node to which the connection will be made.</p> </dd></param>
        /// <param name = "toNodeInputIndex"><dd>  <p>The node input that will be connected.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>D2DERR_NOT_FOUND = (HRESULT_FROM_WIN32(ERROR_NOT_FOUND))</td><td>Direct2D could not locate the specified node.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>Both nodes must already exist in the graph; otherwise, the call fails with <strong>D2DERR_NOT_FOUND</strong>.</p>
        /// </remarks>
        /// <doc-id>hh446926</doc-id>
        /// <unmanaged>HRESULT ID2D1TransformGraph::ConnectNode([In] ID2D1TransformNode* fromNode,[In] ID2D1TransformNode* toNode,[In] unsigned int toNodeInputIndex)</unmanaged>
        /// <unmanaged-short>ID2D1TransformGraph::ConnectNode</unmanaged-short>
        public unsafe void ConnectNode(SharpDX.Direct2D1.TransformNode fromNode, SharpDX.Direct2D1.TransformNode toNode, System.Int32 toNodeInputIndex)
        {
            System.IntPtr fromNode_ = System.IntPtr.Zero;
            System.IntPtr toNode_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            fromNode_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.TransformNode>(fromNode);
            toNode_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.TransformNode>(toNode);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (void *)fromNode_, (void *)toNode_, toNodeInputIndex, (*(void ***)this._nativePointer)[8]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Connects a transform node inside the graph to the corresponding effect input of the encapsulating effect.</p>
        /// </summary>
        /// <param name = "toEffectInputIndex"><dd>  <p>The effect input to which the transform node will be bound.</p> </dd></param>
        /// <param name = "node"><dd>  <p>The node to which the connection will be made.</p> </dd></param>
        /// <param name = "toNodeInputIndex"><dd>  <p>The node input that will be connected.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>D2DERR_NOT_FOUND = (HRESULT_FROM_WIN32(ERROR_NOT_FOUND))</td><td>Direct2D could not locate the specified node.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh446928</doc-id>
        /// <unmanaged>HRESULT ID2D1TransformGraph::ConnectToEffectInput([In] unsigned int toEffectInputIndex,[In] ID2D1TransformNode* node,[In] unsigned int toNodeInputIndex)</unmanaged>
        /// <unmanaged-short>ID2D1TransformGraph::ConnectToEffectInput</unmanaged-short>
        public unsafe void ConnectToEffectInput(System.Int32 toEffectInputIndex, SharpDX.Direct2D1.TransformNode node, System.Int32 toNodeInputIndex)
        {
            System.IntPtr node_ = System.IntPtr.Zero;
            SharpDX.Result __result__;
            node_ = SharpDX.CppObject.ToCallbackPtr<SharpDX.Direct2D1.TransformNode>(node);
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, toEffectInputIndex, (void *)node_, toNodeInputIndex, (*(void ***)this._nativePointer)[9]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Clears the transform nodes and all connections from the transform graph.</p>
        /// </summary>
        /// <remarks>
        /// <p>Used when enough changes to transfoms would make  editing of the transform graph inefficient.</p>
        /// </remarks>
        /// <doc-id>hh446924</doc-id>
        /// <unmanaged>void ID2D1TransformGraph::Clear()</unmanaged>
        /// <unmanaged-short>ID2D1TransformGraph::Clear</unmanaged-short>
        public unsafe void Clear()
        {
            SharpDX.Direct2D1.LocalInterop.CalliStdCallvoid(this._nativePointer, (*(void ***)this._nativePointer)[10]);
        }

        /// <summary>
        /// <p>Uses the specified input as the effect output.</p>
        /// </summary>
        /// <param name = "effectInputIndex"><dd> <p>The index of the input to the effect.</p> </dd></param>
        /// <returns><p>The method returns an <strong><see cref = "SharpDX.Result"/></strong>. Possible values include, but are not limited to, those in the following table.</p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred</td></tr> <tr><td>D2DERR_NOT_FOUND = (HRESULT_FROM_WIN32(ERROR_NOT_FOUND))</td><td>Direct2D could not locate the specified node.</td></tr> </table><p>?</p></returns>
        /// <doc-id>hh997720</doc-id>
        /// <unmanaged>HRESULT ID2D1TransformGraph::SetPassthroughGraph([In] unsigned int effectInputIndex)</unmanaged>
        /// <unmanaged-short>ID2D1TransformGraph::SetPassthroughGraph</unmanaged-short>
        public unsafe void SetPassthroughGraph(System.Int32 effectInputIndex)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, effectInputIndex, (*(void ***)this._nativePointer)[11]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("ef1a287d-342a-4f76-8fdb-da0d6ea9f92b")]
    public partial class TransformNative : SharpDX.Direct2D1.TransformNodeNative, SharpDX.Direct2D1.Transform
    {
        public TransformNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TransformNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TransformNative(nativePtr);
        /// <summary>
        /// <p>Allows a transform to state how it would map a rectangle requested on its output to a set of sample rectangles on its input.</p>
        /// </summary>
        /// <param name = "outputRect"><dd>  <p>The output rectangle from which the inputs must be mapped.</p> </dd></param>
        /// <param name = "inputRects"><dd>  <p>The corresponding set of inputs. The inputs will directly correspond to the transform inputs.</p> </dd></param>
        /// <param name = "inputRectsCount"><dd>  <p>The number of inputs specified. Direct2D guarantees that this is equal to the number of inputs specified on the transform.</p> </dd></param>
        /// <returns><p>If the method succeeds, it returns <strong><see cref = "SharpDX.Result.Ok"/></strong>. If it fails, it returns an <strong><see cref = "SharpDX.Result"/></strong> error code.</p></returns>
        /// <remarks>
        /// <p>The transform implementation must ensure that any pixel shader or software callback implementation it provides honors this calculation.</p><p>The transform implementation must regard this method as purely functional. It can base the mapped input and output rectangles on its current state as specified by the encapsulating effect properties.    However, it must not change its own state in response to this method being invoked. The Direct2D renderer implementation reserves the right to call this method at any time and in any sequence.</p>
        /// </remarks>
        /// <doc-id>hh446945</doc-id>
        /// <unmanaged>HRESULT ID2D1Transform::MapOutputRectToInputRects([In] const RECT* outputRect,[Out, Buffer] RECT* inputRects,[In] unsigned int inputRectsCount)</unmanaged>
        /// <unmanaged-short>ID2D1Transform::MapOutputRectToInputRects</unmanaged-short>
        internal unsafe void MapOutputRectToInputRects_(SharpDX.Mathematics.Interop.RawRectangle outputRect, SharpDX.Mathematics.Interop.RawRectangle[] inputRects, System.Int32 inputRectsCount)
        {
            SharpDX.Result __result__;
            fixed (void *inputRects_ = inputRects)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &outputRect, inputRects_, inputRectsCount, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Performs the inverse mapping to <strong>MapOutputRectToInputRects</strong>.</p>
        /// </summary>
        /// <param name = "inputRects">No documentation.</param>
        /// <param name = "inputOpaqueSubRects">No documentation.</param>
        /// <param name = "inputRectCount">No documentation.</param>
        /// <param name = "outputOpaqueSubRect">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <remarks>
        /// <p>The transform implementation must ensure that any pixel shader or software callback implementation it provides honors this calculation.</p><p>Unlike the <strong>MapOutputRectToInputRects</strong> and <strong>MapInvalidRect</strong> functions, this method is explicitly called by the renderer at a determined place in its rendering algorithm. The transform implementation may change its state based on the input rectangles and use this information to control its rendering information. This method is always called before the <strong>MapInvalidRect</strong> and <strong>MapOutputRectToInputRects</strong> methods of the transform.</p>
        /// </remarks>
        /// <doc-id>hh446943</doc-id>
        /// <unmanaged>HRESULT ID2D1Transform::MapInputRectsToOutputRect([In, Buffer] const RECT* inputRects,[In, Buffer] const RECT* inputOpaqueSubRects,[In] unsigned int inputRectCount,[Out] RECT* outputRect,[Out] RECT* outputOpaqueSubRect)</unmanaged>
        /// <unmanaged-short>ID2D1Transform::MapInputRectsToOutputRect</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawRectangle MapInputRectsToOutputRect_(SharpDX.Mathematics.Interop.RawRectangle[] inputRects, SharpDX.Mathematics.Interop.RawRectangle[] inputOpaqueSubRects, System.Int32 inputRectCount, out SharpDX.Mathematics.Interop.RawRectangle outputOpaqueSubRect)
        {
            SharpDX.Mathematics.Interop.RawRectangle outputRect;
            outputOpaqueSubRect = default (SharpDX.Mathematics.Interop.RawRectangle);
            SharpDX.Result __result__;
            fixed (void *outputOpaqueSubRect_ = &outputOpaqueSubRect)
                fixed (void *inputOpaqueSubRects_ = inputOpaqueSubRects)
                    fixed (void *inputRects_ = inputRects)
                        __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, inputRects_, inputOpaqueSubRects_, inputRectCount, &outputRect, outputOpaqueSubRect_, (*(void ***)this._nativePointer)[5]);
            __result__.CheckError();
            return outputRect;
        }

        /// <summary>
        /// <p>Sets the input rectangles for this rendering pass into the transform.</p>
        /// </summary>
        /// <param name = "inputIndex"><dd>  <p>The index of the input rectangle.</p> </dd></param>
        /// <param name = "invalidInputRect"><dd>  <p>The invalid input rectangle.</p> </dd></param>
        /// <returns><dd>  <p>The output rectangle to which the input rectangle must be mapped.</p> </dd></returns>
        /// <remarks>
        /// <p>The transform implementation must regard <strong>MapInvalidRect</strong> as purely functional. The transform implementation can base the mapped input rectangle on the transform implementation's current state as specified by the encapsulating effect properties. But the transform implementation can't change its own state in response to a call to <strong>MapInvalidRect</strong>. Direct2D can call this method at any time and in any sequence following a call to the <strong>MapInputRectsToOutputRect</strong> method.
        /// </p>
        /// </remarks>
        /// <doc-id>hh446946</doc-id>
        /// <unmanaged>HRESULT ID2D1Transform::MapInvalidRect([In] unsigned int inputIndex,[In] RECT invalidInputRect,[Out] RECT* invalidOutputRect)</unmanaged>
        /// <unmanaged-short>ID2D1Transform::MapInvalidRect</unmanaged-short>
        internal unsafe SharpDX.Mathematics.Interop.RawRectangle MapInvalidRect_(System.Int32 inputIndex, SharpDX.Mathematics.Interop.RawRectangle invalidInputRect)
        {
            SharpDX.Mathematics.Interop.RawRectangle invalidOutputRect;
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint0(this._nativePointer, inputIndex, invalidInputRect, &invalidOutputRect, (*(void ***)this._nativePointer)[6]);
            __result__.CheckError();
            return invalidOutputRect;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("b2efe1e7-729f-4102-949f-505fa21bf666")]
    public partial interface TransformNode : SharpDX.IUnknown
    {
    }

    [System.Runtime.InteropServices.GuidAttribute("b2efe1e7-729f-4102-949f-505fa21bf666")]
    public partial class TransformNodeNative : SharpDX.ComObject, SharpDX.Direct2D1.TransformNode
    {
        public TransformNodeNative(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator TransformNodeNative(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new TransformNodeNative(nativePtr);
        /// <summary>
        /// <p>Gets the number of inputs to the transform node.</p>
        /// </summary>
        /// <doc-id>hh446940</doc-id>
        /// <unmanaged>GetInputCount</unmanaged>
        /// <unmanaged-short>GetInputCount</unmanaged-short>
        public System.Int32 InputCount_
        {
            get => GetInputCount_();
        }

        /// <summary>
        /// <p>Gets the number of inputs to the transform node.</p>
        /// </summary>
        /// <returns><p>This method returns the number of inputs to this transform node.</p></returns>
        /// <doc-id>hh446940</doc-id>
        /// <unmanaged>unsigned int ID2D1TransformNode::GetInputCount()</unmanaged>
        /// <unmanaged-short>ID2D1TransformNode::GetInputCount</unmanaged-short>
        internal unsafe System.Int32 GetInputCount_()
        {
            System.Int32 __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[3]);
            return __result__;
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("9b8b1336-00a5-4668-92b7-ced5d8bf9b7b")]
    public partial class VertexBuffer : SharpDX.ComObject
    {
        public VertexBuffer(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator VertexBuffer(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new VertexBuffer(nativePtr);
        /// <summary>
        /// <p>Maps the provided data into user memory.</p>
        /// </summary>
        /// <param name = "data"><dd>  <p>When this method returns, contains the address of a reference to the available buffer.</p> </dd></param>
        /// <param name = "bufferSize"><dd>  <p>The desired size of the buffer.</p> </dd></param>
        /// <returns><p>The method returns an <see cref = "SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td>E_INVALIDARG</td><td>An invalid parameter was passed to the returning function.</td></tr> <tr><td>D3DERR_DEVICELOST</td><td>The device has been lost but cannot be reset at this time.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p> If <em>data</em> is larger than <em>bufferSize</em>, this method fails. </p>
        /// </remarks>
        /// <doc-id>hh446951</doc-id>
        /// <unmanaged>HRESULT ID2D1VertexBuffer::Map([Out, Buffer] unsigned char** data,[In] unsigned int bufferSize)</unmanaged>
        /// <unmanaged-short>ID2D1VertexBuffer::Map</unmanaged-short>
        public unsafe void Map(System.Byte[] data, System.Int32 bufferSize)
        {
            SharpDX.Result __result__;
            fixed (void *data_ = data)
                __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, data_, bufferSize, (*(void ***)this._nativePointer)[3]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p>Unmaps the vertex buffer.</p>
        /// </summary>
        /// <returns><p>The method returns an <see cref = "SharpDX.Result"/>. Possible values include, but are not limited to, those in the following table.</p><p> </p><table> <tr><th><see cref = "SharpDX.Result"/></th><th>Description</th></tr> <tr><td><see cref = "SharpDX.Result.Ok"/></td><td>No error occurred.</td></tr> <tr><td><see cref = "WrongState"/></td><td>The object was not in the correct state to process the method.</td></tr> </table><p>?</p></returns>
        /// <remarks>
        /// <p>After this method returns, the mapped memory from the vertex buffer is no longer accessible by the effect.</p>
        /// </remarks>
        /// <doc-id>hh446967</doc-id>
        /// <unmanaged>HRESULT ID2D1VertexBuffer::Unmap()</unmanaged>
        /// <unmanaged-short>ID2D1VertexBuffer::Unmap</unmanaged-short>
        public unsafe void Unmap()
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, (*(void ***)this._nativePointer)[4]);
            __result__.CheckError();
        }
    }

    [System.Runtime.InteropServices.GuidAttribute("2cd90698-12e2-11dc-9fed-001143a055f9")]
    public partial class WindowRenderTarget : SharpDX.Direct2D1.RenderTarget
    {
        public WindowRenderTarget(System.IntPtr nativePtr): base (nativePtr)
        {
        }

        public static explicit operator WindowRenderTarget(System.IntPtr nativePtr) => nativePtr == System.IntPtr.Zero ? null : new WindowRenderTarget(nativePtr);
        /// <summary>
        /// <p> Returns the <see cref = "System.IntPtr"/> associated with this render target.</p>
        /// </summary>
        /// <doc-id>dd371470</doc-id>
        /// <unmanaged>GetHwnd</unmanaged>
        /// <unmanaged-short>GetHwnd</unmanaged-short>
        public System.IntPtr Hwnd
        {
            get => GetHwnd();
        }

        /// <summary>
        /// <p>Indicates whether the <see cref = "System.IntPtr"/> associated with this render target is occluded. </p>
        /// </summary>
        /// <returns><p>A value that indicates whether the <see cref = "System.IntPtr"/> associated with this render target is occluded.</p></returns>
        /// <remarks>
        /// <strong>Note</strong>??If the window was occluded the last time  that <strong>EndDraw</strong> was called, the next time that the render target calls <strong>CheckWindowState</strong>, it will return <strong>D2D1_WINDOW_STATE_OCCLUDED</strong> regardless of the current window state. If you want to use <strong>CheckWindowState</strong> to determine the current window state, you should call <strong>CheckWindowState</strong> after every <strong>EndDraw</strong> call and ignore its return value. This call will ensure that your next call to <strong>CheckWindowState</strong> state will return the actual window state.?
        /// </remarks>
        /// <doc-id>dd371466</doc-id>
        /// <unmanaged>D2D1_WINDOW_STATE ID2D1HwndRenderTarget::CheckWindowState()</unmanaged>
        /// <unmanaged-short>ID2D1HwndRenderTarget::CheckWindowState</unmanaged-short>
        public unsafe SharpDX.Direct2D1.WindowState CheckWindowState()
        {
            SharpDX.Direct2D1.WindowState __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSharpDXDirect2D1WindowState(this._nativePointer, (*(void ***)this._nativePointer)[57]);
            return __result__;
        }

        /// <summary>
        /// Changes the size of the render target to the specified pixel size.
        /// </summary>
        /// <param name = "ixelSizeRef">No documentation.</param>
        /// <returns>No documentation.</returns>
        /// <remarks>
        /// <p>After this method is called, the contents of the render target's back-buffer are not defined, even if the <strong>D2D1_PRESENT_OPTIONS_RETAIN_CONTENTS</strong> option was specified when the render target was created.</p>
        /// </remarks>
        /// <doc-id>dd742774</doc-id>
        /// <unmanaged>HRESULT ID2D1HwndRenderTarget::Resize([In] const D2D_SIZE_U* pixelSize)</unmanaged>
        /// <unmanaged-short>ID2D1HwndRenderTarget::Resize</unmanaged-short>
        public unsafe void Resize(SharpDX.Size2 ixelSizeRef)
        {
            SharpDX.Result __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallint(this._nativePointer, &ixelSizeRef, (*(void ***)this._nativePointer)[58]);
            __result__.CheckError();
        }

        /// <summary>
        /// <p> Returns the <see cref = "System.IntPtr"/> associated with this render target.</p>
        /// </summary>
        /// <returns><p>The <see cref = "System.IntPtr"/> associated with this render target.</p></returns>
        /// <doc-id>dd371470</doc-id>
        /// <unmanaged>HWND ID2D1HwndRenderTarget::GetHwnd()</unmanaged>
        /// <unmanaged-short>ID2D1HwndRenderTarget::GetHwnd</unmanaged-short>
        internal unsafe System.IntPtr GetHwnd()
        {
            System.IntPtr __result__;
            __result__ = SharpDX.Direct2D1.LocalInterop.CalliStdCallSystemIntPtr(this._nativePointer, (*(void ***)this._nativePointer)[59]);
            return __result__;
        }
    }
}